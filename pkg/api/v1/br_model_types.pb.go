// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: br_model_types.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ChangeDirection specifies if it is allowed / should be avoided to change
// direction in a block, or is it allowed / should is be avoided that a loc
// changes direction?
type ChangeDirection int32

const (
	// ALLOW indicates that changing direction is allowed
	ChangeDirection_ALLOW ChangeDirection = 0
	// AVOID indicates that changing direction should be avoided
	ChangeDirection_AVOID ChangeDirection = 1
)

var ChangeDirection_name = map[int32]string{
	0: "ALLOW",
	1: "AVOID",
}

var ChangeDirection_value = map[string]int32{
	"ALLOW": 0,
	"AVOID": 1,
}

func (x ChangeDirection) String() string {
	return proto.EnumName(ChangeDirection_name, int32(x))
}

func (ChangeDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{0}
}

// Type of vehicle.
type VehicleType int32

const (
	// LOC indicates a locomotive.
	VehicleType_LOC VehicleType = 0
	// CAR indicates a car.
	VehicleType_CAR VehicleType = 1
)

var VehicleType_name = map[int32]string{
	0: "LOC",
	1: "CAR",
}

var VehicleType_value = map[string]int32{
	"LOC": 0,
	"CAR": 1,
}

func (x VehicleType) String() string {
	return proto.EnumName(VehicleType_name, int32(x))
}

func (VehicleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{1}
}

// Type of local worker
type BinkyNetLocalWorkerType int32

const (
	// Local worker runs linux.
	BinkyNetLocalWorkerType_LINUX BinkyNetLocalWorkerType = 0
	// Local worker runs Esphome.
	BinkyNetLocalWorkerType_ESPHOME BinkyNetLocalWorkerType = 1
)

var BinkyNetLocalWorkerType_name = map[int32]string{
	0: "LINUX",
	1: "ESPHOME",
}

var BinkyNetLocalWorkerType_value = map[string]int32{
	"LINUX":   0,
	"ESPHOME": 1,
}

func (x BinkyNetLocalWorkerType) String() string {
	return proto.EnumName(BinkyNetLocalWorkerType_name, int32(x))
}

func (BinkyNetLocalWorkerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{2}
}

type BinkyNetDeviceType int32

const (
	// DeviceTypeMCP23008 is the device type of a General Purpose I/O
	BinkyNetDeviceType_MCP23008 BinkyNetDeviceType = 0
	// DeviceTypeMCP23017 is the device type of a General Purpose I/O
	BinkyNetDeviceType_MCP23017 BinkyNetDeviceType = 1
	// DeviceTypePCA9685 is the device type of a Pulse Width Modulation device
	BinkyNetDeviceType_PCA9685 BinkyNetDeviceType = 2
	// DeviceTypePCF8574 is the device type of a General Purpose I/O
	BinkyNetDeviceType_PCF8574 BinkyNetDeviceType = 3
	// DeviceTypeADS1115 is the device type of a A/D conversion
	BinkyNetDeviceType_ADS1115 BinkyNetDeviceType = 4
	// DeviceTypeBinkyCarSensor is the device type of a Binky Car Sensor.
	// See https://easyeda.com/editor?from=oshwlab#id=4b79ca953a7e4ea8971153b438ae1339|5964111c75b2459481dac75f8581f77e
	BinkyNetDeviceType_BINKYCARSENSOR BinkyNetDeviceType = 5
	// DeviceTypeMQTTGPIO is the device type of an MQTT input/output device
	BinkyNetDeviceType_MQTT_GPIO BinkyNetDeviceType = 6
	// DeviceTypeMQTTServo is the device type of an MQTT servo device
	BinkyNetDeviceType_MQTT_SERVO BinkyNetDeviceType = 7
	// DeviceTypeGPIO is the device type of a General Purpose I/O on the localworker / router
	BinkyNetDeviceType_GPIO BinkyNetDeviceType = 8
)

var BinkyNetDeviceType_name = map[int32]string{
	0: "MCP23008",
	1: "MCP23017",
	2: "PCA9685",
	3: "PCF8574",
	4: "ADS1115",
	5: "BINKYCARSENSOR",
	6: "MQTT_GPIO",
	7: "MQTT_SERVO",
	8: "GPIO",
}

var BinkyNetDeviceType_value = map[string]int32{
	"MCP23008":       0,
	"MCP23017":       1,
	"PCA9685":        2,
	"PCF8574":        3,
	"ADS1115":        4,
	"BINKYCARSENSOR": 5,
	"MQTT_GPIO":      6,
	"MQTT_SERVO":     7,
	"GPIO":           8,
}

func (x BinkyNetDeviceType) String() string {
	return proto.EnumName(BinkyNetDeviceType_name, int32(x))
}

func (BinkyNetDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{3}
}

type BinkyNetObjectType int32

const (
	// ObjectTypeBinarySensor is the object type of a single-bit on/off sensor
	BinkyNetObjectType_BINARYSENSOR BinkyNetObjectType = 0
	// ObjectTypeBinaryOutput is the object type of a single-bit on/off output
	BinkyNetObjectType_BINARYOUTPUT BinkyNetObjectType = 1
	// ObjectTypeServoSwitch is the object type of a servo driven switch, with an
	// option phase switching relay.
	BinkyNetObjectType_SERVOSWITCH BinkyNetObjectType = 2
	// ObjectTypeRelaySwitch is the object type of a double relay driven switch,
	// with an option phase switching relay.
	BinkyNetObjectType_RELAYSWITCH BinkyNetObjectType = 3
	// ObjectTypeTrackInverter is the object type of a four relay based track
	// power inverter.
	BinkyNetObjectType_TRACKINVERTER BinkyNetObjectType = 4
	// ObjectTypeMagneticSwitch is the object type of switch that a single magnetic coil per direction.
	// The coil has to stay activated.
	BinkyNetObjectType_MAGNETICSWITCH BinkyNetObjectType = 5
)

var BinkyNetObjectType_name = map[int32]string{
	0: "BINARYSENSOR",
	1: "BINARYOUTPUT",
	2: "SERVOSWITCH",
	3: "RELAYSWITCH",
	4: "TRACKINVERTER",
	5: "MAGNETICSWITCH",
}

var BinkyNetObjectType_value = map[string]int32{
	"BINARYSENSOR":   0,
	"BINARYOUTPUT":   1,
	"SERVOSWITCH":    2,
	"RELAYSWITCH":    3,
	"TRACKINVERTER":  4,
	"MAGNETICSWITCH": 5,
}

func (x BinkyNetObjectType) String() string {
	return proto.EnumName(BinkyNetObjectType_name, int32(x))
}

func (BinkyNetObjectType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{4}
}

type SwitchDirection int32

const (
	// STRAIGHT indicates the switch in its straight position
	SwitchDirection_STRAIGHT SwitchDirection = 0
	// OFF indicates the switch in its off position
	SwitchDirection_OFF SwitchDirection = 1
)

var SwitchDirection_name = map[int32]string{
	0: "STRAIGHT",
	1: "OFF",
}

var SwitchDirection_value = map[string]int32{
	"STRAIGHT": 0,
	"OFF":      1,
}

func (x SwitchDirection) String() string {
	return proto.EnumName(SwitchDirection_name, int32(x))
}

func (SwitchDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{5}
}

type BinaryOutputType int32

const (
	// DEFAULT indicates a standard on/off switch
	BinaryOutputType_BOT_DEFAULT BinaryOutputType = 0
	// TRACKINVERTER indicates a digital track inverter
	BinaryOutputType_BOT_TRACKINVERTER BinaryOutputType = 1
)

var BinaryOutputType_name = map[int32]string{
	0: "BOT_DEFAULT",
	1: "BOT_TRACKINVERTER",
}

var BinaryOutputType_value = map[string]int32{
	"BOT_DEFAULT":       0,
	"BOT_TRACKINVERTER": 1,
}

func (x BinaryOutputType) String() string {
	return proto.EnumName(BinaryOutputType_name, int32(x))
}

func (BinaryOutputType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{6}
}

// Side of a block
type BlockSide int32

const (
	// FRONT indicates the end of normal driving direction
	BlockSide_FRONT BlockSide = 0
	// BACK indicates the begining of normal driving direction
	BlockSide_BACK BlockSide = 1
)

var BlockSide_name = map[int32]string{
	0: "FRONT",
	1: "BACK",
}

var BlockSide_value = map[string]int32{
	"FRONT": 0,
	"BACK":  1,
}

func (x BlockSide) String() string {
	return proto.EnumName(BlockSide_name, int32(x))
}

func (BlockSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{7}
}

type RouteStateBehavior int32

const (
	// NOCHANGE indicates that the state does not change
	RouteStateBehavior_RSB_NOCHANGE RouteStateBehavior = 0
	// ENTER indicates that the loc has entered the To block.
	RouteStateBehavior_RSB_ENTER RouteStateBehavior = 1
	// REACHED indicates that the loc has reached the To block.
	RouteStateBehavior_RSB_REACHED RouteStateBehavior = 2
)

var RouteStateBehavior_name = map[int32]string{
	0: "RSB_NOCHANGE",
	1: "RSB_ENTER",
	2: "RSB_REACHED",
}

var RouteStateBehavior_value = map[string]int32{
	"RSB_NOCHANGE": 0,
	"RSB_ENTER":    1,
	"RSB_REACHED":  2,
}

func (x RouteStateBehavior) String() string {
	return proto.EnumName(RouteStateBehavior_name, int32(x))
}

func (RouteStateBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{8}
}

type LocSpeedBehavior int32

const (
	// LocSpeedBehaviorDefault indicates the speed change is controlled by state
	// behavior
	LocSpeedBehavior_LSB_DEFAULT LocSpeedBehavior = 0
	// LocSpeedBehaviorNoChange indicates no change in speed
	LocSpeedBehavior_LSB_NOCHANGE LocSpeedBehavior = 1
	// LocSpeedBehaviorMedium indicates that the speed is set to medium speed.
	LocSpeedBehavior_LSB_MEDIUM LocSpeedBehavior = 2
	// LocSpeedBehaviorMinimum indicates that the speed is set to minimum speed.
	LocSpeedBehavior_LSB_MINIMUM LocSpeedBehavior = 3
	// LocSpeedBehaviorMaximum indicates that the speed is set to maximum speed.
	LocSpeedBehavior_LSB_MAXIMUM LocSpeedBehavior = 4
)

var LocSpeedBehavior_name = map[int32]string{
	0: "LSB_DEFAULT",
	1: "LSB_NOCHANGE",
	2: "LSB_MEDIUM",
	3: "LSB_MINIMUM",
	4: "LSB_MAXIMUM",
}

var LocSpeedBehavior_value = map[string]int32{
	"LSB_DEFAULT":  0,
	"LSB_NOCHANGE": 1,
	"LSB_MEDIUM":   2,
	"LSB_MINIMUM":  3,
	"LSB_MAXIMUM":  4,
}

func (x LocSpeedBehavior) String() string {
	return proto.EnumName(LocSpeedBehavior_name, int32(x))
}

func (LocSpeedBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{9}
}

type Shape int32

const (
	// Circle
	Shape_CIRCLE Shape = 0
	// Triangle
	Shape_TRIANGLE Shape = 1
	// Square
	Shape_SQUARE Shape = 2
	// Diamond
	Shape_DIAMOND Shape = 3
)

var Shape_name = map[int32]string{
	0: "CIRCLE",
	1: "TRIANGLE",
	2: "SQUARE",
	3: "DIAMOND",
}

var Shape_value = map[string]int32{
	"CIRCLE":   0,
	"TRIANGLE": 1,
	"SQUARE":   2,
	"DIAMOND":  3,
}

func (x Shape) String() string {
	return proto.EnumName(Shape_name, int32(x))
}

func (Shape) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{10}
}

// BlockSignalType indicates a type of block signal.
type BlockSignalType int32

const (
	// ENTRY indicates the type of signal that shows if a block can be entered.
	BlockSignalType_ENTRY BlockSignalType = 0
	// EXIT indicates the type of signal that shows if a block can be left.
	BlockSignalType_EXIT BlockSignalType = 1
)

var BlockSignalType_name = map[int32]string{
	0: "ENTRY",
	1: "EXIT",
}

var BlockSignalType_value = map[string]int32{
	"ENTRY": 0,
	"EXIT":  1,
}

func (x BlockSignalType) String() string {
	return proto.EnumName(BlockSignalType_name, int32(x))
}

func (BlockSignalType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{11}
}

// Empty message
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// Raw image content
type Image struct {
	// Base64 encoded image data
	ContentBase64        string   `protobuf:"bytes,1,opt,name=content_base64,json=contentBase64,proto3" json:"content_base64,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Image) Reset()         { *m = Image{} }
func (m *Image) String() string { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()    {}
func (*Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{1}
}
func (m *Image) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Image.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Image.Merge(m, src)
}
func (m *Image) XXX_Size() int {
	return m.Size()
}
func (m *Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Image proto.InternalMessageInfo

func (m *Image) GetContentBase64() string {
	if m != nil {
		return m.ContentBase64
	}
	return ""
}

// Railway contrains a description of a single model railway.
type Railway struct {
	// Unique ID of the railway
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable description of the railway
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Does the railway have unsaved changed?
	Dirty bool `protobuf:"varint,3,opt,name=dirty,proto3" json:"dirty,omitempty"`
	// Modules visible on this railway
	Modules []*ModuleRef `protobuf:"bytes,100,rep,name=modules,proto3" json:"modules,omitempty"`
	// Locs visible on this railway
	Locs []*LocRef `protobuf:"bytes,101,rep,name=locs,proto3" json:"locs,omitempty"`
	// Loc groups visible on this railway
	LocGroups []*LocGroupRef `protobuf:"bytes,102,rep,name=locGroups,proto3" json:"locGroups,omitempty"`
	// Command stations visible on this railway;
	CommandStations      []*CommandStationRef `protobuf:"bytes,103,rep,name=commandStations,proto3" json:"commandStations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Railway) Reset()         { *m = Railway{} }
func (m *Railway) String() string { return proto.CompactTextString(m) }
func (*Railway) ProtoMessage()    {}
func (*Railway) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{2}
}
func (m *Railway) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Railway) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Railway.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Railway) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Railway.Merge(m, src)
}
func (m *Railway) XXX_Size() int {
	return m.Size()
}
func (m *Railway) XXX_DiscardUnknown() {
	xxx_messageInfo_Railway.DiscardUnknown(m)
}

var xxx_messageInfo_Railway proto.InternalMessageInfo

func (m *Railway) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Railway) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Railway) GetDirty() bool {
	if m != nil {
		return m.Dirty
	}
	return false
}

func (m *Railway) GetModules() []*ModuleRef {
	if m != nil {
		return m.Modules
	}
	return nil
}

func (m *Railway) GetLocs() []*LocRef {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *Railway) GetLocGroups() []*LocGroupRef {
	if m != nil {
		return m.LocGroups
	}
	return nil
}

func (m *Railway) GetCommandStations() []*CommandStationRef {
	if m != nil {
		return m.CommandStations
	}
	return nil
}

// Module of a railway
type Module struct {
	// Unique ID of the module
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable description of the module
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Horizontal size (in pixels).
	Width int32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	// Vertical size (in pixels).
	Height int32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	// Does this module have a background image
	HasBackgroundImage bool `protobuf:"varint,5,opt,name=has_background_image,json=hasBackgroundImage,proto3" json:"has_background_image,omitempty"`
	// URL of background image of the module
	BackgroundImageUrl string `protobuf:"bytes,6,opt,name=background_image_url,json=backgroundImageUrl,proto3" json:"background_image_url,omitempty"`
	// Blocks of this module
	Blocks []*BlockRef `protobuf:"bytes,100,rep,name=blocks,proto3" json:"blocks,omitempty"`
	// Blocks of this module
	BlockGroups []*BlockGroupRef `protobuf:"bytes,101,rep,name=blockGroups,proto3" json:"blockGroups,omitempty"`
	// Edges of this module
	Edges []*EdgeRef `protobuf:"bytes,102,rep,name=edges,proto3" json:"edges,omitempty"`
	// Junctions of this module
	Junctions []*JunctionRef `protobuf:"bytes,103,rep,name=junctions,proto3" json:"junctions,omitempty"`
	// Outputs of this module
	Outputs []*OutputRef `protobuf:"bytes,104,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// Routes of this module
	Routes []*RouteRef `protobuf:"bytes,105,rep,name=routes,proto3" json:"routes,omitempty"`
	// Sensors of this module
	Sensors []*SensorRef `protobuf:"bytes,106,rep,name=sensors,proto3" json:"sensors,omitempty"`
	// Signals of this module
	Signals []*SignalRef `protobuf:"bytes,107,rep,name=signals,proto3" json:"signals,omitempty"`
	// All layers used in this module
	Layers               []string `protobuf:"bytes,200,rep,name=layers,proto3" json:"layers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Module) Reset()         { *m = Module{} }
func (m *Module) String() string { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()    {}
func (*Module) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{3}
}
func (m *Module) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Module) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Module.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Module) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Module.Merge(m, src)
}
func (m *Module) XXX_Size() int {
	return m.Size()
}
func (m *Module) XXX_DiscardUnknown() {
	xxx_messageInfo_Module.DiscardUnknown(m)
}

var xxx_messageInfo_Module proto.InternalMessageInfo

func (m *Module) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Module) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Module) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Module) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Module) GetHasBackgroundImage() bool {
	if m != nil {
		return m.HasBackgroundImage
	}
	return false
}

func (m *Module) GetBackgroundImageUrl() string {
	if m != nil {
		return m.BackgroundImageUrl
	}
	return ""
}

func (m *Module) GetBlocks() []*BlockRef {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *Module) GetBlockGroups() []*BlockGroupRef {
	if m != nil {
		return m.BlockGroups
	}
	return nil
}

func (m *Module) GetEdges() []*EdgeRef {
	if m != nil {
		return m.Edges
	}
	return nil
}

func (m *Module) GetJunctions() []*JunctionRef {
	if m != nil {
		return m.Junctions
	}
	return nil
}

func (m *Module) GetOutputs() []*OutputRef {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Module) GetRoutes() []*RouteRef {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *Module) GetSensors() []*SensorRef {
	if m != nil {
		return m.Sensors
	}
	return nil
}

func (m *Module) GetSignals() []*SignalRef {
	if m != nil {
		return m.Signals
	}
	return nil
}

func (m *Module) GetLayers() []string {
	if m != nil {
		return m.Layers
	}
	return nil
}

// Reference to a module
type ModuleRef struct {
	// ID of the module
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Position of the module
	Position *Position `protobuf:"bytes,2,opt,name=position,proto3" json:"position,omitempty"`
	// Zoom factor of the module (100 == 100%)
	ZoomFactor int32 `protobuf:"varint,3,opt,name=zoom_factor,json=zoomFactor,proto3" json:"zoom_factor,omitempty"`
	// If locked, the module cannot be moved.
	Locked               bool     `protobuf:"varint,4,opt,name=locked,proto3" json:"locked,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModuleRef) Reset()         { *m = ModuleRef{} }
func (m *ModuleRef) String() string { return proto.CompactTextString(m) }
func (*ModuleRef) ProtoMessage()    {}
func (*ModuleRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{4}
}
func (m *ModuleRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleRef.Merge(m, src)
}
func (m *ModuleRef) XXX_Size() int {
	return m.Size()
}
func (m *ModuleRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleRef.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleRef proto.InternalMessageInfo

func (m *ModuleRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModuleRef) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *ModuleRef) GetZoomFactor() int32 {
	if m != nil {
		return m.ZoomFactor
	}
	return 0
}

func (m *ModuleRef) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

// Visual position on a grid
type Position struct {
	// Horizontal offset from left of the screen (in pixels).
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	// Vertical offset from top of the screen (in pixels).
	Y int32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	// Horizontal size (in pixels).
	Width int32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	// Vertical size (in pixels).
	Height int32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	// Rotation in degrees.
	Rotation int32 `protobuf:"varint,5,opt,name=rotation,proto3" json:"rotation,omitempty"`
	// Optional layer.
	Layer                string   `protobuf:"bytes,6,opt,name=layer,proto3" json:"layer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{5}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Position) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Position) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Position) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Position) GetRotation() int32 {
	if m != nil {
		return m.Rotation
	}
	return 0
}

func (m *Position) GetLayer() string {
	if m != nil {
		return m.Layer
	}
	return ""
}

// Information of a locomotive
type Loc struct {
	// Unique ID of the loc
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the loc
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Name of the person that owns this loc.
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// Remarks (free text) about this loc.
	Remarks string `protobuf:"bytes,4,opt,name=remarks,proto3" json:"remarks,omitempty"`
	// Address of the loc.
	Address string `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	// URL of image of the loc
	ImageUrl string `protobuf:"bytes,6,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	// Percentage of speed steps for the slowest speed of this loc.
	// Value between 1 and 100.
	SlowSpeed int32 `protobuf:"varint,100,opt,name=slow_speed,json=slowSpeed,proto3" json:"slow_speed,omitempty"`
	// Percentage of speed steps for the medium speed of this loc.
	// Value between 1 and 100.
	MediumSpeed int32 `protobuf:"varint,101,opt,name=medium_speed,json=mediumSpeed,proto3" json:"medium_speed,omitempty"`
	// Percentage of speed steps for the maximum speed of this loc.
	// Value between 1 and 100.
	MaximumSpeed int32 `protobuf:"varint,102,opt,name=maximum_speed,json=maximumSpeed,proto3" json:"maximum_speed,omitempty"`
	// Number of speed steps supported by this loc.
	SpeedSteps int32 `protobuf:"varint,110,opt,name=speed_steps,json=speedSteps,proto3" json:"speed_steps,omitempty"`
	// Is it allowed for this loc to change direction?
	ChangeDirection ChangeDirection `protobuf:"varint,120,opt,name=change_direction,json=changeDirection,proto3,enum=binkyrailways.v1.ChangeDirection" json:"change_direction,omitempty"`
	// Type of vehicle.
	VehicleType          VehicleType `protobuf:"varint,121,opt,name=vehicle_type,json=vehicleType,proto3,enum=binkyrailways.v1.VehicleType" json:"vehicle_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Loc) Reset()         { *m = Loc{} }
func (m *Loc) String() string { return proto.CompactTextString(m) }
func (*Loc) ProtoMessage()    {}
func (*Loc) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{6}
}
func (m *Loc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Loc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Loc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Loc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Loc.Merge(m, src)
}
func (m *Loc) XXX_Size() int {
	return m.Size()
}
func (m *Loc) XXX_DiscardUnknown() {
	xxx_messageInfo_Loc.DiscardUnknown(m)
}

var xxx_messageInfo_Loc proto.InternalMessageInfo

func (m *Loc) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Loc) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Loc) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Loc) GetRemarks() string {
	if m != nil {
		return m.Remarks
	}
	return ""
}

func (m *Loc) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Loc) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

func (m *Loc) GetSlowSpeed() int32 {
	if m != nil {
		return m.SlowSpeed
	}
	return 0
}

func (m *Loc) GetMediumSpeed() int32 {
	if m != nil {
		return m.MediumSpeed
	}
	return 0
}

func (m *Loc) GetMaximumSpeed() int32 {
	if m != nil {
		return m.MaximumSpeed
	}
	return 0
}

func (m *Loc) GetSpeedSteps() int32 {
	if m != nil {
		return m.SpeedSteps
	}
	return 0
}

func (m *Loc) GetChangeDirection() ChangeDirection {
	if m != nil {
		return m.ChangeDirection
	}
	return ChangeDirection_ALLOW
}

func (m *Loc) GetVehicleType() VehicleType {
	if m != nil {
		return m.VehicleType
	}
	return VehicleType_LOC
}

// Reference to a loc
type LocRef struct {
	// ID of the loc
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocRef) Reset()         { *m = LocRef{} }
func (m *LocRef) String() string { return proto.CompactTextString(m) }
func (*LocRef) ProtoMessage()    {}
func (*LocRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{7}
}
func (m *LocRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocRef.Merge(m, src)
}
func (m *LocRef) XXX_Size() int {
	return m.Size()
}
func (m *LocRef) XXX_DiscardUnknown() {
	xxx_messageInfo_LocRef.DiscardUnknown(m)
}

var xxx_messageInfo_LocRef proto.InternalMessageInfo

func (m *LocRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type LocGroup struct {
	// ID of the loc group
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the loc group
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Locs included in this group
	Locs                 []*LocRef `protobuf:"bytes,3,rep,name=locs,proto3" json:"locs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LocGroup) Reset()         { *m = LocGroup{} }
func (m *LocGroup) String() string { return proto.CompactTextString(m) }
func (*LocGroup) ProtoMessage()    {}
func (*LocGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{8}
}
func (m *LocGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocGroup.Merge(m, src)
}
func (m *LocGroup) XXX_Size() int {
	return m.Size()
}
func (m *LocGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_LocGroup.DiscardUnknown(m)
}

var xxx_messageInfo_LocGroup proto.InternalMessageInfo

func (m *LocGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LocGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *LocGroup) GetLocs() []*LocRef {
	if m != nil {
		return m.Locs
	}
	return nil
}

type LocGroupRef struct {
	// ID of the loc group
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocGroupRef) Reset()         { *m = LocGroupRef{} }
func (m *LocGroupRef) String() string { return proto.CompactTextString(m) }
func (*LocGroupRef) ProtoMessage()    {}
func (*LocGroupRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{9}
}
func (m *LocGroupRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocGroupRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocGroupRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocGroupRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocGroupRef.Merge(m, src)
}
func (m *LocGroupRef) XXX_Size() int {
	return m.Size()
}
func (m *LocGroupRef) XXX_DiscardUnknown() {
	xxx_messageInfo_LocGroupRef.DiscardUnknown(m)
}

var xxx_messageInfo_LocGroupRef proto.InternalMessageInfo

func (m *LocGroupRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type CommandStation struct {
	// ID of the command station
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the command station
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// The names of address spaces served by this command station
	AddressSpaces []string `protobuf:"bytes,3,rep,name=address_spaces,json=addressSpaces,proto3" json:"address_spaces,omitempty"`
	// Settings of bidib command station
	BidibCommandStation *BidibCommandStation `protobuf:"bytes,11,opt,name=bidib_command_station,json=bidibCommandStation,proto3" json:"bidib_command_station,omitempty"`
	// Settings of binkynet command station
	BinkynetCommandStation *BinkyNetCommandStation `protobuf:"bytes,10,opt,name=binkynet_command_station,json=binkynetCommandStation,proto3" json:"binkynet_command_station,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *CommandStation) Reset()         { *m = CommandStation{} }
func (m *CommandStation) String() string { return proto.CompactTextString(m) }
func (*CommandStation) ProtoMessage()    {}
func (*CommandStation) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{10}
}
func (m *CommandStation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandStation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStation.Merge(m, src)
}
func (m *CommandStation) XXX_Size() int {
	return m.Size()
}
func (m *CommandStation) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStation.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStation proto.InternalMessageInfo

func (m *CommandStation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CommandStation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CommandStation) GetAddressSpaces() []string {
	if m != nil {
		return m.AddressSpaces
	}
	return nil
}

func (m *CommandStation) GetBidibCommandStation() *BidibCommandStation {
	if m != nil {
		return m.BidibCommandStation
	}
	return nil
}

func (m *CommandStation) GetBinkynetCommandStation() *BinkyNetCommandStation {
	if m != nil {
		return m.BinkynetCommandStation
	}
	return nil
}

type CommandStationRef struct {
	// ID of the command station
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandStationRef) Reset()         { *m = CommandStationRef{} }
func (m *CommandStationRef) String() string { return proto.CompactTextString(m) }
func (*CommandStationRef) ProtoMessage()    {}
func (*CommandStationRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{11}
}
func (m *CommandStationRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStationRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStationRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandStationRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStationRef.Merge(m, src)
}
func (m *CommandStationRef) XXX_Size() int {
	return m.Size()
}
func (m *CommandStationRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStationRef.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStationRef proto.InternalMessageInfo

func (m *CommandStationRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type BidibCommandStation struct {
	// Name of serial port device to which the bidib interface is connected
	SerialPortName       string   `protobuf:"bytes,1,opt,name=serial_port_name,json=serialPortName,proto3" json:"serial_port_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BidibCommandStation) Reset()         { *m = BidibCommandStation{} }
func (m *BidibCommandStation) String() string { return proto.CompactTextString(m) }
func (*BidibCommandStation) ProtoMessage()    {}
func (*BidibCommandStation) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{12}
}
func (m *BidibCommandStation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BidibCommandStation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BidibCommandStation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BidibCommandStation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BidibCommandStation.Merge(m, src)
}
func (m *BidibCommandStation) XXX_Size() int {
	return m.Size()
}
func (m *BidibCommandStation) XXX_DiscardUnknown() {
	xxx_messageInfo_BidibCommandStation.DiscardUnknown(m)
}

var xxx_messageInfo_BidibCommandStation proto.InternalMessageInfo

func (m *BidibCommandStation) GetSerialPortName() string {
	if m != nil {
		return m.SerialPortName
	}
	return ""
}

type BinkyNetCommandStation struct {
	// Network host address (defaults to 0.0.0.0)
	ServerHost string `protobuf:"bytes,1,opt,name=server_host,json=serverHost,proto3" json:"server_host,omitempty"`
	// Network Port of the command station
	GrpcPort int32 `protobuf:"varint,2,opt,name=grpc_port,json=grpcPort,proto3" json:"grpc_port,omitempty"`
	// The required version of local workers
	RequiredWorkerVersion string `protobuf:"bytes,3,opt,name=required_worker_version,json=requiredWorkerVersion,proto3" json:"required_worker_version,omitempty"`
	// Gets the configuration of local workers on the Binky network
	// that this command station is attached to.
	LocalWorkers []*BinkyNetLocalWorkerRef `protobuf:"bytes,4,rep,name=local_workers,json=localWorkers,proto3" json:"local_workers,omitempty"`
	// If set, do not configure objects that are not used
	ExcludeUnusedObjects bool `protobuf:"varint,5,opt,name=exclude_unused_objects,json=excludeUnusedObjects,proto3" json:"exclude_unused_objects,omitempty"`
	// DNS domain to use
	Domain               string   `protobuf:"bytes,6,opt,name=domain,proto3" json:"domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetCommandStation) Reset()         { *m = BinkyNetCommandStation{} }
func (m *BinkyNetCommandStation) String() string { return proto.CompactTextString(m) }
func (*BinkyNetCommandStation) ProtoMessage()    {}
func (*BinkyNetCommandStation) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{13}
}
func (m *BinkyNetCommandStation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetCommandStation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetCommandStation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetCommandStation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetCommandStation.Merge(m, src)
}
func (m *BinkyNetCommandStation) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetCommandStation) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetCommandStation.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetCommandStation proto.InternalMessageInfo

func (m *BinkyNetCommandStation) GetServerHost() string {
	if m != nil {
		return m.ServerHost
	}
	return ""
}

func (m *BinkyNetCommandStation) GetGrpcPort() int32 {
	if m != nil {
		return m.GrpcPort
	}
	return 0
}

func (m *BinkyNetCommandStation) GetRequiredWorkerVersion() string {
	if m != nil {
		return m.RequiredWorkerVersion
	}
	return ""
}

func (m *BinkyNetCommandStation) GetLocalWorkers() []*BinkyNetLocalWorkerRef {
	if m != nil {
		return m.LocalWorkers
	}
	return nil
}

func (m *BinkyNetCommandStation) GetExcludeUnusedObjects() bool {
	if m != nil {
		return m.ExcludeUnusedObjects
	}
	return false
}

func (m *BinkyNetCommandStation) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

// Configuration of a binky local worker
type BinkyNetLocalWorker struct {
	// ID of the local worker
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the local worker
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the command station containing this worker
	CommandStationId string `protobuf:"bytes,3,opt,name=command_station_id,json=commandStationId,proto3" json:"command_station_id,omitempty"`
	// Hardware ID of the local worker.
	HardwareId string `protobuf:"bytes,4,opt,name=hardware_id,json=hardwareId,proto3" json:"hardware_id,omitempty"`
	// Optional alias for the local worker.
	Alias string `protobuf:"bytes,5,opt,name=alias,proto3" json:"alias,omitempty"`
	// Type of local worker
	LocalWorkerType BinkyNetLocalWorkerType `protobuf:"varint,6,opt,name=local_worker_type,json=localWorkerType,proto3,enum=binkyrailways.v1.BinkyNetLocalWorkerType" json:"local_worker_type,omitempty"`
	// Set of devices that must be configured on this local worker.
	Devices []*BinkyNetDevice `protobuf:"bytes,10,rep,name=devices,proto3" json:"devices,omitempty"`
	// Set of real world objects controlled by the local worker
	Objects []*BinkyNetObject `protobuf:"bytes,11,rep,name=objects,proto3" json:"objects,omitempty"`
	// Set of hardware devices that route commands & state to/from devices belonging to this local worker.
	Routers              []*BinkyNetRouter `protobuf:"bytes,12,rep,name=routers,proto3" json:"routers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BinkyNetLocalWorker) Reset()         { *m = BinkyNetLocalWorker{} }
func (m *BinkyNetLocalWorker) String() string { return proto.CompactTextString(m) }
func (*BinkyNetLocalWorker) ProtoMessage()    {}
func (*BinkyNetLocalWorker) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{14}
}
func (m *BinkyNetLocalWorker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetLocalWorker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetLocalWorker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetLocalWorker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetLocalWorker.Merge(m, src)
}
func (m *BinkyNetLocalWorker) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetLocalWorker) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetLocalWorker.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetLocalWorker proto.InternalMessageInfo

func (m *BinkyNetLocalWorker) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetCommandStationId() string {
	if m != nil {
		return m.CommandStationId
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetHardwareId() string {
	if m != nil {
		return m.HardwareId
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetLocalWorkerType() BinkyNetLocalWorkerType {
	if m != nil {
		return m.LocalWorkerType
	}
	return BinkyNetLocalWorkerType_LINUX
}

func (m *BinkyNetLocalWorker) GetDevices() []*BinkyNetDevice {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *BinkyNetLocalWorker) GetObjects() []*BinkyNetObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *BinkyNetLocalWorker) GetRouters() []*BinkyNetRouter {
	if m != nil {
		return m.Routers
	}
	return nil
}

type BinkyNetLocalWorkerRef struct {
	// ID of the local worker
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetLocalWorkerRef) Reset()         { *m = BinkyNetLocalWorkerRef{} }
func (m *BinkyNetLocalWorkerRef) String() string { return proto.CompactTextString(m) }
func (*BinkyNetLocalWorkerRef) ProtoMessage()    {}
func (*BinkyNetLocalWorkerRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{15}
}
func (m *BinkyNetLocalWorkerRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetLocalWorkerRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetLocalWorkerRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetLocalWorkerRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetLocalWorkerRef.Merge(m, src)
}
func (m *BinkyNetLocalWorkerRef) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetLocalWorkerRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetLocalWorkerRef.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetLocalWorkerRef proto.InternalMessageInfo

func (m *BinkyNetLocalWorkerRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Configuration of a binky router
type BinkyNetRouter struct {
	// ID of the router
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the router
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetRouter) Reset()         { *m = BinkyNetRouter{} }
func (m *BinkyNetRouter) String() string { return proto.CompactTextString(m) }
func (*BinkyNetRouter) ProtoMessage()    {}
func (*BinkyNetRouter) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{16}
}
func (m *BinkyNetRouter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetRouter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetRouter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetRouter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetRouter.Merge(m, src)
}
func (m *BinkyNetRouter) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetRouter) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetRouter.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetRouter proto.InternalMessageInfo

func (m *BinkyNetRouter) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BinkyNetRouter) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type BinkyNetDevice struct {
	// ID of this object
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the device in the BinkyNet.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Type of the device
	DeviceType BinkyNetDeviceType `protobuf:"varint,3,opt,name=device_type,json=deviceType,proto3,enum=binkyrailways.v1.BinkyNetDeviceType" json:"device_type,omitempty"`
	// Address of the device
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	// Set if the device is disabled
	Disabled bool `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// ID of router used to route commands & state to/from this device
	RouterId string `protobuf:"bytes,6,opt,name=router_id,json=routerId,proto3" json:"router_id,omitempty"`
	// If set, this device supports adding an object group of type SENSORS_8
	CanAddSensors_8Group bool `protobuf:"varint,10,opt,name=can_add_sensors_8_group,json=canAddSensors8Group,proto3" json:"can_add_sensors_8_group,omitempty"`
	// If set, this device supports adding an object group of type SENSORS_4
	CanAddSensors_4Group bool     `protobuf:"varint,11,opt,name=can_add_sensors_4_group,json=canAddSensors4Group,proto3" json:"can_add_sensors_4_group,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetDevice) Reset()         { *m = BinkyNetDevice{} }
func (m *BinkyNetDevice) String() string { return proto.CompactTextString(m) }
func (*BinkyNetDevice) ProtoMessage()    {}
func (*BinkyNetDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{17}
}
func (m *BinkyNetDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetDevice.Merge(m, src)
}
func (m *BinkyNetDevice) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetDevice.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetDevice proto.InternalMessageInfo

func (m *BinkyNetDevice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BinkyNetDevice) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *BinkyNetDevice) GetDeviceType() BinkyNetDeviceType {
	if m != nil {
		return m.DeviceType
	}
	return BinkyNetDeviceType_MCP23008
}

func (m *BinkyNetDevice) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *BinkyNetDevice) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *BinkyNetDevice) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

func (m *BinkyNetDevice) GetCanAddSensors_8Group() bool {
	if m != nil {
		return m.CanAddSensors_8Group
	}
	return false
}

func (m *BinkyNetDevice) GetCanAddSensors_4Group() bool {
	if m != nil {
		return m.CanAddSensors_4Group
	}
	return false
}

type BinkyNetObject struct {
	// ID of this object
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the object in the binky network.
	ObjectId string `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Type of the object
	ObjectType BinkyNetObjectType `protobuf:"varint,3,opt,name=object_type,json=objectType,proto3,enum=binkyrailways.v1.BinkyNetObjectType" json:"object_type,omitempty"`
	// Connections to devices used by this object
	// The keys used in this map are specific to the type of object.
	Connections []*BinkyNetConnection `protobuf:"bytes,4,rep,name=connections,proto3" json:"connections,omitempty"`
	// Gets optional configuration for this object.
	Configuration        map[string]string `protobuf:"bytes,5,rep,name=configuration,proto3" json:"configuration,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BinkyNetObject) Reset()         { *m = BinkyNetObject{} }
func (m *BinkyNetObject) String() string { return proto.CompactTextString(m) }
func (*BinkyNetObject) ProtoMessage()    {}
func (*BinkyNetObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{18}
}
func (m *BinkyNetObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetObject.Merge(m, src)
}
func (m *BinkyNetObject) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetObject) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetObject.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetObject proto.InternalMessageInfo

func (m *BinkyNetObject) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BinkyNetObject) GetObjectId() string {
	if m != nil {
		return m.ObjectId
	}
	return ""
}

func (m *BinkyNetObject) GetObjectType() BinkyNetObjectType {
	if m != nil {
		return m.ObjectType
	}
	return BinkyNetObjectType_BINARYSENSOR
}

func (m *BinkyNetObject) GetConnections() []*BinkyNetConnection {
	if m != nil {
		return m.Connections
	}
	return nil
}

func (m *BinkyNetObject) GetConfiguration() map[string]string {
	if m != nil {
		return m.Configuration
	}
	return nil
}

// BinkyNetConnection represents a connection from a BinkyNetObject to a
// BinkyNetDevice.
type BinkyNetConnection struct {
	// Key is specific to the type of device.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The pins of devices to connect to.
	Pins []*BinkyNetDevicePin `protobuf:"bytes,2,rep,name=pins,proto3" json:"pins,omitempty"`
	// Gets optional configuration for this connection.
	Configuration        map[string]string `protobuf:"bytes,3,rep,name=configuration,proto3" json:"configuration,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BinkyNetConnection) Reset()         { *m = BinkyNetConnection{} }
func (m *BinkyNetConnection) String() string { return proto.CompactTextString(m) }
func (*BinkyNetConnection) ProtoMessage()    {}
func (*BinkyNetConnection) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{19}
}
func (m *BinkyNetConnection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetConnection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetConnection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetConnection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetConnection.Merge(m, src)
}
func (m *BinkyNetConnection) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetConnection) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetConnection.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetConnection proto.InternalMessageInfo

func (m *BinkyNetConnection) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *BinkyNetConnection) GetPins() []*BinkyNetDevicePin {
	if m != nil {
		return m.Pins
	}
	return nil
}

func (m *BinkyNetConnection) GetConfiguration() map[string]string {
	if m != nil {
		return m.Configuration
	}
	return nil
}

// BinkyNetDevicePin identifies a hardware device and an index within that
// hardware address.
type BinkyNetDevicePin struct {
	// ID of the device that this connection refers to.
	DeviceId string `protobuf:"bytes,1,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Index on the device (1...)
	Index                uint32   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetDevicePin) Reset()         { *m = BinkyNetDevicePin{} }
func (m *BinkyNetDevicePin) String() string { return proto.CompactTextString(m) }
func (*BinkyNetDevicePin) ProtoMessage()    {}
func (*BinkyNetDevicePin) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{20}
}
func (m *BinkyNetDevicePin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetDevicePin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetDevicePin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetDevicePin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetDevicePin.Merge(m, src)
}
func (m *BinkyNetDevicePin) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetDevicePin) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetDevicePin.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetDevicePin proto.InternalMessageInfo

func (m *BinkyNetDevicePin) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *BinkyNetDevicePin) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

// Block on the track
type Block struct {
	// ID of the block
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the block
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the block
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the block
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// Probability (in percentage) that a loc that is allowed to wait in this
	// block will actually wait. When set to 0, no locs will wait (unless there is
	// no route available). When set to 100, all locs (that are allowed) will
	// wait.
	WaitProbability int32 `protobuf:"varint,10,opt,name=wait_probability,json=waitProbability,proto3" json:"wait_probability,omitempty"`
	// Minimum amount of time to wait (if <see cref="WaitProbability"/> is set) in
	// seconds.
	MinimumWaitTime int32 `protobuf:"varint,11,opt,name=minimum_wait_time,json=minimumWaitTime,proto3" json:"minimum_wait_time,omitempty"`
	// Maximum amount of time to wait (if <see cref="WaitProbability"/> is set) in
	// seconds.
	MaximumWaitTime int32 `protobuf:"varint,12,opt,name=maximum_wait_time,json=maximumWaitTime,proto3" json:"maximum_wait_time,omitempty"`
	// Gets the predicate used to decide which locs are allowed to wait in this
	// block.
	WaitPermissions string `protobuf:"bytes,13,opt,name=wait_permissions,json=waitPermissions,proto3" json:"wait_permissions,omitempty"`
	// By default the front of the block is on the right of the block.
	// When this property is set, that is reversed to the left of the block.
	// Setting this property will only alter the display behavior of the block.
	ReverseSides bool `protobuf:"varint,14,opt,name=reverse_sides,json=reverseSides,proto3" json:"reverse_sides,omitempty"`
	// Is it allowed for locs to change direction in this block?
	ChangeDirection ChangeDirection `protobuf:"varint,15,opt,name=change_direction,json=changeDirection,proto3,enum=binkyrailways.v1.ChangeDirection" json:"change_direction,omitempty"`
	// Must reversing locs change direction (back to normal) in this block?
	ChangeDirectionReversingLocs bool `protobuf:"varint,16,opt,name=change_direction_reversing_locs,json=changeDirectionReversingLocs,proto3" json:"change_direction_reversing_locs,omitempty"`
	// Is this block considered a station?
	IsStation bool `protobuf:"varint,18,opt,name=is_station,json=isStation,proto3" json:"is_station,omitempty"`
	// The block group that this block belongs to (if any).
	BlockGroup           *BlockGroupRef `protobuf:"bytes,19,opt,name=block_group,json=blockGroup,proto3" json:"block_group,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{21}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Block) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Block) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Block) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Block) GetWaitProbability() int32 {
	if m != nil {
		return m.WaitProbability
	}
	return 0
}

func (m *Block) GetMinimumWaitTime() int32 {
	if m != nil {
		return m.MinimumWaitTime
	}
	return 0
}

func (m *Block) GetMaximumWaitTime() int32 {
	if m != nil {
		return m.MaximumWaitTime
	}
	return 0
}

func (m *Block) GetWaitPermissions() string {
	if m != nil {
		return m.WaitPermissions
	}
	return ""
}

func (m *Block) GetReverseSides() bool {
	if m != nil {
		return m.ReverseSides
	}
	return false
}

func (m *Block) GetChangeDirection() ChangeDirection {
	if m != nil {
		return m.ChangeDirection
	}
	return ChangeDirection_ALLOW
}

func (m *Block) GetChangeDirectionReversingLocs() bool {
	if m != nil {
		return m.ChangeDirectionReversingLocs
	}
	return false
}

func (m *Block) GetIsStation() bool {
	if m != nil {
		return m.IsStation
	}
	return false
}

func (m *Block) GetBlockGroup() *BlockGroupRef {
	if m != nil {
		return m.BlockGroup
	}
	return nil
}

// Reference to a Block
type BlockRef struct {
	// ID of the block
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRef) Reset()         { *m = BlockRef{} }
func (m *BlockRef) String() string { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()    {}
func (*BlockRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{22}
}
func (m *BlockRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRef.Merge(m, src)
}
func (m *BlockRef) XXX_Size() int {
	return m.Size()
}
func (m *BlockRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRef.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRef proto.InternalMessageInfo

func (m *BlockRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Group of blocks on the track
type BlockGroup struct {
	// ID of the block group
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the block group
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the block group
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// The minimum number of locs that must be present in this group.
	// Locs cannot leave if that results in a lower number of locs in this group.
	MinimumLocsInGroup int32 `protobuf:"varint,4,opt,name=minimum_locs_in_group,json=minimumLocsInGroup,proto3" json:"minimum_locs_in_group,omitempty"`
	// The minimum number of locs that must be on the track before the <see cref="MinimumLocsInGroup"/> becomes active.
	MinimumLocsOnTrack   int32    `protobuf:"varint,5,opt,name=minimum_locs_on_track,json=minimumLocsOnTrack,proto3" json:"minimum_locs_on_track,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockGroup) Reset()         { *m = BlockGroup{} }
func (m *BlockGroup) String() string { return proto.CompactTextString(m) }
func (*BlockGroup) ProtoMessage()    {}
func (*BlockGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{23}
}
func (m *BlockGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockGroup.Merge(m, src)
}
func (m *BlockGroup) XXX_Size() int {
	return m.Size()
}
func (m *BlockGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockGroup.DiscardUnknown(m)
}

var xxx_messageInfo_BlockGroup proto.InternalMessageInfo

func (m *BlockGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BlockGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BlockGroup) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *BlockGroup) GetMinimumLocsInGroup() int32 {
	if m != nil {
		return m.MinimumLocsInGroup
	}
	return 0
}

func (m *BlockGroup) GetMinimumLocsOnTrack() int32 {
	if m != nil {
		return m.MinimumLocsOnTrack
	}
	return 0
}

// Reference to a BlockGroup
type BlockGroupRef struct {
	// ID of the block group
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockGroupRef) Reset()         { *m = BlockGroupRef{} }
func (m *BlockGroupRef) String() string { return proto.CompactTextString(m) }
func (*BlockGroupRef) ProtoMessage()    {}
func (*BlockGroupRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{24}
}
func (m *BlockGroupRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockGroupRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockGroupRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockGroupRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockGroupRef.Merge(m, src)
}
func (m *BlockGroupRef) XXX_Size() int {
	return m.Size()
}
func (m *BlockGroupRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockGroupRef.DiscardUnknown(m)
}

var xxx_messageInfo_BlockGroupRef proto.InternalMessageInfo

func (m *BlockGroupRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Edge of a module on the track
type Edge struct {
	// ID of the edge
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the edge
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the edge
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the edge
	Position             *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Edge) Reset()         { *m = Edge{} }
func (m *Edge) String() string { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()    {}
func (*Edge) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{25}
}
func (m *Edge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Edge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Edge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Edge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Edge.Merge(m, src)
}
func (m *Edge) XXX_Size() int {
	return m.Size()
}
func (m *Edge) XXX_DiscardUnknown() {
	xxx_messageInfo_Edge.DiscardUnknown(m)
}

var xxx_messageInfo_Edge proto.InternalMessageInfo

func (m *Edge) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Edge) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Edge) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Edge) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// Reference to an Edge
type EdgeRef struct {
	// ID of the edge
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EdgeRef) Reset()         { *m = EdgeRef{} }
func (m *EdgeRef) String() string { return proto.CompactTextString(m) }
func (*EdgeRef) ProtoMessage()    {}
func (*EdgeRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{26}
}
func (m *EdgeRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeRef.Merge(m, src)
}
func (m *EdgeRef) XXX_Size() int {
	return m.Size()
}
func (m *EdgeRef) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeRef.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeRef proto.InternalMessageInfo

func (m *EdgeRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Junction on the track
type Junction struct {
	// ID of the Junction
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Junction
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Junction
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Junction
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// The block that this junction belongs to.
	// When set, this junction is considered lock if the block is locked.
	Block *BlockRef `protobuf:"bytes,5,opt,name=block,proto3" json:"block,omitempty"`
	// Set when this junction is of type switch.
	Switch               *Switch  `protobuf:"bytes,6,opt,name=switch,proto3" json:"switch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Junction) Reset()         { *m = Junction{} }
func (m *Junction) String() string { return proto.CompactTextString(m) }
func (*Junction) ProtoMessage()    {}
func (*Junction) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{27}
}
func (m *Junction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Junction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Junction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Junction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Junction.Merge(m, src)
}
func (m *Junction) XXX_Size() int {
	return m.Size()
}
func (m *Junction) XXX_DiscardUnknown() {
	xxx_messageInfo_Junction.DiscardUnknown(m)
}

var xxx_messageInfo_Junction proto.InternalMessageInfo

func (m *Junction) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Junction) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Junction) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Junction) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Junction) GetBlock() *BlockRef {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Junction) GetSwitch() *Switch {
	if m != nil {
		return m.Switch
	}
	return nil
}

// Reference to a Junction
type JunctionRef struct {
	// ID of the Junction
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JunctionRef) Reset()         { *m = JunctionRef{} }
func (m *JunctionRef) String() string { return proto.CompactTextString(m) }
func (*JunctionRef) ProtoMessage()    {}
func (*JunctionRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{28}
}
func (m *JunctionRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JunctionRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JunctionRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JunctionRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JunctionRef.Merge(m, src)
}
func (m *JunctionRef) XXX_Size() int {
	return m.Size()
}
func (m *JunctionRef) XXX_DiscardUnknown() {
	xxx_messageInfo_JunctionRef.DiscardUnknown(m)
}

var xxx_messageInfo_JunctionRef proto.InternalMessageInfo

func (m *JunctionRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Switch specialization of a Junction
type Switch struct {
	// Address of the switch
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Does this switch send a feedback when switched?
	HasFeedback bool `protobuf:"varint,2,opt,name=has_feedback,json=hasFeedback,proto3" json:"has_feedback,omitempty"`
	// Address of the feedback unit of the entity
	FeedbackAddress string `protobuf:"bytes,3,opt,name=feedback_address,json=feedbackAddress,proto3" json:"feedback_address,omitempty"`
	// Time (in ms) it takes for the switch to move from one direction to the
	// other? This property is only used when <see cref="HasFeedback"/> is false.
	SwitchDuration int32 `protobuf:"varint,4,opt,name=switch_duration,json=switchDuration,proto3" json:"switch_duration,omitempty"`
	// If set, the straight/off commands are inverted.
	Invert bool `protobuf:"varint,5,opt,name=invert,proto3" json:"invert,omitempty"`
	// If there is a different feedback address and this is set, the straight/off
	// feedback states are inverted.
	InvertFeedback bool `protobuf:"varint,6,opt,name=invert_feedback,json=invertFeedback,proto3" json:"invert_feedback,omitempty"`
	// At which direction should the switch be initialized?
	InitialDirection SwitchDirection `protobuf:"varint,7,opt,name=initial_direction,json=initialDirection,proto3,enum=binkyrailways.v1.SwitchDirection" json:"initial_direction,omitempty"`
	// Is this switch turning left?
	// Otherwise it is turning right.
	IsLeft               bool     `protobuf:"varint,8,opt,name=is_left,json=isLeft,proto3" json:"is_left,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Switch) Reset()         { *m = Switch{} }
func (m *Switch) String() string { return proto.CompactTextString(m) }
func (*Switch) ProtoMessage()    {}
func (*Switch) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{29}
}
func (m *Switch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Switch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Switch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Switch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Switch.Merge(m, src)
}
func (m *Switch) XXX_Size() int {
	return m.Size()
}
func (m *Switch) XXX_DiscardUnknown() {
	xxx_messageInfo_Switch.DiscardUnknown(m)
}

var xxx_messageInfo_Switch proto.InternalMessageInfo

func (m *Switch) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Switch) GetHasFeedback() bool {
	if m != nil {
		return m.HasFeedback
	}
	return false
}

func (m *Switch) GetFeedbackAddress() string {
	if m != nil {
		return m.FeedbackAddress
	}
	return ""
}

func (m *Switch) GetSwitchDuration() int32 {
	if m != nil {
		return m.SwitchDuration
	}
	return 0
}

func (m *Switch) GetInvert() bool {
	if m != nil {
		return m.Invert
	}
	return false
}

func (m *Switch) GetInvertFeedback() bool {
	if m != nil {
		return m.InvertFeedback
	}
	return false
}

func (m *Switch) GetInitialDirection() SwitchDirection {
	if m != nil {
		return m.InitialDirection
	}
	return SwitchDirection_STRAIGHT
}

func (m *Switch) GetIsLeft() bool {
	if m != nil {
		return m.IsLeft
	}
	return false
}

// Output on the track
type Output struct {
	// ID of the Output
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Output
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Output
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Output
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// Set when this output is of type binary output.
	BinaryOutput         *BinaryOutput `protobuf:"bytes,5,opt,name=binary_output,json=binaryOutput,proto3" json:"binary_output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Output) Reset()         { *m = Output{} }
func (m *Output) String() string { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()    {}
func (*Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{30}
}
func (m *Output) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Output.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Output.Merge(m, src)
}
func (m *Output) XXX_Size() int {
	return m.Size()
}
func (m *Output) XXX_DiscardUnknown() {
	xxx_messageInfo_Output.DiscardUnknown(m)
}

var xxx_messageInfo_Output proto.InternalMessageInfo

func (m *Output) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Output) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Output) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Output) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Output) GetBinaryOutput() *BinaryOutput {
	if m != nil {
		return m.BinaryOutput
	}
	return nil
}

// Reference to a Output
type OutputRef struct {
	// ID of the Output
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutputRef) Reset()         { *m = OutputRef{} }
func (m *OutputRef) String() string { return proto.CompactTextString(m) }
func (*OutputRef) ProtoMessage()    {}
func (*OutputRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{31}
}
func (m *OutputRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputRef.Merge(m, src)
}
func (m *OutputRef) XXX_Size() int {
	return m.Size()
}
func (m *OutputRef) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputRef.DiscardUnknown(m)
}

var xxx_messageInfo_OutputRef proto.InternalMessageInfo

func (m *OutputRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Sub type of Output
type BinaryOutput struct {
	// Output address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Type of output
	OutputType BinaryOutputType `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3,enum=binkyrailways.v1.BinaryOutputType" json:"output_type,omitempty"`
	// Text shown when output is in active state
	ActiveText string `protobuf:"bytes,3,opt,name=active_text,json=activeText,proto3" json:"active_text,omitempty"`
	// Text shown when output is in inactive state
	InactiveText         string   `protobuf:"bytes,4,opt,name=inactive_text,json=inactiveText,proto3" json:"inactive_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinaryOutput) Reset()         { *m = BinaryOutput{} }
func (m *BinaryOutput) String() string { return proto.CompactTextString(m) }
func (*BinaryOutput) ProtoMessage()    {}
func (*BinaryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{32}
}
func (m *BinaryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOutput.Merge(m, src)
}
func (m *BinaryOutput) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOutput proto.InternalMessageInfo

func (m *BinaryOutput) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *BinaryOutput) GetOutputType() BinaryOutputType {
	if m != nil {
		return m.OutputType
	}
	return BinaryOutputType_BOT_DEFAULT
}

func (m *BinaryOutput) GetActiveText() string {
	if m != nil {
		return m.ActiveText
	}
	return ""
}

func (m *BinaryOutput) GetInactiveText() string {
	if m != nil {
		return m.InactiveText
	}
	return ""
}

// Route on the track
type Route struct {
	// ID of the Route
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Route
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Route
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Start of the route
	From *Endpoint `protobuf:"bytes,4,opt,name=from,proto3" json:"from,omitempty"`
	// End of the route
	To *Endpoint `protobuf:"bytes,5,opt,name=to,proto3" json:"to,omitempty"`
	// Set of junctions with their states that are crossed when taking this route.
	CrossingJunctions []*JunctionWithState `protobuf:"bytes,6,rep,name=crossing_junctions,json=crossingJunctions,proto3" json:"crossing_junctions,omitempty"`
	// Set of outputs with their states that are set when taking this route.
	Outputs []*OutputWithState `protobuf:"bytes,7,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// Set of events that change the state of the route and it's running loc.
	Events []*RouteEvent `protobuf:"bytes,8,rep,name=events,proto3" json:"events,omitempty"`
	// Speed of locs when going this route.
	// This value is a percentage of the maximum / medium speed of the loc.
	// <value>0..100</value>
	Speed int32 `protobuf:"varint,10,opt,name=speed,proto3" json:"speed,omitempty"`
	// Probability (in percentage) that a loc will take this route.
	// When multiple routes are available to choose from the route with the
	// highest probability will have the highest chance or being chosen.
	// <value>0..100</value>
	ChooseProbability int32 `protobuf:"varint,11,opt,name=choose_probability,json=chooseProbability,proto3" json:"choose_probability,omitempty"`
	// / Gets the predicate used to decide which locs are allowed to use this
	// / route.
	Permissions string `protobuf:"bytes,12,opt,name=permissions,proto3" json:"permissions,omitempty"`
	// Is this rout open for traffic or not?
	// Setting to true, allows for maintance etc. on this route.
	Closed bool `protobuf:"varint,13,opt,name=closed,proto3" json:"closed,omitempty"`
	// Maximum time in seconds that this route should take.
	// If a loc takes this route and exceeds this duration, a warning is given.
	MaxDuration          int32    `protobuf:"varint,14,opt,name=max_duration,json=maxDuration,proto3" json:"max_duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{33}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Route) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Route) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Route) GetFrom() *Endpoint {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Route) GetTo() *Endpoint {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Route) GetCrossingJunctions() []*JunctionWithState {
	if m != nil {
		return m.CrossingJunctions
	}
	return nil
}

func (m *Route) GetOutputs() []*OutputWithState {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Route) GetEvents() []*RouteEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Route) GetSpeed() int32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Route) GetChooseProbability() int32 {
	if m != nil {
		return m.ChooseProbability
	}
	return 0
}

func (m *Route) GetPermissions() string {
	if m != nil {
		return m.Permissions
	}
	return ""
}

func (m *Route) GetClosed() bool {
	if m != nil {
		return m.Closed
	}
	return false
}

func (m *Route) GetMaxDuration() int32 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

// Reference to a Route
type RouteRef struct {
	// ID of the Route
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteRef) Reset()         { *m = RouteRef{} }
func (m *RouteRef) String() string { return proto.CompactTextString(m) }
func (*RouteRef) ProtoMessage()    {}
func (*RouteRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{34}
}
func (m *RouteRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteRef.Merge(m, src)
}
func (m *RouteRef) XXX_Size() int {
	return m.Size()
}
func (m *RouteRef) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteRef.DiscardUnknown(m)
}

var xxx_messageInfo_RouteRef proto.InternalMessageInfo

func (m *RouteRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Source or destination of a route
type Endpoint struct {
	// Set if endpoint is a block
	Block *BlockRef `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	// Set if endpoint is an edge
	Edge *EdgeRef `protobuf:"bytes,2,opt,name=edge,proto3" json:"edge,omitempty"`
	// Set if endpoint is a block
	BlockSide            BlockSide `protobuf:"varint,3,opt,name=block_side,json=blockSide,proto3,enum=binkyrailways.v1.BlockSide" json:"block_side,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{35}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetBlock() *BlockRef {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Endpoint) GetEdge() *EdgeRef {
	if m != nil {
		return m.Edge
	}
	return nil
}

func (m *Endpoint) GetBlockSide() BlockSide {
	if m != nil {
		return m.BlockSide
	}
	return BlockSide_FRONT
}

// Reference to a junction with specific state
type JunctionWithState struct {
	// Junction reference
	Junction *JunctionRef `protobuf:"bytes,1,opt,name=junction,proto3" json:"junction,omitempty"`
	// Desired state of switch. Only set when junction is of type switch.
	SwitchState          *SwitchWithState `protobuf:"bytes,10,opt,name=switch_state,json=switchState,proto3" json:"switch_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *JunctionWithState) Reset()         { *m = JunctionWithState{} }
func (m *JunctionWithState) String() string { return proto.CompactTextString(m) }
func (*JunctionWithState) ProtoMessage()    {}
func (*JunctionWithState) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{36}
}
func (m *JunctionWithState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JunctionWithState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JunctionWithState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JunctionWithState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JunctionWithState.Merge(m, src)
}
func (m *JunctionWithState) XXX_Size() int {
	return m.Size()
}
func (m *JunctionWithState) XXX_DiscardUnknown() {
	xxx_messageInfo_JunctionWithState.DiscardUnknown(m)
}

var xxx_messageInfo_JunctionWithState proto.InternalMessageInfo

func (m *JunctionWithState) GetJunction() *JunctionRef {
	if m != nil {
		return m.Junction
	}
	return nil
}

func (m *JunctionWithState) GetSwitchState() *SwitchWithState {
	if m != nil {
		return m.SwitchState
	}
	return nil
}

type SwitchWithState struct {
	Direction            SwitchDirection `protobuf:"varint,1,opt,name=direction,proto3,enum=binkyrailways.v1.SwitchDirection" json:"direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SwitchWithState) Reset()         { *m = SwitchWithState{} }
func (m *SwitchWithState) String() string { return proto.CompactTextString(m) }
func (*SwitchWithState) ProtoMessage()    {}
func (*SwitchWithState) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{37}
}
func (m *SwitchWithState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWithState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWithState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchWithState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWithState.Merge(m, src)
}
func (m *SwitchWithState) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWithState) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWithState.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWithState proto.InternalMessageInfo

func (m *SwitchWithState) GetDirection() SwitchDirection {
	if m != nil {
		return m.Direction
	}
	return SwitchDirection_STRAIGHT
}

// Reference to an output with specific state
type OutputWithState struct {
	// Output reference
	Output *OutputRef `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	// Desired state of binary output. Only set when output is of type binary-output.
	BinaryOutputState    *BinaryOutputWithState `protobuf:"bytes,10,opt,name=binary_output_state,json=binaryOutputState,proto3" json:"binary_output_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *OutputWithState) Reset()         { *m = OutputWithState{} }
func (m *OutputWithState) String() string { return proto.CompactTextString(m) }
func (*OutputWithState) ProtoMessage()    {}
func (*OutputWithState) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{38}
}
func (m *OutputWithState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputWithState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputWithState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputWithState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputWithState.Merge(m, src)
}
func (m *OutputWithState) XXX_Size() int {
	return m.Size()
}
func (m *OutputWithState) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputWithState.DiscardUnknown(m)
}

var xxx_messageInfo_OutputWithState proto.InternalMessageInfo

func (m *OutputWithState) GetOutput() *OutputRef {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OutputWithState) GetBinaryOutputState() *BinaryOutputWithState {
	if m != nil {
		return m.BinaryOutputState
	}
	return nil
}

type BinaryOutputWithState struct {
	Active               bool     `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinaryOutputWithState) Reset()         { *m = BinaryOutputWithState{} }
func (m *BinaryOutputWithState) String() string { return proto.CompactTextString(m) }
func (*BinaryOutputWithState) ProtoMessage()    {}
func (*BinaryOutputWithState) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{39}
}
func (m *BinaryOutputWithState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOutputWithState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOutputWithState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOutputWithState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOutputWithState.Merge(m, src)
}
func (m *BinaryOutputWithState) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOutputWithState) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOutputWithState.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOutputWithState proto.InternalMessageInfo

func (m *BinaryOutputWithState) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// RouteEvent specifies a sensor event in a route.
type RouteEvent struct {
	// Sensor that triggers the event
	Sensor *SensorRef `protobuf:"bytes,1,opt,name=sensor,proto3" json:"sensor,omitempty"`
	// Gets the list of behaviors to choose from.
	// The first matching behavior is used.
	Behaviors            []*RouteEventBehavior `protobuf:"bytes,2,rep,name=behaviors,proto3" json:"behaviors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RouteEvent) Reset()         { *m = RouteEvent{} }
func (m *RouteEvent) String() string { return proto.CompactTextString(m) }
func (*RouteEvent) ProtoMessage()    {}
func (*RouteEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{40}
}
func (m *RouteEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteEvent.Merge(m, src)
}
func (m *RouteEvent) XXX_Size() int {
	return m.Size()
}
func (m *RouteEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RouteEvent proto.InternalMessageInfo

func (m *RouteEvent) GetSensor() *SensorRef {
	if m != nil {
		return m.Sensor
	}
	return nil
}

func (m *RouteEvent) GetBehaviors() []*RouteEventBehavior {
	if m != nil {
		return m.Behaviors
	}
	return nil
}

type RouteEventBehavior struct {
	// Predicate used to select the locs to which this event applies.
	AppliesTo string `protobuf:"bytes,1,opt,name=applies_to,json=appliesTo,proto3" json:"applies_to,omitempty"`
	// How is the state of the route changed.
	StateBehavior RouteStateBehavior `protobuf:"varint,2,opt,name=state_behavior,json=stateBehavior,proto3,enum=binkyrailways.v1.RouteStateBehavior" json:"state_behavior,omitempty"`
	// How is the speed of the occupying loc changed.
	SpeedBehavior        LocSpeedBehavior `protobuf:"varint,3,opt,name=speed_behavior,json=speedBehavior,proto3,enum=binkyrailways.v1.LocSpeedBehavior" json:"speed_behavior,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RouteEventBehavior) Reset()         { *m = RouteEventBehavior{} }
func (m *RouteEventBehavior) String() string { return proto.CompactTextString(m) }
func (*RouteEventBehavior) ProtoMessage()    {}
func (*RouteEventBehavior) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{41}
}
func (m *RouteEventBehavior) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteEventBehavior) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteEventBehavior.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteEventBehavior) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteEventBehavior.Merge(m, src)
}
func (m *RouteEventBehavior) XXX_Size() int {
	return m.Size()
}
func (m *RouteEventBehavior) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteEventBehavior.DiscardUnknown(m)
}

var xxx_messageInfo_RouteEventBehavior proto.InternalMessageInfo

func (m *RouteEventBehavior) GetAppliesTo() string {
	if m != nil {
		return m.AppliesTo
	}
	return ""
}

func (m *RouteEventBehavior) GetStateBehavior() RouteStateBehavior {
	if m != nil {
		return m.StateBehavior
	}
	return RouteStateBehavior_RSB_NOCHANGE
}

func (m *RouteEventBehavior) GetSpeedBehavior() LocSpeedBehavior {
	if m != nil {
		return m.SpeedBehavior
	}
	return LocSpeedBehavior_LSB_DEFAULT
}

// Sensor on the track
type Sensor struct {
	// ID of the Sensor
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Sensor
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Sensor
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Sensor
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// Address of the sensor
	Address string `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	// The block that this sensor belongs to.
	// When set, this connection is used in the loc-to-block assignment process.
	Block *BlockRef `protobuf:"bytes,6,opt,name=block,proto3" json:"block,omitempty"`
	// Shape used to visualize this sensor
	Shape Shape `protobuf:"varint,7,opt,name=shape,proto3,enum=binkyrailways.v1.Shape" json:"shape,omitempty"`
	// Set when this sensor is of type binary sensor.
	BinarySensor         *BinarySensor `protobuf:"bytes,8,opt,name=binary_sensor,json=binarySensor,proto3" json:"binary_sensor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Sensor) Reset()         { *m = Sensor{} }
func (m *Sensor) String() string { return proto.CompactTextString(m) }
func (*Sensor) ProtoMessage()    {}
func (*Sensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{42}
}
func (m *Sensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sensor.Merge(m, src)
}
func (m *Sensor) XXX_Size() int {
	return m.Size()
}
func (m *Sensor) XXX_DiscardUnknown() {
	xxx_messageInfo_Sensor.DiscardUnknown(m)
}

var xxx_messageInfo_Sensor proto.InternalMessageInfo

func (m *Sensor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Sensor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Sensor) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Sensor) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Sensor) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Sensor) GetBlock() *BlockRef {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Sensor) GetShape() Shape {
	if m != nil {
		return m.Shape
	}
	return Shape_CIRCLE
}

func (m *Sensor) GetBinarySensor() *BinarySensor {
	if m != nil {
		return m.BinarySensor
	}
	return nil
}

// Reference to a Sensor
type SensorRef struct {
	// ID of the Sensor
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SensorRef) Reset()         { *m = SensorRef{} }
func (m *SensorRef) String() string { return proto.CompactTextString(m) }
func (*SensorRef) ProtoMessage()    {}
func (*SensorRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{43}
}
func (m *SensorRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorRef.Merge(m, src)
}
func (m *SensorRef) XXX_Size() int {
	return m.Size()
}
func (m *SensorRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorRef.DiscardUnknown(m)
}

var xxx_messageInfo_SensorRef proto.InternalMessageInfo

func (m *SensorRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Sub type of Sensor
type BinarySensor struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinarySensor) Reset()         { *m = BinarySensor{} }
func (m *BinarySensor) String() string { return proto.CompactTextString(m) }
func (*BinarySensor) ProtoMessage()    {}
func (*BinarySensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{44}
}
func (m *BinarySensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinarySensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinarySensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinarySensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinarySensor.Merge(m, src)
}
func (m *BinarySensor) XXX_Size() int {
	return m.Size()
}
func (m *BinarySensor) XXX_DiscardUnknown() {
	xxx_messageInfo_BinarySensor.DiscardUnknown(m)
}

var xxx_messageInfo_BinarySensor proto.InternalMessageInfo

// Signal on the track
type Signal struct {
	// ID of the Signal
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Signal
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Signal
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Signal
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// Set when this signal is of type block signal.
	BlockSignal          *BlockSignal `protobuf:"bytes,5,opt,name=block_signal,json=blockSignal,proto3" json:"block_signal,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Signal) Reset()         { *m = Signal{} }
func (m *Signal) String() string { return proto.CompactTextString(m) }
func (*Signal) ProtoMessage()    {}
func (*Signal) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{45}
}
func (m *Signal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signal.Merge(m, src)
}
func (m *Signal) XXX_Size() int {
	return m.Size()
}
func (m *Signal) XXX_DiscardUnknown() {
	xxx_messageInfo_Signal.DiscardUnknown(m)
}

var xxx_messageInfo_Signal proto.InternalMessageInfo

func (m *Signal) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Signal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Signal) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Signal) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Signal) GetBlockSignal() *BlockSignal {
	if m != nil {
		return m.BlockSignal
	}
	return nil
}

// Signal related to a specific block
type BlockSignal struct {
	// First address
	// This is an output signal.
	Address1 string `protobuf:"bytes,1,opt,name=address1,proto3" json:"address1,omitempty"`
	// Second address
	// This is an output signal.
	Address2 string `protobuf:"bytes,2,opt,name=address2,proto3" json:"address2,omitempty"`
	// Third address
	// This is an output signal.
	Address3 string `protobuf:"bytes,3,opt,name=address3,proto3" json:"address3,omitempty"`
	// Fourth address
	// This is an output signal.
	Address4 string `protobuf:"bytes,4,opt,name=address4,proto3" json:"address4,omitempty"`
	// Is the Red color available?
	// Readonly.
	IsRedAvailable bool `protobuf:"varint,10,opt,name=is_red_available,json=isRedAvailable,proto3" json:"is_red_available,omitempty"`
	// Bit pattern used for color Red.
	RedPattern int32 `protobuf:"varint,11,opt,name=red_pattern,json=redPattern,proto3" json:"red_pattern,omitempty"`
	// Is the Green color available?
	// Readonly.
	IsGreenAvailable bool `protobuf:"varint,20,opt,name=is_green_available,json=isGreenAvailable,proto3" json:"is_green_available,omitempty"`
	// Bit pattern used for color Green.
	GreenPattern int32 `protobuf:"varint,21,opt,name=green_pattern,json=greenPattern,proto3" json:"green_pattern,omitempty"`
	// Is the Yellow color available?
	// Readonly.
	IsYellowAvailable bool `protobuf:"varint,30,opt,name=is_yellow_available,json=isYellowAvailable,proto3" json:"is_yellow_available,omitempty"`
	// Bit pattern used for color Yellow.
	YellowPattern int32 `protobuf:"varint,31,opt,name=yellow_pattern,json=yellowPattern,proto3" json:"yellow_pattern,omitempty"`
	// Is the White color available?
	// Readonly.
	IsWhiteAvailable bool `protobuf:"varint,40,opt,name=is_white_available,json=isWhiteAvailable,proto3" json:"is_white_available,omitempty"`
	// Bit pattern used for color White.
	WhitePattern int32 `protobuf:"varint,41,opt,name=white_pattern,json=whitePattern,proto3" json:"white_pattern,omitempty"`
	// The block this signal protects.
	Block *BlockRef `protobuf:"bytes,50,opt,name=block,proto3" json:"block,omitempty"`
	// Side of the block where the signal is located.
	BlockSide BlockSide `protobuf:"varint,51,opt,name=block_side,json=blockSide,proto3,enum=binkyrailways.v1.BlockSide" json:"block_side,omitempty"`
	// Type of signal
	Type                 BlockSignalType `protobuf:"varint,60,opt,name=type,proto3,enum=binkyrailways.v1.BlockSignalType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *BlockSignal) Reset()         { *m = BlockSignal{} }
func (m *BlockSignal) String() string { return proto.CompactTextString(m) }
func (*BlockSignal) ProtoMessage()    {}
func (*BlockSignal) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{46}
}
func (m *BlockSignal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSignal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSignal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockSignal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSignal.Merge(m, src)
}
func (m *BlockSignal) XXX_Size() int {
	return m.Size()
}
func (m *BlockSignal) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSignal.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSignal proto.InternalMessageInfo

func (m *BlockSignal) GetAddress1() string {
	if m != nil {
		return m.Address1
	}
	return ""
}

func (m *BlockSignal) GetAddress2() string {
	if m != nil {
		return m.Address2
	}
	return ""
}

func (m *BlockSignal) GetAddress3() string {
	if m != nil {
		return m.Address3
	}
	return ""
}

func (m *BlockSignal) GetAddress4() string {
	if m != nil {
		return m.Address4
	}
	return ""
}

func (m *BlockSignal) GetIsRedAvailable() bool {
	if m != nil {
		return m.IsRedAvailable
	}
	return false
}

func (m *BlockSignal) GetRedPattern() int32 {
	if m != nil {
		return m.RedPattern
	}
	return 0
}

func (m *BlockSignal) GetIsGreenAvailable() bool {
	if m != nil {
		return m.IsGreenAvailable
	}
	return false
}

func (m *BlockSignal) GetGreenPattern() int32 {
	if m != nil {
		return m.GreenPattern
	}
	return 0
}

func (m *BlockSignal) GetIsYellowAvailable() bool {
	if m != nil {
		return m.IsYellowAvailable
	}
	return false
}

func (m *BlockSignal) GetYellowPattern() int32 {
	if m != nil {
		return m.YellowPattern
	}
	return 0
}

func (m *BlockSignal) GetIsWhiteAvailable() bool {
	if m != nil {
		return m.IsWhiteAvailable
	}
	return false
}

func (m *BlockSignal) GetWhitePattern() int32 {
	if m != nil {
		return m.WhitePattern
	}
	return 0
}

func (m *BlockSignal) GetBlock() *BlockRef {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *BlockSignal) GetBlockSide() BlockSide {
	if m != nil {
		return m.BlockSide
	}
	return BlockSide_FRONT
}

func (m *BlockSignal) GetType() BlockSignalType {
	if m != nil {
		return m.Type
	}
	return BlockSignalType_ENTRY
}

// Reference to a Signal
type SignalRef struct {
	// ID of the Signal
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignalRef) Reset()         { *m = SignalRef{} }
func (m *SignalRef) String() string { return proto.CompactTextString(m) }
func (*SignalRef) ProtoMessage()    {}
func (*SignalRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{47}
}
func (m *SignalRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignalRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignalRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignalRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignalRef.Merge(m, src)
}
func (m *SignalRef) XXX_Size() int {
	return m.Size()
}
func (m *SignalRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SignalRef.DiscardUnknown(m)
}

var xxx_messageInfo_SignalRef proto.InternalMessageInfo

func (m *SignalRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterEnum("binkyrailways.v1.ChangeDirection", ChangeDirection_name, ChangeDirection_value)
	proto.RegisterEnum("binkyrailways.v1.VehicleType", VehicleType_name, VehicleType_value)
	proto.RegisterEnum("binkyrailways.v1.BinkyNetLocalWorkerType", BinkyNetLocalWorkerType_name, BinkyNetLocalWorkerType_value)
	proto.RegisterEnum("binkyrailways.v1.BinkyNetDeviceType", BinkyNetDeviceType_name, BinkyNetDeviceType_value)
	proto.RegisterEnum("binkyrailways.v1.BinkyNetObjectType", BinkyNetObjectType_name, BinkyNetObjectType_value)
	proto.RegisterEnum("binkyrailways.v1.SwitchDirection", SwitchDirection_name, SwitchDirection_value)
	proto.RegisterEnum("binkyrailways.v1.BinaryOutputType", BinaryOutputType_name, BinaryOutputType_value)
	proto.RegisterEnum("binkyrailways.v1.BlockSide", BlockSide_name, BlockSide_value)
	proto.RegisterEnum("binkyrailways.v1.RouteStateBehavior", RouteStateBehavior_name, RouteStateBehavior_value)
	proto.RegisterEnum("binkyrailways.v1.LocSpeedBehavior", LocSpeedBehavior_name, LocSpeedBehavior_value)
	proto.RegisterEnum("binkyrailways.v1.Shape", Shape_name, Shape_value)
	proto.RegisterEnum("binkyrailways.v1.BlockSignalType", BlockSignalType_name, BlockSignalType_value)
	proto.RegisterType((*Empty)(nil), "binkyrailways.v1.Empty")
	proto.RegisterType((*Image)(nil), "binkyrailways.v1.Image")
	proto.RegisterType((*Railway)(nil), "binkyrailways.v1.Railway")
	proto.RegisterType((*Module)(nil), "binkyrailways.v1.Module")
	proto.RegisterType((*ModuleRef)(nil), "binkyrailways.v1.ModuleRef")
	proto.RegisterType((*Position)(nil), "binkyrailways.v1.Position")
	proto.RegisterType((*Loc)(nil), "binkyrailways.v1.Loc")
	proto.RegisterType((*LocRef)(nil), "binkyrailways.v1.LocRef")
	proto.RegisterType((*LocGroup)(nil), "binkyrailways.v1.LocGroup")
	proto.RegisterType((*LocGroupRef)(nil), "binkyrailways.v1.LocGroupRef")
	proto.RegisterType((*CommandStation)(nil), "binkyrailways.v1.CommandStation")
	proto.RegisterType((*CommandStationRef)(nil), "binkyrailways.v1.CommandStationRef")
	proto.RegisterType((*BidibCommandStation)(nil), "binkyrailways.v1.BidibCommandStation")
	proto.RegisterType((*BinkyNetCommandStation)(nil), "binkyrailways.v1.BinkyNetCommandStation")
	proto.RegisterType((*BinkyNetLocalWorker)(nil), "binkyrailways.v1.BinkyNetLocalWorker")
	proto.RegisterType((*BinkyNetLocalWorkerRef)(nil), "binkyrailways.v1.BinkyNetLocalWorkerRef")
	proto.RegisterType((*BinkyNetRouter)(nil), "binkyrailways.v1.BinkyNetRouter")
	proto.RegisterType((*BinkyNetDevice)(nil), "binkyrailways.v1.BinkyNetDevice")
	proto.RegisterType((*BinkyNetObject)(nil), "binkyrailways.v1.BinkyNetObject")
	proto.RegisterMapType((map[string]string)(nil), "binkyrailways.v1.BinkyNetObject.ConfigurationEntry")
	proto.RegisterType((*BinkyNetConnection)(nil), "binkyrailways.v1.BinkyNetConnection")
	proto.RegisterMapType((map[string]string)(nil), "binkyrailways.v1.BinkyNetConnection.ConfigurationEntry")
	proto.RegisterType((*BinkyNetDevicePin)(nil), "binkyrailways.v1.BinkyNetDevicePin")
	proto.RegisterType((*Block)(nil), "binkyrailways.v1.Block")
	proto.RegisterType((*BlockRef)(nil), "binkyrailways.v1.BlockRef")
	proto.RegisterType((*BlockGroup)(nil), "binkyrailways.v1.BlockGroup")
	proto.RegisterType((*BlockGroupRef)(nil), "binkyrailways.v1.BlockGroupRef")
	proto.RegisterType((*Edge)(nil), "binkyrailways.v1.Edge")
	proto.RegisterType((*EdgeRef)(nil), "binkyrailways.v1.EdgeRef")
	proto.RegisterType((*Junction)(nil), "binkyrailways.v1.Junction")
	proto.RegisterType((*JunctionRef)(nil), "binkyrailways.v1.JunctionRef")
	proto.RegisterType((*Switch)(nil), "binkyrailways.v1.Switch")
	proto.RegisterType((*Output)(nil), "binkyrailways.v1.Output")
	proto.RegisterType((*OutputRef)(nil), "binkyrailways.v1.OutputRef")
	proto.RegisterType((*BinaryOutput)(nil), "binkyrailways.v1.BinaryOutput")
	proto.RegisterType((*Route)(nil), "binkyrailways.v1.Route")
	proto.RegisterType((*RouteRef)(nil), "binkyrailways.v1.RouteRef")
	proto.RegisterType((*Endpoint)(nil), "binkyrailways.v1.Endpoint")
	proto.RegisterType((*JunctionWithState)(nil), "binkyrailways.v1.JunctionWithState")
	proto.RegisterType((*SwitchWithState)(nil), "binkyrailways.v1.SwitchWithState")
	proto.RegisterType((*OutputWithState)(nil), "binkyrailways.v1.OutputWithState")
	proto.RegisterType((*BinaryOutputWithState)(nil), "binkyrailways.v1.BinaryOutputWithState")
	proto.RegisterType((*RouteEvent)(nil), "binkyrailways.v1.RouteEvent")
	proto.RegisterType((*RouteEventBehavior)(nil), "binkyrailways.v1.RouteEventBehavior")
	proto.RegisterType((*Sensor)(nil), "binkyrailways.v1.Sensor")
	proto.RegisterType((*SensorRef)(nil), "binkyrailways.v1.SensorRef")
	proto.RegisterType((*BinarySensor)(nil), "binkyrailways.v1.BinarySensor")
	proto.RegisterType((*Signal)(nil), "binkyrailways.v1.Signal")
	proto.RegisterType((*BlockSignal)(nil), "binkyrailways.v1.BlockSignal")
	proto.RegisterType((*SignalRef)(nil), "binkyrailways.v1.SignalRef")
}

func init() { proto.RegisterFile("br_model_types.proto", fileDescriptor_054508b9601a8429) }

var fileDescriptor_054508b9601a8429 = []byte{
	// 3320 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0x4d, 0x6c, 0x1b, 0x59,
	0x72, 0x76, 0xf3, 0x4f, 0x64, 0x91, 0xa2, 0x5a, 0xcf, 0x7f, 0x1c, 0x7b, 0x6c, 0xcb, 0xed, 0x71,
	0x46, 0x23, 0xcc, 0xc8, 0x96, 0x2d, 0xff, 0x8c, 0x27, 0xc0, 0x98, 0xa2, 0x28, 0x9b, 0x63, 0x8a,
	0xd4, 0x34, 0x29, 0x7b, 0x1c, 0x20, 0x68, 0x34, 0xbb, 0x9f, 0xc8, 0x67, 0x91, 0xdd, 0x4c, 0xbf,
	0xa6, 0x24, 0xe6, 0x94, 0x1c, 0x92, 0x53, 0x72, 0x9b, 0x43, 0x80, 0x1c, 0x72, 0xc8, 0x21, 0x01,
	0x72, 0x0c, 0x90, 0x9c, 0x93, 0xb9, 0x0c, 0x90, 0x43, 0x76, 0x81, 0x05, 0xf6, 0xba, 0x98, 0x3d,
	0xed, 0xde, 0xf7, 0xbe, 0x78, 0x3f, 0xcd, 0x6e, 0xfe, 0xc9, 0xb2, 0x31, 0x58, 0xf8, 0xc6, 0xaa,
	0xf7, 0x55, 0x75, 0xbd, 0x7a, 0x55, 0xf5, 0xaa, 0xab, 0x09, 0x17, 0x5a, 0x9e, 0xd1, 0x73, 0x6d,
	0xdc, 0x35, 0xfc, 0x61, 0x1f, 0xd3, 0xf5, 0xbe, 0xe7, 0xfa, 0x2e, 0x52, 0x5b, 0xc4, 0x39, 0x1c,
	0x7a, 0x26, 0xe9, 0x1e, 0x9b, 0x43, 0xba, 0x7e, 0xb4, 0xa1, 0x2d, 0x40, 0xb2, 0xdc, 0xeb, 0xfb,
	0x43, 0x6d, 0x1d, 0x92, 0x95, 0x9e, 0xd9, 0xc6, 0xe8, 0x36, 0xe4, 0x2d, 0xd7, 0xf1, 0xb1, 0xe3,
	0x1b, 0x2d, 0x93, 0xe2, 0x87, 0x9b, 0x05, 0x65, 0x45, 0x59, 0xcd, 0xe8, 0x8b, 0x92, 0xbb, 0xc5,
	0x99, 0xda, 0xff, 0xc6, 0x60, 0x41, 0x17, 0x8a, 0x50, 0x1e, 0x62, 0xc4, 0x96, 0xb0, 0x18, 0xb1,
	0xd1, 0x0a, 0x64, 0x6d, 0x4c, 0x2d, 0x8f, 0xf4, 0x7d, 0xe2, 0x3a, 0x85, 0x18, 0x5f, 0x88, 0xb2,
	0xd0, 0x05, 0x48, 0xda, 0xc4, 0xf3, 0x87, 0x85, 0xf8, 0x8a, 0xb2, 0x9a, 0xd6, 0x05, 0x81, 0x1e,
	0xc0, 0x42, 0xcf, 0xb5, 0x07, 0x5d, 0x4c, 0x0b, 0xf6, 0x4a, 0x7c, 0x35, 0x7b, 0xef, 0xea, 0xfa,
	0xa4, 0xc1, 0xeb, 0xbb, 0x1c, 0xa0, 0xe3, 0x03, 0x3d, 0xc0, 0xa2, 0xcf, 0x21, 0xd1, 0x75, 0x2d,
	0x5a, 0xc0, 0x5c, 0xa6, 0x30, 0x2d, 0x53, 0x75, 0x2d, 0x26, 0xc0, 0x51, 0xe8, 0x2b, 0xc8, 0x74,
	0x5d, 0xeb, 0x99, 0xe7, 0x0e, 0xfa, 0xb4, 0x70, 0xc0, 0x45, 0xae, 0xcd, 0x14, 0xe1, 0x10, 0x26,
	0x17, 0xe2, 0xd1, 0x2e, 0x2c, 0x59, 0x6e, 0xaf, 0x67, 0x3a, 0x76, 0xc3, 0x37, 0xd9, 0x4e, 0x68,
	0xa1, 0xcd, 0x55, 0xdc, 0x9a, 0x56, 0x51, 0x1a, 0x03, 0x32, 0x45, 0x93, 0xb2, 0xda, 0xbf, 0x26,
	0x21, 0x25, 0x36, 0xf4, 0x7e, 0x3e, 0x3c, 0x26, 0xb6, 0xdf, 0xe1, 0x3e, 0x4c, 0xea, 0x82, 0x40,
	0x97, 0x20, 0xd5, 0xc1, 0xa4, 0xdd, 0xf1, 0x0b, 0x09, 0xce, 0x96, 0x14, 0xba, 0x0b, 0x17, 0x3a,
	0x26, 0x35, 0x5a, 0xa6, 0x75, 0xd8, 0xf6, 0xdc, 0x81, 0x63, 0x1b, 0x84, 0x1d, 0x77, 0x21, 0xc9,
	0x0f, 0x00, 0x75, 0x4c, 0xba, 0x35, 0x5a, 0x12, 0x81, 0x70, 0x17, 0x2e, 0x4c, 0xa2, 0x8d, 0x81,
	0xd7, 0x2d, 0xa4, 0xb8, 0x29, 0xa8, 0x35, 0x0e, 0xdf, 0xf7, 0xba, 0xe8, 0x1e, 0xa4, 0x5a, 0x5d,
	0xd7, 0x3a, 0x0c, 0x8e, 0xef, 0xca, 0xb4, 0x53, 0xb6, 0xd8, 0x3a, 0xf3, 0x85, 0x44, 0xa2, 0x22,
	0x64, 0xf9, 0x2f, 0x79, 0x20, 0xe2, 0x0c, 0x6f, 0xcc, 0x11, 0x1c, 0x1d, 0x49, 0x54, 0x06, 0xdd,
	0x81, 0x24, 0xb6, 0xdb, 0x38, 0x38, 0xcd, 0x8f, 0xa6, 0x85, 0xcb, 0x76, 0x9b, 0x87, 0x8c, 0xc0,
	0xb1, 0x10, 0x78, 0x33, 0x70, 0xac, 0xe8, 0xf9, 0xcd, 0x08, 0x81, 0x6f, 0x24, 0x84, 0x87, 0xc0,
	0x08, 0xcf, 0x82, 0xd4, 0x1d, 0xf8, 0xfd, 0x81, 0x4f, 0x0b, 0x9d, 0x79, 0x41, 0x5a, 0xe7, 0x00,
	0x1e, 0xa4, 0x12, 0xcb, 0x7c, 0xe3, 0xb9, 0x03, 0x1f, 0xd3, 0x02, 0x99, 0xe7, 0x1b, 0x9d, 0xad,
	0x73, 0xdf, 0x08, 0x24, 0x7b, 0x14, 0xc5, 0x0e, 0x75, 0x3d, 0x5a, 0x78, 0x33, 0xef, 0x51, 0x0d,
	0x0e, 0xe0, 0x8f, 0x92, 0x58, 0x2e, 0x46, 0xda, 0x8e, 0xd9, 0xa5, 0x85, 0xc3, 0xb9, 0x62, 0x1c,
	0x20, 0xc4, 0x04, 0x16, 0x5d, 0x86, 0x54, 0xd7, 0x1c, 0x62, 0x8f, 0x16, 0x7e, 0x54, 0x56, 0xe2,
	0xab, 0x19, 0x5d, 0x92, 0xda, 0x3f, 0x28, 0x90, 0x19, 0xa5, 0xdd, 0x54, 0xa0, 0x3e, 0x84, 0x74,
	0xdf, 0xa5, 0x64, 0x14, 0xa5, 0x33, 0xb7, 0xb6, 0x27, 0x11, 0xfa, 0x08, 0x8b, 0x6e, 0x40, 0xf6,
	0xaf, 0x5d, 0xb7, 0x67, 0x1c, 0x98, 0x96, 0xef, 0x7a, 0x32, 0x88, 0x81, 0xb1, 0x76, 0x38, 0x87,
	0x45, 0x32, 0x3b, 0x64, 0x6c, 0xf3, 0x48, 0x4e, 0xeb, 0x92, 0xd2, 0xfe, 0x5e, 0x81, 0x74, 0xa0,
	0x0f, 0xe5, 0x40, 0x39, 0xe1, 0xc6, 0x24, 0x75, 0xe5, 0x84, 0x51, 0x43, 0x6e, 0x44, 0x52, 0x57,
	0x86, 0xef, 0x98, 0x20, 0x57, 0x20, 0xed, 0xb9, 0x22, 0x31, 0x79, 0x52, 0x24, 0xf5, 0x11, 0xcd,
	0x34, 0x71, 0x5f, 0xc8, 0xd8, 0x17, 0x84, 0xf6, 0x5f, 0x71, 0x88, 0x57, 0x5d, 0xeb, 0xfd, 0x52,
	0xd7, 0x3d, 0x76, 0xb0, 0xd8, 0x75, 0x46, 0x17, 0x04, 0x2a, 0xc0, 0x82, 0x87, 0x7b, 0xa6, 0x77,
	0x48, 0xb9, 0x69, 0x19, 0x3d, 0x20, 0xd9, 0x8a, 0x69, 0xdb, 0x1e, 0xa6, 0x94, 0x9b, 0x96, 0xd1,
	0x03, 0x12, 0x5d, 0x85, 0xcc, 0x64, 0x66, 0xa6, 0x49, 0x90, 0x8f, 0xd7, 0x00, 0x68, 0xd7, 0x3d,
	0x36, 0x68, 0x1f, 0x63, 0xbb, 0x60, 0xf3, 0x4d, 0x65, 0x18, 0xa7, 0xc1, 0x18, 0xe8, 0x26, 0xe4,
	0x7a, 0xd8, 0x26, 0x83, 0x9e, 0x04, 0x60, 0x0e, 0xc8, 0x0a, 0x9e, 0x80, 0xdc, 0x82, 0xc5, 0x9e,
	0x79, 0x42, 0x7a, 0x23, 0xcc, 0x01, 0xc7, 0xe4, 0x24, 0x53, 0x80, 0x6e, 0x40, 0x96, 0x2f, 0x1a,
	0xd4, 0xc7, 0x7d, 0x5a, 0x70, 0xc4, 0x49, 0x72, 0x56, 0x83, 0x71, 0x50, 0x15, 0x54, 0xab, 0x63,
	0x3a, 0x6d, 0x6c, 0xd8, 0xc4, 0xc3, 0x3c, 0x8f, 0x0a, 0x27, 0x2b, 0xca, 0x6a, 0xfe, 0xde, 0xcd,
	0x19, 0x65, 0x93, 0x23, 0xb7, 0x03, 0xa0, 0xbe, 0x64, 0x8d, 0x33, 0xd0, 0x53, 0xc8, 0x1d, 0xe1,
	0x0e, 0xb1, 0xba, 0x98, 0xdf, 0x6d, 0x85, 0x21, 0xd7, 0x34, 0x23, 0x81, 0x5f, 0x0a, 0x54, 0x73,
	0xd8, 0xc7, 0x7a, 0xf6, 0x28, 0x24, 0xb4, 0x02, 0xa4, 0xc4, 0x95, 0x30, 0x79, 0x74, 0xda, 0x1b,
	0x48, 0x07, 0x95, 0xff, 0x3d, 0x8e, 0x35, 0xb8, 0x88, 0xe2, 0x67, 0xb9, 0x88, 0xb4, 0x6b, 0x90,
	0x8d, 0xdc, 0x32, 0x53, 0xa6, 0xfc, 0x7b, 0x0c, 0xf2, 0xe3, 0x57, 0xc8, 0x7b, 0x58, 0x74, 0x1b,
	0xf2, 0x32, 0x52, 0x0c, 0xda, 0x37, 0x2d, 0x2c, 0x6c, 0xcb, 0xe8, 0x8b, 0x92, 0xdb, 0xe0, 0x4c,
	0xf4, 0x1a, 0x2e, 0xb6, 0x88, 0x4d, 0x5a, 0x86, 0xbc, 0xa0, 0x0c, 0x2a, 0x13, 0x21, 0xcb, 0x13,
	0xfa, 0xf6, 0x8c, 0x72, 0xcc, 0xe0, 0x13, 0x37, 0xdc, 0xf9, 0xd6, 0x34, 0x13, 0xb5, 0xa0, 0xc0,
	0x85, 0x1d, 0xec, 0x4f, 0x69, 0x07, 0xae, 0x7d, 0x75, 0x96, 0x76, 0xe7, 0x70, 0x58, 0xc3, 0xfe,
	0xc4, 0x03, 0x2e, 0x05, 0x9a, 0xc6, 0xf9, 0xda, 0x2d, 0x58, 0x9e, 0xba, 0x6c, 0xa7, 0xfc, 0xf9,
	0x35, 0x9c, 0x9f, 0x61, 0x34, 0x5a, 0x05, 0x95, 0x62, 0x8f, 0x98, 0x5d, 0xa3, 0xef, 0x7a, 0xbe,
	0xe1, 0x98, 0x3d, 0x2c, 0x85, 0xf2, 0x82, 0xbf, 0xe7, 0x7a, 0x7e, 0xcd, 0xec, 0x61, 0xed, 0x3f,
	0x62, 0x70, 0x69, 0xb6, 0x61, 0x3c, 0x03, 0xb0, 0x77, 0x84, 0x3d, 0xa3, 0xe3, 0x52, 0x5f, 0xca,
	0x83, 0x60, 0x3d, 0x77, 0xa9, 0xcf, 0xd2, 0xb4, 0xed, 0xf5, 0x2d, 0xfe, 0x0c, 0x59, 0xa0, 0xd2,
	0x8c, 0xc1, 0x94, 0xa3, 0x87, 0x70, 0xd9, 0xc3, 0x7f, 0x35, 0x20, 0x1e, 0xb6, 0x8d, 0x63, 0xd7,
	0x3b, 0xc4, 0x9e, 0x71, 0x84, 0x3d, 0xca, 0x3c, 0x24, 0xea, 0xc3, 0xc5, 0x60, 0xf9, 0x15, 0x5f,
	0x7d, 0x29, 0x16, 0xd1, 0x2e, 0x2c, 0x76, 0x5d, 0xcb, 0xec, 0x4a, 0x21, 0x56, 0x35, 0xe2, 0xa7,
	0xfb, 0xb3, 0xca, 0xe0, 0x42, 0x09, 0x8b, 0xc3, 0x5c, 0x37, 0xa4, 0x29, 0xda, 0x84, 0x4b, 0xf8,
	0xc4, 0xea, 0x0e, 0x6c, 0x6c, 0x0c, 0x9c, 0x01, 0xc5, 0xb6, 0xe1, 0xb6, 0xde, 0x60, 0xcb, 0xa7,
	0xb2, 0x47, 0xb8, 0x20, 0x57, 0xf7, 0xf9, 0x62, 0x5d, 0xac, 0xb1, 0x72, 0x6a, 0xbb, 0x3d, 0x93,
	0x38, 0xb2, 0xfa, 0x48, 0x4a, 0xfb, 0xef, 0x38, 0xf3, 0xf7, 0xd4, 0x63, 0xdf, 0x2b, 0xab, 0xd0,
	0x44, 0xe0, 0x18, 0xc4, 0x96, 0x9e, 0x51, 0xc7, 0x3b, 0xaa, 0x0a, 0x2f, 0x46, 0x1d, 0xd3, 0xb3,
	0x8f, 0x4d, 0x0f, 0x33, 0x98, 0x28, 0xa4, 0x10, 0xb0, 0x2a, 0x36, 0xab, 0xbd, 0x66, 0x97, 0x98,
	0x41, 0x25, 0x15, 0x04, 0xda, 0x87, 0xe5, 0xa8, 0x2f, 0x45, 0x65, 0x49, 0xf1, 0xca, 0xf2, 0xd9,
	0x99, 0xfc, 0xc9, 0xab, 0xcc, 0x52, 0x77, 0x9c, 0x81, 0x9e, 0xc0, 0x82, 0x8d, 0x8f, 0x08, 0x4b,
	0x3c, 0xe0, 0x87, 0xb3, 0x32, 0x5f, 0xd9, 0x36, 0x07, 0xea, 0x81, 0x00, 0x93, 0x0d, 0x0e, 0x20,
	0xfb, 0x36, 0x59, 0x71, 0x1a, 0x7a, 0x20, 0xc0, 0x64, 0x79, 0x0f, 0xe1, 0xd1, 0x42, 0xee, 0x6d,
	0xb2, 0xbc, 0xed, 0xf0, 0xf4, 0x40, 0x40, 0x5b, 0x0d, 0xc3, 0x7c, 0x3c, 0x5e, 0xa6, 0x52, 0x6a,
	0x0b, 0xf2, 0xe3, 0x4a, 0xde, 0xfd, 0x74, 0xb5, 0x1f, 0x62, 0xa1, 0x12, 0xe1, 0x81, 0x29, 0x25,
	0x57, 0x21, 0x23, 0x7c, 0xc2, 0x0e, 0x54, 0xa8, 0x48, 0x0b, 0x46, 0xc5, 0x46, 0x65, 0xf6, 0x04,
	0xbe, 0xc8, 0x8f, 0x2c, 0xce, 0x8f, 0xec, 0x93, 0xb7, 0x79, 0x99, 0x9f, 0x16, 0xd8, 0xa3, 0xdf,
	0xd1, 0x1b, 0x36, 0x31, 0x7e, 0xc3, 0x5e, 0x81, 0xb4, 0x4d, 0xa8, 0xd9, 0xea, 0x62, 0x5b, 0x26,
	0xc2, 0x88, 0x66, 0x96, 0x09, 0xaf, 0x31, 0xcb, 0xe4, 0xed, 0x2b, 0x18, 0x15, 0x1b, 0x6d, 0xc2,
	0x65, 0xcb, 0x74, 0x0c, 0xd3, 0xb6, 0x0d, 0xd9, 0x99, 0x19, 0x8f, 0x0d, 0xd6, 0x31, 0xf7, 0x79,
	0xe1, 0x4b, 0xeb, 0xe7, 0x2d, 0xd3, 0x29, 0xda, 0xb6, 0xe8, 0xe0, 0xe8, 0x63, 0x71, 0xeb, 0xcc,
	0x90, 0xda, 0x94, 0x52, 0xd9, 0x19, 0x52, 0x9b, 0x5c, 0x4a, 0xfb, 0x5d, 0xc4, 0x8b, 0x22, 0x16,
	0x66, 0x79, 0x51, 0x44, 0x47, 0xc4, 0x8b, 0x82, 0x21, 0xbc, 0x28, 0x17, 0xcf, 0xe6, 0x45, 0xf1,
	0x0c, 0xe1, 0x45, 0x77, 0xf4, 0x1b, 0xed, 0x40, 0xd6, 0x72, 0x1d, 0x07, 0xcb, 0xd6, 0x5a, 0xd4,
	0xa3, 0x4f, 0x4e, 0xab, 0xef, 0x01, 0x58, 0x8f, 0x0a, 0xa2, 0xd7, 0xc0, 0xde, 0x36, 0x0f, 0x48,
	0x7b, 0xe0, 0x05, 0x0d, 0x19, 0xd3, 0x74, 0xff, 0x6d, 0x06, 0xad, 0x97, 0xa2, 0x52, 0x65, 0xc7,
	0xf7, 0x86, 0xfa, 0xb8, 0xa6, 0x2b, 0x4f, 0x01, 0x4d, 0x83, 0x90, 0x0a, 0xf1, 0x43, 0x3c, 0x94,
	0xde, 0x62, 0x3f, 0x59, 0x99, 0x38, 0x32, 0xbb, 0x03, 0x2c, 0x5d, 0x25, 0x88, 0x27, 0xb1, 0xc7,
	0x8a, 0xf6, 0x37, 0x31, 0x40, 0xd3, 0x1b, 0x98, 0xa1, 0xe2, 0x11, 0x24, 0xfa, 0xc4, 0xa1, 0x85,
	0xd8, 0xbc, 0x37, 0xc4, 0xf1, 0x98, 0xdc, 0x23, 0x8e, 0xce, 0x05, 0xd0, 0x5f, 0x4e, 0x6e, 0x5f,
	0x34, 0x14, 0x8f, 0xce, 0xe2, 0xc8, 0x3f, 0x89, 0x0b, 0x76, 0x60, 0x79, 0xca, 0xf6, 0xf1, 0x34,
	0x55, 0x26, 0xd2, 0xf4, 0x02, 0x24, 0x89, 0x63, 0xe3, 0x13, 0xae, 0x6b, 0x51, 0x17, 0x84, 0xf6,
	0xeb, 0x04, 0x24, 0xf9, 0x8b, 0xdd, 0x7b, 0x5c, 0x0b, 0x57, 0x21, 0x23, 0x06, 0x00, 0xe1, 0x6d,
	0x90, 0x16, 0x8c, 0xca, 0xf8, 0x4b, 0x49, 0xe2, 0x1d, 0x5e, 0x4a, 0x3e, 0x03, 0xf5, 0xd8, 0x24,
	0xbe, 0xd1, 0xf7, 0xdc, 0x96, 0xd9, 0x22, 0x5d, 0xe2, 0x0f, 0x79, 0xb2, 0x26, 0xf5, 0x25, 0xc6,
	0xdf, 0x0b, 0xd9, 0x68, 0x0d, 0x96, 0x7b, 0xc4, 0xe1, 0xad, 0x31, 0x17, 0xf1, 0x49, 0x0f, 0xf3,
	0x14, 0x4d, 0xea, 0x4b, 0x72, 0xe1, 0x95, 0x49, 0xfc, 0x26, 0xe9, 0x61, 0x8e, 0x95, 0x6d, 0x74,
	0x88, 0xcd, 0x49, 0xac, 0x58, 0x18, 0x61, 0x47, 0x26, 0x60, 0xaf, 0x47, 0x28, 0xe5, 0x89, 0xb4,
	0xc8, 0xb7, 0x27, 0x4c, 0x08, 0xd9, 0xac, 0x3b, 0xf7, 0x30, 0x6b, 0x15, 0xb0, 0x41, 0x89, 0x8d,
	0x69, 0x21, 0xcf, 0x2b, 0x44, 0x4e, 0x32, 0x1b, 0x8c, 0x37, 0xb3, 0xf9, 0x5e, 0x7a, 0xef, 0xe6,
	0xbb, 0x0c, 0x37, 0x26, 0xb5, 0x19, 0xe2, 0x71, 0xc4, 0x69, 0x1b, 0xbc, 0xfb, 0x55, 0xb9, 0x11,
	0x1f, 0x4f, 0x48, 0xea, 0x01, 0xa8, 0xea, 0x5a, 0x94, 0xbd, 0x99, 0x10, 0x3a, 0xea, 0x03, 0x11,
	0x97, 0xc8, 0x10, 0x1a, 0xf4, 0x53, 0x4f, 0xe5, 0x50, 0x40, 0x16, 0xbe, 0xf3, 0xfc, 0x04, 0xdf,
	0x3a, 0x14, 0x80, 0x70, 0x28, 0xa0, 0x5d, 0x81, 0x74, 0x30, 0x6a, 0x98, 0xba, 0xb6, 0xfe, 0x47,
	0x01, 0x08, 0x25, 0x7f, 0xee, 0xd0, 0xdb, 0x80, 0x8b, 0x41, 0x5c, 0x30, 0x77, 0x18, 0xc4, 0x91,
	0xbb, 0x10, 0xaf, 0x9b, 0x48, 0x2e, 0x32, 0x37, 0x54, 0x1c, 0x61, 0xc1, 0xa4, 0x88, 0xeb, 0x18,
	0xbe, 0x67, 0x5a, 0x87, 0xf2, 0x3d, 0x34, 0x2a, 0x52, 0x77, 0x9a, 0x6c, 0x45, 0xbb, 0x01, 0x8b,
	0x63, 0x9b, 0x9f, 0xda, 0xe4, 0x3f, 0x2a, 0x90, 0x28, 0xdb, 0x6d, 0xfc, 0x81, 0x64, 0x96, 0xf6,
	0x11, 0x2c, 0xc8, 0x29, 0xcc, 0x94, 0xa9, 0x7f, 0x50, 0x20, 0x1d, 0x0c, 0x5b, 0x3e, 0x94, 0x42,
	0x70, 0x17, 0x92, 0x3c, 0x9a, 0xf8, 0x11, 0x9c, 0x3e, 0xc9, 0x12, 0x40, 0x74, 0x17, 0x52, 0xf4,
	0x98, 0xf8, 0x56, 0x87, 0x37, 0x02, 0x33, 0x5f, 0xff, 0x1a, 0x7c, 0x5d, 0x97, 0x38, 0xf6, 0x02,
	0x18, 0x99, 0x31, 0x4d, 0xb9, 0xe5, 0x87, 0x18, 0xa4, 0x84, 0x44, 0xb4, 0x3b, 0x51, 0xc6, 0xbb,
	0x93, 0x9b, 0x90, 0xeb, 0x98, 0xd4, 0x38, 0xc0, 0xd8, 0x6e, 0xb1, 0x88, 0x89, 0xf1, 0x54, 0xca,
	0x76, 0x4c, 0xba, 0x23, 0x59, 0xac, 0xa0, 0x04, 0xcb, 0x46, 0xa0, 0x45, 0xb8, 0x69, 0x29, 0xe0,
	0x17, 0xa5, 0xb6, 0x4f, 0x61, 0x49, 0xd8, 0x66, 0xd8, 0xc1, 0xd5, 0x23, 0xa2, 0x36, 0x2f, 0xd8,
	0xdb, 0x92, 0xcb, 0xba, 0x7e, 0xe2, 0x1c, 0x61, 0xcf, 0x97, 0x2d, 0x91, 0xa4, 0x98, 0x02, 0xf1,
	0x2b, 0xb4, 0x28, 0xc5, 0x01, 0x79, 0xc1, 0x1e, 0x19, 0x55, 0x83, 0x65, 0xe2, 0x10, 0x9f, 0xbd,
	0x77, 0x85, 0x65, 0x69, 0x61, 0x5e, 0x59, 0x12, 0x6e, 0x08, 0x6b, 0x89, 0x2a, 0x65, 0xc3, 0xba,
	0x74, 0x19, 0x16, 0x08, 0x35, 0xba, 0xf8, 0xc0, 0x2f, 0xa4, 0xa5, 0x45, 0xb4, 0x8a, 0x0f, 0x7c,
	0xed, 0x57, 0x0a, 0xa4, 0xc4, 0x38, 0xee, 0x43, 0x09, 0xad, 0x12, 0x2c, 0xb6, 0x88, 0x63, 0x7a,
	0x43, 0x43, 0xcc, 0x06, 0x65, 0x88, 0x5d, 0x9f, 0x79, 0xbb, 0x9b, 0xde, 0x50, 0x0e, 0x13, 0x73,
	0xad, 0x08, 0xa5, 0x5d, 0x85, 0xcc, 0x68, 0xc8, 0x38, 0x15, 0x39, 0xff, 0xa9, 0x40, 0x2e, 0x2a,
	0x7b, 0x4a, 0xfc, 0x94, 0x20, 0x2b, 0xac, 0x10, 0x8d, 0x5f, 0x8c, 0x9f, 0x80, 0x76, 0xba, 0x29,
	0xb2, 0xed, 0x1b, 0xfd, 0x66, 0xef, 0x5c, 0xa6, 0xe5, 0x93, 0x23, 0x6c, 0xf8, 0xf8, 0xc4, 0x97,
	0x8e, 0x02, 0xc1, 0x6a, 0xe2, 0x13, 0x9f, 0x5d, 0x54, 0xc4, 0x89, 0x42, 0x44, 0x8f, 0x9d, 0x0b,
	0x98, 0x0c, 0xa4, 0xfd, 0x73, 0x02, 0x92, 0xfc, 0x35, 0xe2, 0xe7, 0x3e, 0xa8, 0x75, 0x48, 0x1c,
	0x78, 0x6e, 0x6f, 0xfe, 0x21, 0x95, 0x1d, 0xbb, 0xef, 0x12, 0xc7, 0xd7, 0x39, 0x0e, 0xad, 0x41,
	0xcc, 0x77, 0xe7, 0x27, 0xfe, 0x08, 0x1d, 0xf3, 0x5d, 0xa4, 0x03, 0xb2, 0x3c, 0x97, 0xf2, 0xdb,
	0x2f, 0x9c, 0x29, 0xa7, 0xe6, 0x75, 0x7c, 0x41, 0xbe, 0xbf, 0x22, 0x7e, 0x87, 0x5d, 0x76, 0x58,
	0x5f, 0x0e, 0xc4, 0xbf, 0x19, 0x4d, 0x98, 0xbf, 0x0a, 0x27, 0xcc, 0x0b, 0x5c, 0xd1, 0xcd, 0x79,
	0x13, 0xe6, 0x50, 0xcd, 0x68, 0xce, 0xbc, 0x09, 0x29, 0x7c, 0x84, 0x1d, 0x9f, 0x16, 0xd2, 0x5c,
	0xf6, 0xe3, 0x39, 0x73, 0xe6, 0x32, 0x03, 0xe9, 0x12, 0xcb, 0xda, 0x33, 0x31, 0xdf, 0x13, 0xcd,
	0x8e, 0x20, 0xd0, 0x17, 0x80, 0xac, 0x8e, 0xeb, 0x52, 0x3c, 0xd6, 0x0f, 0x89, 0x1e, 0x67, 0x59,
	0xac, 0x44, 0x3b, 0xa2, 0x15, 0xc8, 0x46, 0x9b, 0x96, 0x9c, 0x38, 0xa6, 0x08, 0x8b, 0x95, 0x0d,
	0xab, 0xeb, 0x52, 0x6c, 0xf3, 0x8e, 0x26, 0xad, 0x4b, 0x8a, 0x4f, 0x22, 0xcd, 0x93, 0xb0, 0xe8,
	0xe4, 0xe5, 0x24, 0xd2, 0x3c, 0x09, 0x2a, 0x0e, 0xbb, 0xd0, 0x83, 0xf9, 0xf8, 0x54, 0xbc, 0xff,
	0x9b, 0x02, 0xe9, 0xe0, 0x54, 0xc2, 0xca, 0xad, 0x9c, 0xb5, 0x72, 0x7f, 0x01, 0x09, 0x6c, 0xb7,
	0xb1, 0x9c, 0x5e, 0x9f, 0xf2, 0xf9, 0x80, 0xc3, 0xd0, 0x13, 0x10, 0x8d, 0x06, 0xef, 0xb9, 0xe4,
	0xab, 0xd2, 0xd5, 0x39, 0x4f, 0x61, 0x2d, 0x98, 0x9e, 0x69, 0x05, 0x3f, 0xb5, 0xef, 0x15, 0x58,
	0x9e, 0x8a, 0x01, 0xf4, 0x25, 0xa4, 0x83, 0xd8, 0x91, 0x56, 0xbf, 0xe5, 0x73, 0xc4, 0x08, 0x8e,
	0xb6, 0x21, 0x27, 0x2b, 0x36, 0x6b, 0xa6, 0xb0, 0x1c, 0xa9, 0xcd, 0x2d, 0xa1, 0x61, 0xc0, 0x64,
	0x85, 0x18, 0x27, 0x34, 0x1d, 0x96, 0x26, 0xd6, 0xd1, 0xd7, 0x90, 0x09, 0x0b, 0xb3, 0x72, 0xd6,
	0xc2, 0x1c, 0xca, 0x68, 0xff, 0xa2, 0xc0, 0xd2, 0x44, 0x94, 0xa2, 0xfb, 0x90, 0x92, 0x35, 0x4f,
	0x6c, 0xf3, 0xd4, 0x4f, 0x27, 0x12, 0x8a, 0x5e, 0xc1, 0xf9, 0xb1, 0x7a, 0x39, 0xb6, 0xd3, 0x4f,
	0x4f, 0x2f, 0x55, 0x91, 0x3c, 0x8b, 0x96, 0x4f, 0xb1, 0xeb, 0x3b, 0x70, 0x71, 0x26, 0x96, 0x85,
	0xa9, 0xa8, 0x4b, 0xdc, 0xcc, 0xb4, 0x2e, 0x29, 0xed, 0xef, 0x14, 0x80, 0x30, 0x79, 0xd8, 0x6e,
	0xc4, 0x2b, 0xfa, 0xfc, 0xdd, 0x84, 0x5f, 0x67, 0x24, 0x14, 0x6d, 0x41, 0xa6, 0x85, 0x3b, 0xe6,
	0x11, 0x71, 0xbd, 0xe0, 0xcd, 0xf0, 0x93, 0xd3, 0x52, 0x74, 0x4b, 0x82, 0xf5, 0x50, 0x4c, 0xfb,
	0x3f, 0x05, 0xd0, 0x34, 0x82, 0x35, 0xd5, 0x66, 0xbf, 0xdf, 0x25, 0x98, 0x1a, 0xbe, 0x2b, 0xd3,
	0x23, 0x23, 0x39, 0x4d, 0x17, 0xbd, 0x80, 0x3c, 0xf7, 0x9c, 0x11, 0x28, 0x92, 0xd5, 0x7e, 0xde,
	0xe3, 0xb9, 0x2f, 0x46, 0x8f, 0x5f, 0xa4, 0x51, 0x12, 0x55, 0x20, 0x2f, 0x66, 0xfe, 0x23, 0x65,
	0xf1, 0x79, 0x57, 0x47, 0xd5, 0xb5, 0xf8, 0x77, 0x82, 0x88, 0xaa, 0x28, 0xa9, 0xfd, 0x3f, 0xeb,
	0x73, 0x84, 0x73, 0x3e, 0x90, 0x1b, 0x7a, 0xfe, 0xe7, 0x96, 0x51, 0x71, 0x49, 0x9d, 0xbd, 0xb8,
	0x24, 0x69, 0xc7, 0xec, 0x63, 0xd9, 0xdc, 0x5c, 0x9e, 0x11, 0x23, 0x6c, 0x59, 0x17, 0xa8, 0x48,
	0x73, 0x20, 0x43, 0x2b, 0x7d, 0x7a, 0x73, 0x20, 0x03, 0x4c, 0x36, 0x07, 0x82, 0x62, 0xcd, 0xc1,
	0x28, 0xf0, 0xa6, 0x8a, 0x65, 0x3e, 0xe8, 0x0d, 0x24, 0xf8, 0x97, 0x0a, 0xa4, 0xc4, 0xd7, 0xc0,
	0x0f, 0xc5, 0xfd, 0x4f, 0x21, 0x17, 0x14, 0x58, 0x66, 0x96, 0xbc, 0x89, 0xaf, 0xcd, 0x2d, 0xb1,
	0xfc, 0x4b, 0x66, 0xb6, 0x15, 0x12, 0xda, 0xef, 0x13, 0x90, 0x8d, 0x2c, 0xa2, 0x2b, 0x90, 0x96,
	0x27, 0xb8, 0x11, 0x4c, 0x26, 0x02, 0x3a, 0xb2, 0x76, 0x2f, 0x18, 0x8b, 0x05, 0x74, 0x64, 0xed,
	0x7e, 0xb0, 0xbb, 0x80, 0x8e, 0xac, 0x6d, 0xca, 0x76, 0x66, 0x44, 0xa3, 0x55, 0x50, 0x09, 0x35,
	0x3c, 0x6c, 0x1b, 0xe6, 0x91, 0x49, 0xba, 0x66, 0xab, 0x8b, 0xe5, 0xcc, 0x2f, 0x4f, 0xa8, 0x8e,
	0xed, 0x62, 0xc0, 0x65, 0xad, 0x13, 0x83, 0xf5, 0x4d, 0xdf, 0xc7, 0x9e, 0x23, 0xef, 0x56, 0xf0,
	0xb0, 0xbd, 0x27, 0x38, 0xe8, 0x73, 0x40, 0x84, 0x1a, 0x6d, 0x0f, 0x63, 0x27, 0xa2, 0xec, 0x02,
	0x57, 0xa6, 0x12, 0xfa, 0x8c, 0x2d, 0x84, 0xea, 0x6e, 0xc1, 0xa2, 0x80, 0x06, 0x0a, 0x2f, 0x8a,
	0xef, 0x75, 0x9c, 0x19, 0xa8, 0x5c, 0x87, 0xf3, 0x84, 0x1a, 0x43, 0xdc, 0xed, 0xba, 0xc7, 0x11,
	0x9d, 0xd7, 0xb9, 0xce, 0x65, 0x42, 0x5f, 0xf3, 0x95, 0x50, 0xe9, 0x6d, 0xc8, 0x4b, 0x70, 0xa0,
	0xf5, 0x06, 0xd7, 0xba, 0x28, 0xb8, 0xe3, 0x96, 0x1e, 0x77, 0x88, 0x8f, 0x23, 0x5a, 0x57, 0x03,
	0x4b, 0x5f, 0xb1, 0x85, 0x31, 0x4b, 0x05, 0x34, 0xd0, 0xf9, 0x99, 0xb0, 0x94, 0x33, 0x03, 0x95,
	0xa3, 0x74, 0xbb, 0x77, 0xd6, 0x74, 0x1b, 0xbf, 0x9c, 0xef, 0xbf, 0xcb, 0xe5, 0x8c, 0x1e, 0x40,
	0x82, 0x37, 0xc1, 0x7f, 0x3e, 0xef, 0xb6, 0x8b, 0x84, 0x14, 0xef, 0x81, 0x39, 0x9c, 0x67, 0x5b,
	0xf0, 0x35, 0x7d, 0x32, 0x85, 0xd6, 0x3e, 0x85, 0xa5, 0x89, 0x99, 0x0a, 0xca, 0x40, 0xb2, 0x58,
	0xad, 0xd6, 0x5f, 0xa9, 0xe7, 0xf8, 0xcf, 0x97, 0xf5, 0xca, 0xb6, 0xaa, 0xac, 0xdd, 0x80, 0x6c,
	0xe4, 0x7b, 0x25, 0x5a, 0x80, 0x78, 0xb5, 0x5e, 0x52, 0xcf, 0xb1, 0x1f, 0xa5, 0xa2, 0xae, 0x2a,
	0x6b, 0x1b, 0x70, 0x79, 0xce, 0x67, 0x07, 0xa6, 0xa6, 0x5a, 0xa9, 0xed, 0x7f, 0xa7, 0x9e, 0x43,
	0x59, 0x58, 0x28, 0x37, 0xf6, 0x9e, 0xd7, 0x77, 0xcb, 0xaa, 0xb2, 0xf6, 0xbd, 0x12, 0x4e, 0x2a,
	0xc3, 0xb9, 0x37, 0xca, 0x41, 0x7a, 0xb7, 0xb4, 0x77, 0xef, 0xfe, 0xdd, 0xbb, 0x8f, 0xd5, 0x73,
	0x21, 0xb5, 0xf1, 0x48, 0x55, 0x98, 0xfc, 0x5e, 0xa9, 0xf8, 0xe5, 0xc3, 0xc7, 0x0f, 0xd4, 0x98,
	0x20, 0x76, 0x1e, 0x3f, 0x78, 0xb4, 0xa9, 0xc6, 0x19, 0x51, 0xdc, 0x6e, 0x6c, 0x6c, 0x6c, 0x3c,
	0x50, 0x13, 0x08, 0x41, 0x7e, 0xab, 0x52, 0x7b, 0xf1, 0xba, 0x54, 0xd4, 0x1b, 0xe5, 0x5a, 0xa3,
	0xae, 0xab, 0x49, 0xb4, 0x08, 0x99, 0xdd, 0x6f, 0x9b, 0x4d, 0xe3, 0xd9, 0x5e, 0xa5, 0xae, 0xa6,
	0x50, 0x1e, 0x80, 0x93, 0x8d, 0xb2, 0xfe, 0xb2, 0xae, 0x2e, 0xa0, 0x34, 0x24, 0xf8, 0x4a, 0x7a,
	0xed, 0x6f, 0x23, 0x66, 0x85, 0x83, 0x64, 0xa4, 0x42, 0x6e, 0xab, 0x52, 0x2b, 0xea, 0xaf, 0xa5,
	0xc6, 0x73, 0x21, 0xa7, 0xbe, 0xdf, 0xdc, 0xdb, 0x6f, 0xaa, 0x0a, 0x5a, 0x82, 0x2c, 0xd7, 0xd7,
	0x78, 0x55, 0x69, 0x96, 0x9e, 0xab, 0x31, 0xc6, 0xd0, 0xcb, 0xd5, 0xe2, 0x6b, 0xc9, 0x88, 0xa3,
	0x65, 0x58, 0x6c, 0xea, 0xc5, 0xd2, 0x8b, 0x4a, 0xed, 0x65, 0x59, 0x6f, 0x96, 0x75, 0x61, 0xec,
	0x6e, 0xf1, 0x59, 0xad, 0xdc, 0xac, 0x94, 0x24, 0x2c, 0xb9, 0xb6, 0x1a, 0x74, 0x3c, 0xe1, 0xb9,
	0xe4, 0x20, 0xdd, 0x68, 0xea, 0xc5, 0xca, 0xb3, 0xe7, 0x4d, 0xe1, 0xf7, 0xfa, 0xce, 0x8e, 0xaa,
	0xac, 0x3d, 0x01, 0x75, 0xf2, 0xe5, 0x87, 0x3d, 0x75, 0xab, 0xde, 0x34, 0xb6, 0xcb, 0x3b, 0xc5,
	0xfd, 0x2a, 0x43, 0x5f, 0x84, 0x65, 0xc6, 0x18, 0x7f, 0xb2, 0xb2, 0xb6, 0x02, 0x99, 0x51, 0xa4,
	0xb1, 0x53, 0xda, 0xd1, 0xeb, 0x35, 0x06, 0x4f, 0x43, 0x62, 0xab, 0x58, 0x7a, 0xa1, 0x2a, 0x6b,
	0x3b, 0xf2, 0x26, 0x1f, 0xbb, 0x6c, 0xd9, 0xc6, 0xf5, 0xc6, 0x96, 0x51, 0xab, 0x97, 0x9e, 0x17,
	0x6b, 0xcf, 0xca, 0xea, 0x39, 0xe6, 0x5c, 0xc6, 0x29, 0xd7, 0xb8, 0x62, 0xbe, 0xed, 0xc6, 0x96,
	0xa1, 0x97, 0x8b, 0xa5, 0xe7, 0xe5, 0x6d, 0x35, 0xb6, 0xd6, 0x06, 0x75, 0xf2, 0x9e, 0x65, 0xa0,
	0x6a, 0x63, 0x2b, 0x62, 0xa5, 0x0a, 0xb9, 0x6a, 0x54, 0xad, 0xc2, 0x0e, 0x89, 0x71, 0x76, 0xcb,
	0xdb, 0x95, 0xfd, 0x5d, 0xe1, 0x4e, 0x4e, 0x57, 0x6a, 0x95, 0xdd, 0xfd, 0x5d, 0x35, 0x3e, 0x62,
	0x14, 0xbf, 0xe3, 0x8c, 0xc4, 0xda, 0x13, 0x48, 0xf2, 0x0b, 0x0b, 0x01, 0xa4, 0x4a, 0x15, 0xbd,
	0x54, 0x2d, 0x8b, 0x18, 0x6a, 0xea, 0x95, 0x62, 0xed, 0x59, 0x95, 0x29, 0x05, 0x48, 0x35, 0xbe,
	0xdd, 0x2f, 0xea, 0x65, 0x11, 0x42, 0xdb, 0x95, 0xe2, 0x6e, 0xbd, 0xb6, 0xad, 0xc6, 0xd7, 0xfe,
	0x0c, 0x96, 0x26, 0x52, 0x88, 0x39, 0xa5, 0x5c, 0x6b, 0xea, 0xaf, 0x85, 0x53, 0xca, 0xdf, 0x55,
	0x9a, 0xaa, 0xb2, 0x55, 0xfa, 0xf1, 0xa7, 0xeb, 0xca, 0x2f, 0x7e, 0xba, 0xae, 0xfc, 0xe6, 0xa7,
	0xeb, 0xca, 0x3f, 0xfd, 0xf6, 0xfa, 0xb9, 0xbf, 0xd8, 0x68, 0x13, 0xbf, 0x33, 0x68, 0xad, 0x5b,
	0x6e, 0xef, 0xce, 0x58, 0x5a, 0xde, 0xe1, 0x81, 0xa4, 0x07, 0x54, 0xff, 0xb0, 0x7d, 0xc7, 0xec,
	0x93, 0x3b, 0x47, 0x1b, 0xad, 0x14, 0xff, 0xcb, 0xdb, 0xfd, 0x3f, 0x06, 0x00, 0x00, 0xff, 0xff,
	0x38, 0xd2, 0xa1, 0x30, 0x0a, 0x27, 0x00, 0x00,
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContentBase64) > 0 {
		i -= len(m.ContentBase64)
		copy(dAtA[i:], m.ContentBase64)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ContentBase64)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Railway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Railway) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Railway) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CommandStations) > 0 {
		for iNdEx := len(m.CommandStations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommandStations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.LocGroups) > 0 {
		for iNdEx := len(m.LocGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Locs) > 0 {
		for iNdEx := len(m.Locs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Modules) > 0 {
		for iNdEx := len(m.Modules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Modules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Dirty {
		i--
		if m.Dirty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Module) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Module) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Module) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Layers) > 0 {
		for iNdEx := len(m.Layers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Layers[iNdEx])
			copy(dAtA[i:], m.Layers[iNdEx])
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Layers[iNdEx])))
			i--
			dAtA[i] = 0xc
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Signals) > 0 {
		for iNdEx := len(m.Signals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.Sensors) > 0 {
		for iNdEx := len(m.Sensors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sensors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Junctions) > 0 {
		for iNdEx := len(m.Junctions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Junctions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.Edges) > 0 {
		for iNdEx := len(m.Edges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Edges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.BlockGroups) > 0 {
		for iNdEx := len(m.BlockGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.BackgroundImageUrl) > 0 {
		i -= len(m.BackgroundImageUrl)
		copy(dAtA[i:], m.BackgroundImageUrl)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.BackgroundImageUrl)))
		i--
		dAtA[i] = 0x32
	}
	if m.HasBackgroundImage {
		i--
		if m.HasBackgroundImage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Height != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if m.Width != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModuleRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ZoomFactor != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ZoomFactor))
		i--
		dAtA[i] = 0x18
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Layer) > 0 {
		i -= len(m.Layer)
		copy(dAtA[i:], m.Layer)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Layer)))
		i--
		dAtA[i] = 0x32
	}
	if m.Rotation != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Rotation))
		i--
		dAtA[i] = 0x28
	}
	if m.Height != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if m.Width != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Loc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Loc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Loc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VehicleType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.VehicleType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if m.ChangeDirection != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ChangeDirection))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.SpeedSteps != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SpeedSteps))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if m.MaximumSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MaximumSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.MediumSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MediumSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.SlowSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SlowSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ImageUrl) > 0 {
		i -= len(m.ImageUrl)
		copy(dAtA[i:], m.ImageUrl)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ImageUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Remarks) > 0 {
		i -= len(m.Remarks)
		copy(dAtA[i:], m.Remarks)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Remarks)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Locs) > 0 {
		for iNdEx := len(m.Locs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocGroupRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocGroupRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocGroupRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandStation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandStation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BidibCommandStation != nil {
		{
			size, err := m.BidibCommandStation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.BinkynetCommandStation != nil {
		{
			size, err := m.BinkynetCommandStation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.AddressSpaces) > 0 {
		for iNdEx := len(m.AddressSpaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddressSpaces[iNdEx])
			copy(dAtA[i:], m.AddressSpaces[iNdEx])
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.AddressSpaces[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandStationRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStationRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandStationRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BidibCommandStation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidibCommandStation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BidibCommandStation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SerialPortName) > 0 {
		i -= len(m.SerialPortName)
		copy(dAtA[i:], m.SerialPortName)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.SerialPortName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetCommandStation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetCommandStation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetCommandStation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x32
	}
	if m.ExcludeUnusedObjects {
		i--
		if m.ExcludeUnusedObjects {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.LocalWorkers) > 0 {
		for iNdEx := len(m.LocalWorkers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalWorkers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RequiredWorkerVersion) > 0 {
		i -= len(m.RequiredWorkerVersion)
		copy(dAtA[i:], m.RequiredWorkerVersion)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.RequiredWorkerVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GrpcPort != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.GrpcPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ServerHost) > 0 {
		i -= len(m.ServerHost)
		copy(dAtA[i:], m.ServerHost)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ServerHost)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetLocalWorker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetLocalWorker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetLocalWorker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Routers) > 0 {
		for iNdEx := len(m.Routers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.LocalWorkerType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.LocalWorkerType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Alias) > 0 {
		i -= len(m.Alias)
		copy(dAtA[i:], m.Alias)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Alias)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HardwareId) > 0 {
		i -= len(m.HardwareId)
		copy(dAtA[i:], m.HardwareId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.HardwareId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CommandStationId) > 0 {
		i -= len(m.CommandStationId)
		copy(dAtA[i:], m.CommandStationId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.CommandStationId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetLocalWorkerRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetLocalWorkerRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetLocalWorkerRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetRouter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetRouter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CanAddSensors_4Group {
		i--
		if m.CanAddSensors_4Group {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.CanAddSensors_8Group {
		i--
		if m.CanAddSensors_8Group {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.RouterId) > 0 {
		i -= len(m.RouterId)
		copy(dAtA[i:], m.RouterId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.RouterId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if m.DeviceType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.DeviceType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Configuration) > 0 {
		for k := range m.Configuration {
			v := m.Configuration[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBrModelTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Connections) > 0 {
		for iNdEx := len(m.Connections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Connections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ObjectType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ObjectType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ObjectId) > 0 {
		i -= len(m.ObjectId)
		copy(dAtA[i:], m.ObjectId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ObjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetConnection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetConnection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetConnection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Configuration) > 0 {
		for k := range m.Configuration {
			v := m.Configuration[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBrModelTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Pins) > 0 {
		for iNdEx := len(m.Pins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetDevicePin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetDevicePin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetDevicePin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockGroup != nil {
		{
			size, err := m.BlockGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.IsStation {
		i--
		if m.IsStation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ChangeDirectionReversingLocs {
		i--
		if m.ChangeDirectionReversingLocs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ChangeDirection != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ChangeDirection))
		i--
		dAtA[i] = 0x78
	}
	if m.ReverseSides {
		i--
		if m.ReverseSides {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.WaitPermissions) > 0 {
		i -= len(m.WaitPermissions)
		copy(dAtA[i:], m.WaitPermissions)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.WaitPermissions)))
		i--
		dAtA[i] = 0x6a
	}
	if m.MaximumWaitTime != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MaximumWaitTime))
		i--
		dAtA[i] = 0x60
	}
	if m.MinimumWaitTime != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MinimumWaitTime))
		i--
		dAtA[i] = 0x58
	}
	if m.WaitProbability != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.WaitProbability))
		i--
		dAtA[i] = 0x50
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinimumLocsOnTrack != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MinimumLocsOnTrack))
		i--
		dAtA[i] = 0x28
	}
	if m.MinimumLocsInGroup != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MinimumLocsInGroup))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockGroupRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockGroupRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockGroupRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Edge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Edge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Edge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EdgeRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Junction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Junction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Junction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Switch != nil {
		{
			size, err := m.Switch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JunctionRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunctionRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JunctionRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Switch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Switch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Switch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsLeft {
		i--
		if m.IsLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.InitialDirection != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.InitialDirection))
		i--
		dAtA[i] = 0x38
	}
	if m.InvertFeedback {
		i--
		if m.InvertFeedback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Invert {
		i--
		if m.Invert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SwitchDuration != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SwitchDuration))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FeedbackAddress) > 0 {
		i -= len(m.FeedbackAddress)
		copy(dAtA[i:], m.FeedbackAddress)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.FeedbackAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.HasFeedback {
		i--
		if m.HasFeedback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinaryOutput != nil {
		{
			size, err := m.BinaryOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InactiveText) > 0 {
		i -= len(m.InactiveText)
		copy(dAtA[i:], m.InactiveText)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.InactiveText)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ActiveText) > 0 {
		i -= len(m.ActiveText)
		copy(dAtA[i:], m.ActiveText)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ActiveText)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OutputType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxDuration != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MaxDuration))
		i--
		dAtA[i] = 0x70
	}
	if m.Closed {
		i--
		if m.Closed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.Permissions) > 0 {
		i -= len(m.Permissions)
		copy(dAtA[i:], m.Permissions)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Permissions)))
		i--
		dAtA[i] = 0x62
	}
	if m.ChooseProbability != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ChooseProbability))
		i--
		dAtA[i] = 0x58
	}
	if m.Speed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CrossingJunctions) > 0 {
		for iNdEx := len(m.CrossingJunctions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CrossingJunctions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockSide != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.BlockSide))
		i--
		dAtA[i] = 0x18
	}
	if m.Edge != nil {
		{
			size, err := m.Edge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JunctionWithState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunctionWithState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JunctionWithState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SwitchState != nil {
		{
			size, err := m.SwitchState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Junction != nil {
		{
			size, err := m.Junction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwitchWithState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWithState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchWithState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Direction != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OutputWithState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputWithState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputWithState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinaryOutputState != nil {
		{
			size, err := m.BinaryOutputState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOutputWithState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOutputWithState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOutputWithState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Behaviors) > 0 {
		for iNdEx := len(m.Behaviors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Behaviors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Sensor != nil {
		{
			size, err := m.Sensor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteEventBehavior) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteEventBehavior) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteEventBehavior) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SpeedBehavior != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SpeedBehavior))
		i--
		dAtA[i] = 0x18
	}
	if m.StateBehavior != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.StateBehavior))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppliesTo) > 0 {
		i -= len(m.AppliesTo)
		copy(dAtA[i:], m.AppliesTo)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.AppliesTo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinarySensor != nil {
		{
			size, err := m.BinarySensor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Shape != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Shape))
		i--
		dAtA[i] = 0x38
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SensorRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinarySensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinarySensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinarySensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Signal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockSignal != nil {
		{
			size, err := m.BlockSignal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockSignal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSignal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockSignal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.BlockSide != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.BlockSide))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.WhitePattern != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.WhitePattern))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.IsWhiteAvailable {
		i--
		if m.IsWhiteAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.YellowPattern != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.YellowPattern))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.IsYellowAvailable {
		i--
		if m.IsYellowAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.GreenPattern != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.GreenPattern))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.IsGreenAvailable {
		i--
		if m.IsGreenAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.RedPattern != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.RedPattern))
		i--
		dAtA[i] = 0x58
	}
	if m.IsRedAvailable {
		i--
		if m.IsRedAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Address4) > 0 {
		i -= len(m.Address4)
		copy(dAtA[i:], m.Address4)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address4)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Address3) > 0 {
		i -= len(m.Address3)
		copy(dAtA[i:], m.Address3)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address3)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address2) > 0 {
		i -= len(m.Address2)
		copy(dAtA[i:], m.Address2)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address1) > 0 {
		i -= len(m.Address1)
		copy(dAtA[i:], m.Address1)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignalRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBrModelTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovBrModelTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentBase64)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Railway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Dirty {
		n += 2
	}
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Locs) > 0 {
		for _, e := range m.Locs {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.LocGroups) > 0 {
		for _, e := range m.LocGroups {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.CommandStations) > 0 {
		for _, e := range m.CommandStations {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Module) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Height))
	}
	if m.HasBackgroundImage {
		n += 2
	}
	l = len(m.BackgroundImageUrl)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.BlockGroups) > 0 {
		for _, e := range m.BlockGroups {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Junctions) > 0 {
		for _, e := range m.Junctions {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Sensors) > 0 {
		for _, e := range m.Sensors {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Signals) > 0 {
		for _, e := range m.Signals {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Layers) > 0 {
		for _, s := range m.Layers {
			l = len(s)
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModuleRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.ZoomFactor != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ZoomFactor))
	}
	if m.Locked {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovBrModelTypes(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Y))
	}
	if m.Width != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Height))
	}
	if m.Rotation != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Rotation))
	}
	l = len(m.Layer)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Loc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Remarks)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.SlowSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.SlowSpeed))
	}
	if m.MediumSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.MediumSpeed))
	}
	if m.MaximumSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.MaximumSpeed))
	}
	if m.SpeedSteps != 0 {
		n += 2 + sovBrModelTypes(uint64(m.SpeedSteps))
	}
	if m.ChangeDirection != 0 {
		n += 2 + sovBrModelTypes(uint64(m.ChangeDirection))
	}
	if m.VehicleType != 0 {
		n += 2 + sovBrModelTypes(uint64(m.VehicleType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.Locs) > 0 {
		for _, e := range m.Locs {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocGroupRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandStation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.AddressSpaces) > 0 {
		for _, s := range m.AddressSpaces {
			l = len(s)
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.BinkynetCommandStation != nil {
		l = m.BinkynetCommandStation.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BidibCommandStation != nil {
		l = m.BidibCommandStation.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandStationRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidibCommandStation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SerialPortName)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetCommandStation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerHost)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.GrpcPort != 0 {
		n += 1 + sovBrModelTypes(uint64(m.GrpcPort))
	}
	l = len(m.RequiredWorkerVersion)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.LocalWorkers) > 0 {
		for _, e := range m.LocalWorkers {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.ExcludeUnusedObjects {
		n += 2
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetLocalWorker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.CommandStationId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.HardwareId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.LocalWorkerType != 0 {
		n += 1 + sovBrModelTypes(uint64(m.LocalWorkerType))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Routers) > 0 {
		for _, e := range m.Routers {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetLocalWorkerRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetRouter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.DeviceType != 0 {
		n += 1 + sovBrModelTypes(uint64(m.DeviceType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	l = len(m.RouterId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.CanAddSensors_8Group {
		n += 2
	}
	if m.CanAddSensors_4Group {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.ObjectType != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ObjectType))
	}
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Configuration) > 0 {
		for k, v := range m.Configuration {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBrModelTypes(uint64(len(k))) + 1 + len(v) + sovBrModelTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovBrModelTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetConnection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.Pins) > 0 {
		for _, e := range m.Pins {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Configuration) > 0 {
		for k, v := range m.Configuration {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBrModelTypes(uint64(len(k))) + 1 + len(v) + sovBrModelTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovBrModelTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetDevicePin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.WaitProbability != 0 {
		n += 1 + sovBrModelTypes(uint64(m.WaitProbability))
	}
	if m.MinimumWaitTime != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MinimumWaitTime))
	}
	if m.MaximumWaitTime != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MaximumWaitTime))
	}
	l = len(m.WaitPermissions)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.ReverseSides {
		n += 2
	}
	if m.ChangeDirection != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ChangeDirection))
	}
	if m.ChangeDirectionReversingLocs {
		n += 3
	}
	if m.IsStation {
		n += 3
	}
	if m.BlockGroup != nil {
		l = m.BlockGroup.Size()
		n += 2 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.MinimumLocsInGroup != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MinimumLocsInGroup))
	}
	if m.MinimumLocsOnTrack != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MinimumLocsOnTrack))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockGroupRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Edge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EdgeRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Junction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Switch != nil {
		l = m.Switch.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JunctionRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Switch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.HasFeedback {
		n += 2
	}
	l = len(m.FeedbackAddress)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.SwitchDuration != 0 {
		n += 1 + sovBrModelTypes(uint64(m.SwitchDuration))
	}
	if m.Invert {
		n += 2
	}
	if m.InvertFeedback {
		n += 2
	}
	if m.InitialDirection != 0 {
		n += 1 + sovBrModelTypes(uint64(m.InitialDirection))
	}
	if m.IsLeft {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BinaryOutput != nil {
		l = m.BinaryOutput.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OutputRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinaryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.OutputType != 0 {
		n += 1 + sovBrModelTypes(uint64(m.OutputType))
	}
	l = len(m.ActiveText)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.InactiveText)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.CrossingJunctions) > 0 {
		for _, e := range m.CrossingJunctions {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.Speed != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Speed))
	}
	if m.ChooseProbability != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ChooseProbability))
	}
	l = len(m.Permissions)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Closed {
		n += 2
	}
	if m.MaxDuration != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MaxDuration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Edge != nil {
		l = m.Edge.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BlockSide != 0 {
		n += 1 + sovBrModelTypes(uint64(m.BlockSide))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JunctionWithState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Junction != nil {
		l = m.Junction.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.SwitchState != nil {
		l = m.SwitchState.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwitchWithState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Direction))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OutputWithState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BinaryOutputState != nil {
		l = m.BinaryOutputState.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinaryOutputWithState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Active {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sensor != nil {
		l = m.Sensor.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.Behaviors) > 0 {
		for _, e := range m.Behaviors {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteEventBehavior) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppliesTo)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.StateBehavior != 0 {
		n += 1 + sovBrModelTypes(uint64(m.StateBehavior))
	}
	if m.SpeedBehavior != 0 {
		n += 1 + sovBrModelTypes(uint64(m.SpeedBehavior))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Shape != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Shape))
	}
	if m.BinarySensor != nil {
		l = m.BinarySensor.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinarySensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Signal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BlockSignal != nil {
		l = m.BlockSignal.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockSignal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address1)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Address2)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Address3)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Address4)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.IsRedAvailable {
		n += 2
	}
	if m.RedPattern != 0 {
		n += 1 + sovBrModelTypes(uint64(m.RedPattern))
	}
	if m.IsGreenAvailable {
		n += 3
	}
	if m.GreenPattern != 0 {
		n += 2 + sovBrModelTypes(uint64(m.GreenPattern))
	}
	if m.IsYellowAvailable {
		n += 3
	}
	if m.YellowPattern != 0 {
		n += 2 + sovBrModelTypes(uint64(m.YellowPattern))
	}
	if m.IsWhiteAvailable {
		n += 3
	}
	if m.WhitePattern != 0 {
		n += 2 + sovBrModelTypes(uint64(m.WhitePattern))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 2 + l + sovBrModelTypes(uint64(l))
	}
	if m.BlockSide != 0 {
		n += 2 + sovBrModelTypes(uint64(m.BlockSide))
	}
	if m.Type != 0 {
		n += 2 + sovBrModelTypes(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBrModelTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBrModelTypes(x uint64) (n int) {
	return sovBrModelTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentBase64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentBase64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Railway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Railway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Railway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dirty = bool(v != 0)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modules = append(m.Modules, &ModuleRef{})
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locs = append(m.Locs, &LocRef{})
			if err := m.Locs[len(m.Locs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocGroups = append(m.LocGroups, &LocGroupRef{})
			if err := m.LocGroups[len(m.LocGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandStations = append(m.CommandStations, &CommandStationRef{})
			if err := m.CommandStations[len(m.CommandStations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Module) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Module: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Module: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasBackgroundImage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasBackgroundImage = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackgroundImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockRef{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockGroups = append(m.BlockGroups, &BlockGroupRef{})
			if err := m.BlockGroups[len(m.BlockGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &EdgeRef{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Junctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Junctions = append(m.Junctions, &JunctionRef{})
			if err := m.Junctions[len(m.Junctions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &OutputRef{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteRef{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sensors = append(m.Sensors, &SensorRef{})
			if err := m.Sensors[len(m.Sensors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signals = append(m.Signals, &SignalRef{})
			if err := m.Signals[len(m.Signals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoomFactor", wireType)
			}
			m.ZoomFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZoomFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			m.Rotation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Loc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Loc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Loc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remarks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remarks = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowSpeed", wireType)
			}
			m.SlowSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlowSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediumSpeed", wireType)
			}
			m.MediumSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediumSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumSpeed", wireType)
			}
			m.MaximumSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedSteps", wireType)
			}
			m.SpeedSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedSteps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDirection", wireType)
			}
			m.ChangeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeDirection |= ChangeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VehicleType", wireType)
			}
			m.VehicleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VehicleType |= VehicleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locs = append(m.Locs, &LocRef{})
			if err := m.Locs[len(m.Locs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocGroupRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocGroupRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocGroupRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressSpaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressSpaces = append(m.AddressSpaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinkynetCommandStation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinkynetCommandStation == nil {
				m.BinkynetCommandStation = &BinkyNetCommandStation{}
			}
			if err := m.BinkynetCommandStation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidibCommandStation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BidibCommandStation == nil {
				m.BidibCommandStation = &BidibCommandStation{}
			}
			if err := m.BidibCommandStation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStationRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStationRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStationRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidibCommandStation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidibCommandStation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidibCommandStation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialPortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialPortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetCommandStation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetCommandStation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetCommandStation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcPort", wireType)
			}
			m.GrpcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredWorkerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredWorkerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalWorkers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalWorkers = append(m.LocalWorkers, &BinkyNetLocalWorkerRef{})
			if err := m.LocalWorkers[len(m.LocalWorkers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeUnusedObjects", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeUnusedObjects = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetLocalWorker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetLocalWorker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetLocalWorker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandStationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalWorkerType", wireType)
			}
			m.LocalWorkerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalWorkerType |= BinkyNetLocalWorkerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &BinkyNetDevice{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &BinkyNetObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routers = append(m.Routers, &BinkyNetRouter{})
			if err := m.Routers[len(m.Routers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetLocalWorkerRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetLocalWorkerRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetLocalWorkerRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= BinkyNetDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddSensors_8Group", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAddSensors_8Group = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddSensors_4Group", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAddSensors_4Group = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			m.ObjectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectType |= BinkyNetObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &BinkyNetConnection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBrModelTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrModelTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrModelTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBrModelTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Configuration[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetConnection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetConnection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetConnection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pins = append(m.Pins, &BinkyNetDevicePin{})
			if err := m.Pins[len(m.Pins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBrModelTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrModelTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrModelTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBrModelTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Configuration[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetDevicePin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetDevicePin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetDevicePin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitProbability", wireType)
			}
			m.WaitProbability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitProbability |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumWaitTime", wireType)
			}
			m.MinimumWaitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumWaitTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumWaitTime", wireType)
			}
			m.MaximumWaitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumWaitTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitPermissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WaitPermissions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseSides", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReverseSides = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDirection", wireType)
			}
			m.ChangeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeDirection |= ChangeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDirectionReversingLocs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeDirectionReversingLocs = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStation = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockGroup == nil {
				m.BlockGroup = &BlockGroupRef{}
			}
			if err := m.BlockGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumLocsInGroup", wireType)
			}
			m.MinimumLocsInGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumLocsInGroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumLocsOnTrack", wireType)
			}
			m.MinimumLocsOnTrack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumLocsOnTrack |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockGroupRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockGroupRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockGroupRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Edge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Junction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Junction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Junction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockRef{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Switch == nil {
				m.Switch = &Switch{}
			}
			if err := m.Switch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunctionRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunctionRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunctionRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Switch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFeedback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFeedback = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedbackAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedbackAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchDuration", wireType)
			}
			m.SwitchDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchDuration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Invert = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertFeedback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertFeedback = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialDirection", wireType)
			}
			m.InitialDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialDirection |= SwitchDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeft = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinaryOutput == nil {
				m.BinaryOutput = &BinaryOutput{}
			}
			if err := m.BinaryOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= BinaryOutputType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InactiveText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Endpoint{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Endpoint{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossingJunctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossingJunctions = append(m.CrossingJunctions, &JunctionWithState{})
			if err := m.CrossingJunctions[len(m.CrossingJunctions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &OutputWithState{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &RouteEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChooseProbability", wireType)
			}
			m.ChooseProbability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChooseProbability |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Closed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Closed = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			m.MaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDuration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockRef{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Edge == nil {
				m.Edge = &EdgeRef{}
			}
			if err := m.Edge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSide", wireType)
			}
			m.BlockSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSide |= BlockSide(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunctionWithState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunctionWithState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunctionWithState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Junction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Junction == nil {
				m.Junction = &JunctionRef{}
			}
			if err := m.Junction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwitchState == nil {
				m.SwitchState = &SwitchWithState{}
			}
			if err := m.SwitchState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWithState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWithState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWithState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= SwitchDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputWithState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputWithState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputWithState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &OutputRef{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOutputState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinaryOutputState == nil {
				m.BinaryOutputState = &BinaryOutputWithState{}
			}
			if err := m.BinaryOutputState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOutputWithState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOutputWithState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOutputWithState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sensor == nil {
				m.Sensor = &SensorRef{}
			}
			if err := m.Sensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Behaviors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Behaviors = append(m.Behaviors, &RouteEventBehavior{})
			if err := m.Behaviors[len(m.Behaviors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteEventBehavior) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteEventBehavior: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteEventBehavior: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliesTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppliesTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateBehavior", wireType)
			}
			m.StateBehavior = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StateBehavior |= RouteStateBehavior(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedBehavior", wireType)
			}
			m.SpeedBehavior = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedBehavior |= LocSpeedBehavior(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockRef{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			m.Shape = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shape |= Shape(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinarySensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinarySensor == nil {
				m.BinarySensor = &BinarySensor{}
			}
			if err := m.BinarySensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinarySensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinarySensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinarySensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSignal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockSignal == nil {
				m.BlockSignal = &BlockSignal{}
			}
			if err := m.BlockSignal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSignal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSignal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSignal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address3", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address3 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRedAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRedAvailable = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPattern", wireType)
			}
			m.RedPattern = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedPattern |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGreenAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGreenAvailable = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GreenPattern", wireType)
			}
			m.GreenPattern = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GreenPattern |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsYellowAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsYellowAvailable = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YellowPattern", wireType)
			}
			m.YellowPattern = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YellowPattern |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWhiteAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWhiteAvailable = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhitePattern", wireType)
			}
			m.WhitePattern = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhitePattern |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockRef{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSide", wireType)
			}
			m.BlockSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSide |= BlockSide(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BlockSignalType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignalRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignalRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignalRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrModelTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBrModelTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBrModelTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBrModelTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBrModelTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrModelTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBrModelTypes = fmt.Errorf("proto: unexpected end of group")
)
