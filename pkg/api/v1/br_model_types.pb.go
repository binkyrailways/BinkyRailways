// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: br_model_types.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// AddressType is a strongly typed type of address
type AddressType int32

const (
	AddressType_BINKYNET AddressType = 0
	AddressType_DCC      AddressType = 1
	AddressType_LOCONET  AddressType = 2
	AddressType_MOTOROLA AddressType = 3
	AddressType_MFX      AddressType = 4
	AddressType_MQTT     AddressType = 5
)

var AddressType_name = map[int32]string{
	0: "BINKYNET",
	1: "DCC",
	2: "LOCONET",
	3: "MOTOROLA",
	4: "MFX",
	5: "MQTT",
}

var AddressType_value = map[string]int32{
	"BINKYNET": 0,
	"DCC":      1,
	"LOCONET":  2,
	"MOTOROLA": 3,
	"MFX":      4,
	"MQTT":     5,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}

func (AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{0}
}

// ChangeDirection specifies if it is allowed / should be avoided to change
// direction in a block, or is it allowed / should is be avoided that a loc
// changes direction?
type ChangeDirection int32

const (
	// ALLOW indicates that changing direction is allowed
	ChangeDirection_ALLOW ChangeDirection = 0
	// AVOID indicates that changing direction should be avoided
	ChangeDirection_AVOID ChangeDirection = 1
)

var ChangeDirection_name = map[int32]string{
	0: "ALLOW",
	1: "AVOID",
}

var ChangeDirection_value = map[string]int32{
	"ALLOW": 0,
	"AVOID": 1,
}

func (x ChangeDirection) String() string {
	return proto.EnumName(ChangeDirection_name, int32(x))
}

func (ChangeDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{1}
}

// Empty message
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// Railway contrains a description of a single model railway.
type Railway struct {
	// Unique ID of the railway
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable description of the railway
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Does the railway have unsaved changed?
	Dirty bool `protobuf:"varint,3,opt,name=dirty,proto3" json:"dirty,omitempty"`
	// Modules visible on this railway
	Modules []*ModuleRef `protobuf:"bytes,100,rep,name=modules,proto3" json:"modules,omitempty"`
	// Locs visible on this railway
	Locs                 []*LocRef `protobuf:"bytes,101,rep,name=locs,proto3" json:"locs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Railway) Reset()         { *m = Railway{} }
func (m *Railway) String() string { return proto.CompactTextString(m) }
func (*Railway) ProtoMessage()    {}
func (*Railway) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{1}
}
func (m *Railway) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Railway) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Railway.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Railway) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Railway.Merge(m, src)
}
func (m *Railway) XXX_Size() int {
	return m.Size()
}
func (m *Railway) XXX_DiscardUnknown() {
	xxx_messageInfo_Railway.DiscardUnknown(m)
}

var xxx_messageInfo_Railway proto.InternalMessageInfo

func (m *Railway) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Railway) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Railway) GetDirty() bool {
	if m != nil {
		return m.Dirty
	}
	return false
}

func (m *Railway) GetModules() []*ModuleRef {
	if m != nil {
		return m.Modules
	}
	return nil
}

func (m *Railway) GetLocs() []*LocRef {
	if m != nil {
		return m.Locs
	}
	return nil
}

// Module of a railway
type Module struct {
	// Unique ID of the module
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable description of the module
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Module) Reset()         { *m = Module{} }
func (m *Module) String() string { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()    {}
func (*Module) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{2}
}
func (m *Module) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Module) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Module.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Module) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Module.Merge(m, src)
}
func (m *Module) XXX_Size() int {
	return m.Size()
}
func (m *Module) XXX_DiscardUnknown() {
	xxx_messageInfo_Module.DiscardUnknown(m)
}

var xxx_messageInfo_Module proto.InternalMessageInfo

func (m *Module) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Module) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Reference to a module
type ModuleRef struct {
	// ID of the module
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Position of the module
	Position *Position `protobuf:"bytes,2,opt,name=position,proto3" json:"position,omitempty"`
	// Zoom factor of the module (100 == 100%)
	ZoomFactor int32 `protobuf:"varint,3,opt,name=zoom_factor,json=zoomFactor,proto3" json:"zoom_factor,omitempty"`
	// If locked, the module cannot be moved.
	Locked               bool     `protobuf:"varint,4,opt,name=locked,proto3" json:"locked,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModuleRef) Reset()         { *m = ModuleRef{} }
func (m *ModuleRef) String() string { return proto.CompactTextString(m) }
func (*ModuleRef) ProtoMessage()    {}
func (*ModuleRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{3}
}
func (m *ModuleRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleRef.Merge(m, src)
}
func (m *ModuleRef) XXX_Size() int {
	return m.Size()
}
func (m *ModuleRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleRef.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleRef proto.InternalMessageInfo

func (m *ModuleRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModuleRef) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *ModuleRef) GetZoomFactor() int32 {
	if m != nil {
		return m.ZoomFactor
	}
	return 0
}

func (m *ModuleRef) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

// Visual position on a grid
type Position struct {
	// Horizontal offset from left of the screen (in pixels).
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	// Vertical offset from top of the screen (in pixels).
	Y int32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	// Horizontal size (in pixels).
	Width int32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	// Vertical size (in pixels).
	Height int32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	// Rotation in degrees.
	Rotation int32 `protobuf:"varint,5,opt,name=rotation,proto3" json:"rotation,omitempty"`
	// Optional layer.
	Layer                string   `protobuf:"bytes,6,opt,name=layer,proto3" json:"layer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{4}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Position) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Position) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Position) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Position) GetRotation() int32 {
	if m != nil {
		return m.Rotation
	}
	return 0
}

func (m *Position) GetLayer() string {
	if m != nil {
		return m.Layer
	}
	return ""
}

type Address struct {
	// Type of address
	Type AddressType `protobuf:"varint,1,opt,name=type,proto3,enum=binkyrailways.v1.AddressType" json:"type,omitempty"`
	// Address space
	Space string `protobuf:"bytes,2,opt,name=space,proto3" json:"space,omitempty"`
	// Address value
	Value                string   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{5}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetType() AddressType {
	if m != nil {
		return m.Type
	}
	return AddressType_BINKYNET
}

func (m *Address) GetSpace() string {
	if m != nil {
		return m.Space
	}
	return ""
}

func (m *Address) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Information of a locomotive
type Loc struct {
	// Unique ID of the loc
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the loc
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Name of the person that owns this loc.
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// Remarks (free text) about this loc.
	Remarks string `protobuf:"bytes,4,opt,name=remarks,proto3" json:"remarks,omitempty"`
	// Address of the loc.
	Address *Address `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	// Percentage of speed steps for the slowest speed of this loc.
	// Value between 1 and 100.
	SlowSpeed int32 `protobuf:"varint,100,opt,name=slow_speed,json=slowSpeed,proto3" json:"slow_speed,omitempty"`
	// Percentage of speed steps for the medium speed of this loc.
	// Value between 1 and 100.
	MediumSpeed int32 `protobuf:"varint,101,opt,name=medium_speed,json=mediumSpeed,proto3" json:"medium_speed,omitempty"`
	// Percentage of speed steps for the maximum speed of this loc.
	// Value between 1 and 100.
	MaximumSpeed int32 `protobuf:"varint,102,opt,name=maximum_speed,json=maximumSpeed,proto3" json:"maximum_speed,omitempty"`
	// Number of speed steps supported by this loc.
	SpeedSteps int32 `protobuf:"varint,110,opt,name=speed_steps,json=speedSteps,proto3" json:"speed_steps,omitempty"`
	// Is it allowed for this loc to change direction?
	ChangeDirection      ChangeDirection `protobuf:"varint,120,opt,name=change_direction,json=changeDirection,proto3,enum=binkyrailways.v1.ChangeDirection" json:"change_direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Loc) Reset()         { *m = Loc{} }
func (m *Loc) String() string { return proto.CompactTextString(m) }
func (*Loc) ProtoMessage()    {}
func (*Loc) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{6}
}
func (m *Loc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Loc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Loc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Loc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Loc.Merge(m, src)
}
func (m *Loc) XXX_Size() int {
	return m.Size()
}
func (m *Loc) XXX_DiscardUnknown() {
	xxx_messageInfo_Loc.DiscardUnknown(m)
}

var xxx_messageInfo_Loc proto.InternalMessageInfo

func (m *Loc) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Loc) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Loc) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Loc) GetRemarks() string {
	if m != nil {
		return m.Remarks
	}
	return ""
}

func (m *Loc) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Loc) GetSlowSpeed() int32 {
	if m != nil {
		return m.SlowSpeed
	}
	return 0
}

func (m *Loc) GetMediumSpeed() int32 {
	if m != nil {
		return m.MediumSpeed
	}
	return 0
}

func (m *Loc) GetMaximumSpeed() int32 {
	if m != nil {
		return m.MaximumSpeed
	}
	return 0
}

func (m *Loc) GetSpeedSteps() int32 {
	if m != nil {
		return m.SpeedSteps
	}
	return 0
}

func (m *Loc) GetChangeDirection() ChangeDirection {
	if m != nil {
		return m.ChangeDirection
	}
	return ChangeDirection_ALLOW
}

// Reference to a loc
type LocRef struct {
	// ID of the loc
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocRef) Reset()         { *m = LocRef{} }
func (m *LocRef) String() string { return proto.CompactTextString(m) }
func (*LocRef) ProtoMessage()    {}
func (*LocRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{7}
}
func (m *LocRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocRef.Merge(m, src)
}
func (m *LocRef) XXX_Size() int {
	return m.Size()
}
func (m *LocRef) XXX_DiscardUnknown() {
	xxx_messageInfo_LocRef.DiscardUnknown(m)
}

var xxx_messageInfo_LocRef proto.InternalMessageInfo

func (m *LocRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterEnum("binkyrailways.v1.AddressType", AddressType_name, AddressType_value)
	proto.RegisterEnum("binkyrailways.v1.ChangeDirection", ChangeDirection_name, ChangeDirection_value)
	proto.RegisterType((*Empty)(nil), "binkyrailways.v1.Empty")
	proto.RegisterType((*Railway)(nil), "binkyrailways.v1.Railway")
	proto.RegisterType((*Module)(nil), "binkyrailways.v1.Module")
	proto.RegisterType((*ModuleRef)(nil), "binkyrailways.v1.ModuleRef")
	proto.RegisterType((*Position)(nil), "binkyrailways.v1.Position")
	proto.RegisterType((*Address)(nil), "binkyrailways.v1.Address")
	proto.RegisterType((*Loc)(nil), "binkyrailways.v1.Loc")
	proto.RegisterType((*LocRef)(nil), "binkyrailways.v1.LocRef")
}

func init() { proto.RegisterFile("br_model_types.proto", fileDescriptor_054508b9601a8429) }

var fileDescriptor_054508b9601a8429 = []byte{
	// 678 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xcf, 0x6e, 0xda, 0x4a,
	0x14, 0xc6, 0x63, 0xc0, 0x18, 0x8e, 0xb9, 0x89, 0x35, 0x8a, 0xae, 0x7c, 0x73, 0x15, 0x42, 0xdc,
	0x45, 0xa3, 0xa8, 0x02, 0x41, 0xd4, 0x2e, 0xba, 0x4b, 0x48, 0x22, 0x45, 0x85, 0xd0, 0x4e, 0x50,
	0xff, 0x6d, 0x90, 0xb1, 0x27, 0x30, 0xc2, 0x66, 0x2c, 0xdb, 0x04, 0xdc, 0x07, 0xe8, 0xaa, 0x0f,
	0xd0, 0x27, 0xe9, 0x33, 0x74, 0xd9, 0x47, 0xa8, 0xd2, 0x37, 0xe8, 0x13, 0x54, 0x73, 0x6c, 0x50,
	0x12, 0xd4, 0x45, 0xbb, 0xcb, 0xf7, 0xcd, 0x6f, 0x8e, 0xbe, 0xf3, 0x79, 0x02, 0x6c, 0x0f, 0xc3,
	0x81, 0x2f, 0x5c, 0xe6, 0x0d, 0xe2, 0x24, 0x60, 0x51, 0x3d, 0x08, 0x45, 0x2c, 0x88, 0x31, 0xe4,
	0xd3, 0x49, 0x12, 0xda, 0xdc, 0x9b, 0xdb, 0x49, 0x54, 0xbf, 0x69, 0x5a, 0x1a, 0xa8, 0x67, 0x7e,
	0x10, 0x27, 0xd6, 0x17, 0x05, 0x34, 0x9a, 0x1e, 0x90, 0x4d, 0xc8, 0x71, 0xd7, 0x54, 0x6a, 0xca,
	0x41, 0x99, 0xe6, 0xb8, 0x4b, 0x6a, 0xa0, 0xbb, 0x2c, 0x72, 0x42, 0x1e, 0xc4, 0x5c, 0x4c, 0xcd,
	0x1c, 0x1e, 0xdc, 0xb5, 0xc8, 0x36, 0xa8, 0x2e, 0x0f, 0xe3, 0xc4, 0xcc, 0xd7, 0x94, 0x83, 0x12,
	0x4d, 0x05, 0x79, 0x0a, 0x9a, 0x2f, 0xdc, 0x99, 0xc7, 0x22, 0xd3, 0xad, 0xe5, 0x0f, 0xf4, 0xd6,
	0xff, 0xf5, 0x87, 0x01, 0xea, 0x5d, 0x04, 0x28, 0xbb, 0xa6, 0x4b, 0x96, 0x3c, 0x81, 0x82, 0x27,
	0x9c, 0xc8, 0x64, 0x78, 0xc7, 0x5c, 0xbf, 0xd3, 0x11, 0x8e, 0xbc, 0x80, 0x94, 0xf5, 0x1c, 0x8a,
	0xe9, 0x8c, 0x3f, 0x8f, 0x6d, 0x7d, 0x52, 0xa0, 0xbc, 0x0a, 0xb0, 0x76, 0xff, 0x19, 0x94, 0x02,
	0x11, 0xf1, 0xd5, 0x65, 0xbd, 0xb5, 0xb3, 0x9e, 0xe5, 0x65, 0x46, 0xd0, 0x15, 0x4b, 0xf6, 0x40,
	0xff, 0x20, 0x84, 0x3f, 0xb8, 0xb6, 0x9d, 0x58, 0x84, 0x58, 0x89, 0x4a, 0x41, 0x5a, 0xe7, 0xe8,
	0x90, 0x7f, 0xa1, 0xe8, 0x09, 0x67, 0xc2, 0x5c, 0xb3, 0x80, 0x75, 0x65, 0xca, 0xfa, 0xa8, 0x40,
	0x69, 0x39, 0x8f, 0x54, 0x40, 0x59, 0x60, 0x18, 0x95, 0x2a, 0x0b, 0xa9, 0x12, 0x0c, 0xa1, 0x52,
	0x25, 0x91, 0x75, 0xcf, 0xb9, 0x1b, 0x8f, 0xb3, 0xd9, 0xa9, 0x90, 0x63, 0xc7, 0x8c, 0x8f, 0xc6,
	0x31, 0x8e, 0x55, 0x69, 0xa6, 0xc8, 0x0e, 0x94, 0x42, 0x11, 0xdb, 0xb8, 0x87, 0x8a, 0x27, 0x2b,
	0x2d, 0x27, 0x79, 0x76, 0xc2, 0x42, 0xb3, 0x88, 0x6b, 0xa7, 0xc2, 0x1a, 0x83, 0x76, 0xec, 0xba,
	0x21, 0x8b, 0x22, 0xd2, 0x84, 0x82, 0x7c, 0x41, 0x98, 0x64, 0xb3, 0xb5, 0xbb, 0x5e, 0x40, 0x06,
	0xf6, 0x93, 0x80, 0x51, 0x44, 0xe5, 0xcc, 0x28, 0xb0, 0x1d, 0x96, 0x35, 0x9e, 0x0a, 0xe9, 0xde,
	0xd8, 0xde, 0x8c, 0x61, 0xe6, 0x32, 0x4d, 0x85, 0xf5, 0x33, 0x07, 0xf9, 0x8e, 0x70, 0xfe, 0xee,
	0xc9, 0x89, 0xf9, 0x94, 0x85, 0xcb, 0x79, 0x28, 0x88, 0x09, 0x5a, 0xc8, 0x7c, 0x3b, 0x9c, 0x44,
	0x58, 0x42, 0x99, 0x2e, 0x25, 0x39, 0x02, 0xcd, 0x4e, 0xa3, 0x62, 0x09, 0x7a, 0xeb, 0xbf, 0xdf,
	0xee, 0x42, 0x97, 0x24, 0xd9, 0x05, 0x88, 0x3c, 0x31, 0x1f, 0x44, 0x01, 0x63, 0xae, 0xe9, 0x62,
	0x79, 0x65, 0xe9, 0x5c, 0x49, 0x83, 0xec, 0x43, 0xc5, 0x67, 0x2e, 0x9f, 0xf9, 0x19, 0xc0, 0x10,
	0xd0, 0x53, 0x2f, 0x45, 0x1e, 0xc1, 0x3f, 0xbe, 0xbd, 0xe0, 0xfe, 0x8a, 0xb9, 0x46, 0xa6, 0x92,
	0x99, 0x29, 0xb4, 0x07, 0x3a, 0x1e, 0x0e, 0xa2, 0x98, 0x05, 0x91, 0x39, 0x4d, 0x5f, 0x0c, 0x5a,
	0x57, 0xd2, 0x21, 0x1d, 0x30, 0x9c, 0xb1, 0x3d, 0x1d, 0xb1, 0x81, 0xcb, 0x43, 0xe6, 0x60, 0x27,
	0x0b, 0xfc, 0x22, 0xfb, 0xeb, 0x5b, 0xb4, 0x91, 0x3c, 0x5d, 0x82, 0x74, 0xcb, 0xb9, 0x6f, 0x58,
	0x26, 0x14, 0xd3, 0x7f, 0xa1, 0x87, 0xb5, 0x1f, 0x52, 0xd0, 0xef, 0x7c, 0x4f, 0x52, 0x81, 0xd2,
	0xc9, 0xc5, 0xe5, 0x8b, 0x77, 0x97, 0x67, 0x7d, 0x63, 0x83, 0x68, 0x90, 0x3f, 0x6d, 0xb7, 0x0d,
	0x85, 0xe8, 0xa0, 0x75, 0x7a, 0xed, 0x9e, 0x74, 0x73, 0x92, 0xe9, 0xf6, 0xfa, 0x3d, 0xda, 0xeb,
	0x1c, 0x1b, 0x79, 0xc9, 0x74, 0xcf, 0xdf, 0x1a, 0x05, 0x52, 0x82, 0x42, 0xf7, 0x55, 0xbf, 0x6f,
	0xa8, 0x87, 0x8f, 0x61, 0xeb, 0x41, 0x22, 0x52, 0x06, 0xf5, 0xb8, 0xd3, 0xe9, 0xbd, 0x31, 0x36,
	0xf0, 0xcf, 0xd7, 0xbd, 0x8b, 0x53, 0x43, 0x39, 0x69, 0x7f, 0xbd, 0xad, 0x2a, 0xdf, 0x6e, 0xab,
	0xca, 0xf7, 0xdb, 0xaa, 0xf2, 0xf9, 0x47, 0x75, 0xe3, 0x7d, 0x73, 0xc4, 0xe3, 0xf1, 0x6c, 0x58,
	0x77, 0x84, 0xdf, 0xb8, 0xb7, 0x66, 0xe3, 0x44, 0x2a, 0xba, 0x54, 0xc1, 0x64, 0xd4, 0xb0, 0x03,
	0xde, 0xb8, 0x69, 0x0e, 0x8b, 0xf8, 0x4b, 0x77, 0xf4, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x8c, 0x3b,
	0x7e, 0x2d, 0x01, 0x05, 0x00, 0x00,
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Railway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Railway) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Railway) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Locs) > 0 {
		for iNdEx := len(m.Locs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Modules) > 0 {
		for iNdEx := len(m.Modules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Modules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Dirty {
		i--
		if m.Dirty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Module) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Module) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Module) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModuleRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ZoomFactor != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ZoomFactor))
		i--
		dAtA[i] = 0x18
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Layer) > 0 {
		i -= len(m.Layer)
		copy(dAtA[i:], m.Layer)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Layer)))
		i--
		dAtA[i] = 0x32
	}
	if m.Rotation != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Rotation))
		i--
		dAtA[i] = 0x28
	}
	if m.Height != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if m.Width != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Space) > 0 {
		i -= len(m.Space)
		copy(dAtA[i:], m.Space)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Space)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Loc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Loc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Loc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangeDirection != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ChangeDirection))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.SpeedSteps != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SpeedSteps))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if m.MaximumSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MaximumSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.MediumSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MediumSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.SlowSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SlowSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Remarks) > 0 {
		i -= len(m.Remarks)
		copy(dAtA[i:], m.Remarks)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Remarks)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBrModelTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovBrModelTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Railway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Dirty {
		n += 2
	}
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Locs) > 0 {
		for _, e := range m.Locs {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Module) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModuleRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.ZoomFactor != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ZoomFactor))
	}
	if m.Locked {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovBrModelTypes(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Y))
	}
	if m.Width != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Height))
	}
	if m.Rotation != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Rotation))
	}
	l = len(m.Layer)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Type))
	}
	l = len(m.Space)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Loc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Remarks)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.SlowSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.SlowSpeed))
	}
	if m.MediumSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.MediumSpeed))
	}
	if m.MaximumSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.MaximumSpeed))
	}
	if m.SpeedSteps != 0 {
		n += 2 + sovBrModelTypes(uint64(m.SpeedSteps))
	}
	if m.ChangeDirection != 0 {
		n += 2 + sovBrModelTypes(uint64(m.ChangeDirection))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBrModelTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBrModelTypes(x uint64) (n int) {
	return sovBrModelTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Railway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Railway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Railway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dirty = bool(v != 0)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modules = append(m.Modules, &ModuleRef{})
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locs = append(m.Locs, &LocRef{})
			if err := m.Locs[len(m.Locs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Module) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Module: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Module: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoomFactor", wireType)
			}
			m.ZoomFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZoomFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			m.Rotation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AddressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Space = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Loc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Loc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Loc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remarks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remarks = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowSpeed", wireType)
			}
			m.SlowSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlowSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediumSpeed", wireType)
			}
			m.MediumSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediumSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumSpeed", wireType)
			}
			m.MaximumSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedSteps", wireType)
			}
			m.SpeedSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedSteps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDirection", wireType)
			}
			m.ChangeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeDirection |= ChangeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrModelTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBrModelTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBrModelTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBrModelTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBrModelTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrModelTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBrModelTypes = fmt.Errorf("proto: unexpected end of group")
)
