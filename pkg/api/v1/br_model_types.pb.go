// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: br_model_types.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ChangeDirection specifies if it is allowed / should be avoided to change
// direction in a block, or is it allowed / should is be avoided that a loc
// changes direction?
type ChangeDirection int32

const (
	// ALLOW indicates that changing direction is allowed
	ChangeDirection_ALLOW ChangeDirection = 0
	// AVOID indicates that changing direction should be avoided
	ChangeDirection_AVOID ChangeDirection = 1
)

var ChangeDirection_name = map[int32]string{
	0: "ALLOW",
	1: "AVOID",
}

var ChangeDirection_value = map[string]int32{
	"ALLOW": 0,
	"AVOID": 1,
}

func (x ChangeDirection) String() string {
	return proto.EnumName(ChangeDirection_name, int32(x))
}

func (ChangeDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{0}
}

type BinkyNetDeviceType int32

const (
	// DeviceTypeMCP23008 is the device type of a General Purpose I/O
	BinkyNetDeviceType_MCP23008 BinkyNetDeviceType = 0
	// DeviceTypeMCP23017 is the device type of a General Purpose I/O
	BinkyNetDeviceType_MCP23017 BinkyNetDeviceType = 1
	// DeviceTypePCA9685 is the device type of a Pulse Width Modulation device
	BinkyNetDeviceType_PCA9685 BinkyNetDeviceType = 2
	// DeviceTypePCF8574 is the device type of a General Purpose I/O
	BinkyNetDeviceType_PCF8574 BinkyNetDeviceType = 3
)

var BinkyNetDeviceType_name = map[int32]string{
	0: "MCP23008",
	1: "MCP23017",
	2: "PCA9685",
	3: "PCF8574",
}

var BinkyNetDeviceType_value = map[string]int32{
	"MCP23008": 0,
	"MCP23017": 1,
	"PCA9685":  2,
	"PCF8574":  3,
}

func (x BinkyNetDeviceType) String() string {
	return proto.EnumName(BinkyNetDeviceType_name, int32(x))
}

func (BinkyNetDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{1}
}

type BinkyNetObjectType int32

const (
	// ObjectTypeBinarySensor is the object type of a single-bit on/off sensor
	BinkyNetObjectType_BINARYSENSOR BinkyNetObjectType = 0
	// ObjectTypeBinaryOutput is the object type of a single-bit on/off output
	BinkyNetObjectType_BINARYOUTPUT BinkyNetObjectType = 1
	// ObjectTypeServoSwitch is the object type of a servo driven switch, with an
	// option phase switching relay.
	BinkyNetObjectType_SERVOSWITCH BinkyNetObjectType = 2
	// ObjectTypeRelaySwitch is the object type of a double relay driven switch,
	// with an option phase switching relay.
	BinkyNetObjectType_RELAYSWITCH BinkyNetObjectType = 3
	// ObjectTypeTrackInverter is the object type of a four relay based track
	// power inverter.
	BinkyNetObjectType_TRACKINVERTER BinkyNetObjectType = 4
)

var BinkyNetObjectType_name = map[int32]string{
	0: "BINARYSENSOR",
	1: "BINARYOUTPUT",
	2: "SERVOSWITCH",
	3: "RELAYSWITCH",
	4: "TRACKINVERTER",
}

var BinkyNetObjectType_value = map[string]int32{
	"BINARYSENSOR":  0,
	"BINARYOUTPUT":  1,
	"SERVOSWITCH":   2,
	"RELAYSWITCH":   3,
	"TRACKINVERTER": 4,
}

func (x BinkyNetObjectType) String() string {
	return proto.EnumName(BinkyNetObjectType_name, int32(x))
}

func (BinkyNetObjectType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{2}
}

type SwitchDirection int32

const (
	// STRAIGHT indicates the switch in its straight position
	SwitchDirection_STRAIGHT SwitchDirection = 0
	// OFF indicates the switch in its off position
	SwitchDirection_OFF SwitchDirection = 1
)

var SwitchDirection_name = map[int32]string{
	0: "STRAIGHT",
	1: "OFF",
}

var SwitchDirection_value = map[string]int32{
	"STRAIGHT": 0,
	"OFF":      1,
}

func (x SwitchDirection) String() string {
	return proto.EnumName(SwitchDirection_name, int32(x))
}

func (SwitchDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{3}
}

type BinaryOutputType int32

const (
	// DEFAULT indicates a standard on/off switch
	BinaryOutputType_BOT_DEFAULT BinaryOutputType = 0
	// TRACKINVERTER indicates a digital track inverter
	BinaryOutputType_BOT_TRACKINVERTER BinaryOutputType = 1
)

var BinaryOutputType_name = map[int32]string{
	0: "BOT_DEFAULT",
	1: "BOT_TRACKINVERTER",
}

var BinaryOutputType_value = map[string]int32{
	"BOT_DEFAULT":       0,
	"BOT_TRACKINVERTER": 1,
}

func (x BinaryOutputType) String() string {
	return proto.EnumName(BinaryOutputType_name, int32(x))
}

func (BinaryOutputType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{4}
}

// Side of a block
type BlockSide int32

const (
	// FRONT indicates the end of normal driving direction
	BlockSide_FRONT BlockSide = 0
	// BACK indicates the begining of normal driving direction
	BlockSide_BACK BlockSide = 1
)

var BlockSide_name = map[int32]string{
	0: "FRONT",
	1: "BACK",
}

var BlockSide_value = map[string]int32{
	"FRONT": 0,
	"BACK":  1,
}

func (x BlockSide) String() string {
	return proto.EnumName(BlockSide_name, int32(x))
}

func (BlockSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{5}
}

type RouteStateBehavior int32

const (
	// NOCHANGE indicates that the state does not change
	RouteStateBehavior_RSB_NOCHANGE RouteStateBehavior = 0
	// ENTER indicates that the loc has entered the To block.
	RouteStateBehavior_RSB_ENTER RouteStateBehavior = 1
	// REACHED indicates that the loc has reached the To block.
	RouteStateBehavior_RSB_REACHED RouteStateBehavior = 2
)

var RouteStateBehavior_name = map[int32]string{
	0: "RSB_NOCHANGE",
	1: "RSB_ENTER",
	2: "RSB_REACHED",
}

var RouteStateBehavior_value = map[string]int32{
	"RSB_NOCHANGE": 0,
	"RSB_ENTER":    1,
	"RSB_REACHED":  2,
}

func (x RouteStateBehavior) String() string {
	return proto.EnumName(RouteStateBehavior_name, int32(x))
}

func (RouteStateBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{6}
}

type LocSpeedBehavior int32

const (
	// LocSpeedBehaviorDefault indicates the speed change is controlled by state
	// behavior
	LocSpeedBehavior_LSB_DEFAULT LocSpeedBehavior = 0
	// LocSpeedBehaviorNoChange indicates no change in speed
	LocSpeedBehavior_LSB_NOCHANGE LocSpeedBehavior = 1
	// LocSpeedBehaviorMedium indicates that the speed is set to medium speed.
	LocSpeedBehavior_LSB_MEDIUM LocSpeedBehavior = 2
	// LocSpeedBehaviorMinimum indicates that the speed is set to minimum speed.
	LocSpeedBehavior_LSB_MINIMUM LocSpeedBehavior = 3
	// LocSpeedBehaviorMaximum indicates that the speed is set to maximum speed.
	LocSpeedBehavior_LSB_MAXIMUM LocSpeedBehavior = 4
)

var LocSpeedBehavior_name = map[int32]string{
	0: "LSB_DEFAULT",
	1: "LSB_NOCHANGE",
	2: "LSB_MEDIUM",
	3: "LSB_MINIMUM",
	4: "LSB_MAXIMUM",
}

var LocSpeedBehavior_value = map[string]int32{
	"LSB_DEFAULT":  0,
	"LSB_NOCHANGE": 1,
	"LSB_MEDIUM":   2,
	"LSB_MINIMUM":  3,
	"LSB_MAXIMUM":  4,
}

func (x LocSpeedBehavior) String() string {
	return proto.EnumName(LocSpeedBehavior_name, int32(x))
}

func (LocSpeedBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{7}
}

type Shape int32

const (
	// Circle
	Shape_CIRCLE Shape = 0
	// Triangle
	Shape_TRIANGLE Shape = 1
	// Square
	Shape_SQUARE Shape = 2
	// Diamond
	Shape_DIAMOND Shape = 3
)

var Shape_name = map[int32]string{
	0: "CIRCLE",
	1: "TRIANGLE",
	2: "SQUARE",
	3: "DIAMOND",
}

var Shape_value = map[string]int32{
	"CIRCLE":   0,
	"TRIANGLE": 1,
	"SQUARE":   2,
	"DIAMOND":  3,
}

func (x Shape) String() string {
	return proto.EnumName(Shape_name, int32(x))
}

func (Shape) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{8}
}

// Empty message
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// Raw image content
type Image struct {
	// Base64 encoded image data
	ContentBase64        string   `protobuf:"bytes,1,opt,name=content_base64,json=contentBase64,proto3" json:"content_base64,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Image) Reset()         { *m = Image{} }
func (m *Image) String() string { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()    {}
func (*Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{1}
}
func (m *Image) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Image.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Image.Merge(m, src)
}
func (m *Image) XXX_Size() int {
	return m.Size()
}
func (m *Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Image proto.InternalMessageInfo

func (m *Image) GetContentBase64() string {
	if m != nil {
		return m.ContentBase64
	}
	return ""
}

// Railway contrains a description of a single model railway.
type Railway struct {
	// Unique ID of the railway
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable description of the railway
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Does the railway have unsaved changed?
	Dirty bool `protobuf:"varint,3,opt,name=dirty,proto3" json:"dirty,omitempty"`
	// Modules visible on this railway
	Modules []*ModuleRef `protobuf:"bytes,100,rep,name=modules,proto3" json:"modules,omitempty"`
	// Locs visible on this railway
	Locs []*LocRef `protobuf:"bytes,101,rep,name=locs,proto3" json:"locs,omitempty"`
	// Loc groups visible on this railway
	LocGroups []*LocGroupRef `protobuf:"bytes,102,rep,name=locGroups,proto3" json:"locGroups,omitempty"`
	// Command stations visible on this railway;
	CommandStations      []*CommandStationRef `protobuf:"bytes,103,rep,name=commandStations,proto3" json:"commandStations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Railway) Reset()         { *m = Railway{} }
func (m *Railway) String() string { return proto.CompactTextString(m) }
func (*Railway) ProtoMessage()    {}
func (*Railway) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{2}
}
func (m *Railway) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Railway) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Railway.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Railway) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Railway.Merge(m, src)
}
func (m *Railway) XXX_Size() int {
	return m.Size()
}
func (m *Railway) XXX_DiscardUnknown() {
	xxx_messageInfo_Railway.DiscardUnknown(m)
}

var xxx_messageInfo_Railway proto.InternalMessageInfo

func (m *Railway) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Railway) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Railway) GetDirty() bool {
	if m != nil {
		return m.Dirty
	}
	return false
}

func (m *Railway) GetModules() []*ModuleRef {
	if m != nil {
		return m.Modules
	}
	return nil
}

func (m *Railway) GetLocs() []*LocRef {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *Railway) GetLocGroups() []*LocGroupRef {
	if m != nil {
		return m.LocGroups
	}
	return nil
}

func (m *Railway) GetCommandStations() []*CommandStationRef {
	if m != nil {
		return m.CommandStations
	}
	return nil
}

// Module of a railway
type Module struct {
	// Unique ID of the module
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable description of the module
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Horizontal size (in pixels).
	Width int32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	// Vertical size (in pixels).
	Height int32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	// Does this module have a background image
	HasBackgroundImage bool `protobuf:"varint,5,opt,name=has_background_image,json=hasBackgroundImage,proto3" json:"has_background_image,omitempty"`
	// Blocks of this module
	Blocks []*BlockRef `protobuf:"bytes,100,rep,name=blocks,proto3" json:"blocks,omitempty"`
	// Blocks of this module
	BlockGroups []*BlockGroupRef `protobuf:"bytes,101,rep,name=blockGroups,proto3" json:"blockGroups,omitempty"`
	// Edges of this module
	Edges []*EdgeRef `protobuf:"bytes,102,rep,name=edges,proto3" json:"edges,omitempty"`
	// Junctions of this module
	Junctions []*JunctionRef `protobuf:"bytes,103,rep,name=junctions,proto3" json:"junctions,omitempty"`
	// Outputs of this module
	Outputs []*OutputRef `protobuf:"bytes,104,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// Routes of this module
	Routes []*RouteRef `protobuf:"bytes,105,rep,name=routes,proto3" json:"routes,omitempty"`
	// Sensors of this module
	Sensors []*SensorRef `protobuf:"bytes,106,rep,name=sensors,proto3" json:"sensors,omitempty"`
	// Signals of this module
	Signals              []*SignalRef `protobuf:"bytes,107,rep,name=signals,proto3" json:"signals,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Module) Reset()         { *m = Module{} }
func (m *Module) String() string { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()    {}
func (*Module) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{3}
}
func (m *Module) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Module) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Module.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Module) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Module.Merge(m, src)
}
func (m *Module) XXX_Size() int {
	return m.Size()
}
func (m *Module) XXX_DiscardUnknown() {
	xxx_messageInfo_Module.DiscardUnknown(m)
}

var xxx_messageInfo_Module proto.InternalMessageInfo

func (m *Module) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Module) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Module) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Module) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Module) GetHasBackgroundImage() bool {
	if m != nil {
		return m.HasBackgroundImage
	}
	return false
}

func (m *Module) GetBlocks() []*BlockRef {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *Module) GetBlockGroups() []*BlockGroupRef {
	if m != nil {
		return m.BlockGroups
	}
	return nil
}

func (m *Module) GetEdges() []*EdgeRef {
	if m != nil {
		return m.Edges
	}
	return nil
}

func (m *Module) GetJunctions() []*JunctionRef {
	if m != nil {
		return m.Junctions
	}
	return nil
}

func (m *Module) GetOutputs() []*OutputRef {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Module) GetRoutes() []*RouteRef {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *Module) GetSensors() []*SensorRef {
	if m != nil {
		return m.Sensors
	}
	return nil
}

func (m *Module) GetSignals() []*SignalRef {
	if m != nil {
		return m.Signals
	}
	return nil
}

// Reference to a module
type ModuleRef struct {
	// ID of the module
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Position of the module
	Position *Position `protobuf:"bytes,2,opt,name=position,proto3" json:"position,omitempty"`
	// Zoom factor of the module (100 == 100%)
	ZoomFactor int32 `protobuf:"varint,3,opt,name=zoom_factor,json=zoomFactor,proto3" json:"zoom_factor,omitempty"`
	// If locked, the module cannot be moved.
	Locked               bool     `protobuf:"varint,4,opt,name=locked,proto3" json:"locked,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModuleRef) Reset()         { *m = ModuleRef{} }
func (m *ModuleRef) String() string { return proto.CompactTextString(m) }
func (*ModuleRef) ProtoMessage()    {}
func (*ModuleRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{4}
}
func (m *ModuleRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleRef.Merge(m, src)
}
func (m *ModuleRef) XXX_Size() int {
	return m.Size()
}
func (m *ModuleRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleRef.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleRef proto.InternalMessageInfo

func (m *ModuleRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModuleRef) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *ModuleRef) GetZoomFactor() int32 {
	if m != nil {
		return m.ZoomFactor
	}
	return 0
}

func (m *ModuleRef) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

// Visual position on a grid
type Position struct {
	// Horizontal offset from left of the screen (in pixels).
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	// Vertical offset from top of the screen (in pixels).
	Y int32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	// Horizontal size (in pixels).
	Width int32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	// Vertical size (in pixels).
	Height int32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	// Rotation in degrees.
	Rotation int32 `protobuf:"varint,5,opt,name=rotation,proto3" json:"rotation,omitempty"`
	// Optional layer.
	Layer                string   `protobuf:"bytes,6,opt,name=layer,proto3" json:"layer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{5}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Position) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Position) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Position) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Position) GetRotation() int32 {
	if m != nil {
		return m.Rotation
	}
	return 0
}

func (m *Position) GetLayer() string {
	if m != nil {
		return m.Layer
	}
	return ""
}

// Information of a locomotive
type Loc struct {
	// Unique ID of the loc
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the loc
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Name of the person that owns this loc.
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// Remarks (free text) about this loc.
	Remarks string `protobuf:"bytes,4,opt,name=remarks,proto3" json:"remarks,omitempty"`
	// Address of the loc.
	Address string `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	// Percentage of speed steps for the slowest speed of this loc.
	// Value between 1 and 100.
	SlowSpeed int32 `protobuf:"varint,100,opt,name=slow_speed,json=slowSpeed,proto3" json:"slow_speed,omitempty"`
	// Percentage of speed steps for the medium speed of this loc.
	// Value between 1 and 100.
	MediumSpeed int32 `protobuf:"varint,101,opt,name=medium_speed,json=mediumSpeed,proto3" json:"medium_speed,omitempty"`
	// Percentage of speed steps for the maximum speed of this loc.
	// Value between 1 and 100.
	MaximumSpeed int32 `protobuf:"varint,102,opt,name=maximum_speed,json=maximumSpeed,proto3" json:"maximum_speed,omitempty"`
	// Number of speed steps supported by this loc.
	SpeedSteps int32 `protobuf:"varint,110,opt,name=speed_steps,json=speedSteps,proto3" json:"speed_steps,omitempty"`
	// Is it allowed for this loc to change direction?
	ChangeDirection      ChangeDirection `protobuf:"varint,120,opt,name=change_direction,json=changeDirection,proto3,enum=binkyrailways.v1.ChangeDirection" json:"change_direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Loc) Reset()         { *m = Loc{} }
func (m *Loc) String() string { return proto.CompactTextString(m) }
func (*Loc) ProtoMessage()    {}
func (*Loc) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{6}
}
func (m *Loc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Loc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Loc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Loc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Loc.Merge(m, src)
}
func (m *Loc) XXX_Size() int {
	return m.Size()
}
func (m *Loc) XXX_DiscardUnknown() {
	xxx_messageInfo_Loc.DiscardUnknown(m)
}

var xxx_messageInfo_Loc proto.InternalMessageInfo

func (m *Loc) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Loc) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Loc) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Loc) GetRemarks() string {
	if m != nil {
		return m.Remarks
	}
	return ""
}

func (m *Loc) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Loc) GetSlowSpeed() int32 {
	if m != nil {
		return m.SlowSpeed
	}
	return 0
}

func (m *Loc) GetMediumSpeed() int32 {
	if m != nil {
		return m.MediumSpeed
	}
	return 0
}

func (m *Loc) GetMaximumSpeed() int32 {
	if m != nil {
		return m.MaximumSpeed
	}
	return 0
}

func (m *Loc) GetSpeedSteps() int32 {
	if m != nil {
		return m.SpeedSteps
	}
	return 0
}

func (m *Loc) GetChangeDirection() ChangeDirection {
	if m != nil {
		return m.ChangeDirection
	}
	return ChangeDirection_ALLOW
}

// Reference to a loc
type LocRef struct {
	// ID of the loc
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocRef) Reset()         { *m = LocRef{} }
func (m *LocRef) String() string { return proto.CompactTextString(m) }
func (*LocRef) ProtoMessage()    {}
func (*LocRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{7}
}
func (m *LocRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocRef.Merge(m, src)
}
func (m *LocRef) XXX_Size() int {
	return m.Size()
}
func (m *LocRef) XXX_DiscardUnknown() {
	xxx_messageInfo_LocRef.DiscardUnknown(m)
}

var xxx_messageInfo_LocRef proto.InternalMessageInfo

func (m *LocRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type LocGroup struct {
	// ID of the loc group
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the loc group
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocGroup) Reset()         { *m = LocGroup{} }
func (m *LocGroup) String() string { return proto.CompactTextString(m) }
func (*LocGroup) ProtoMessage()    {}
func (*LocGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{8}
}
func (m *LocGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocGroup.Merge(m, src)
}
func (m *LocGroup) XXX_Size() int {
	return m.Size()
}
func (m *LocGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_LocGroup.DiscardUnknown(m)
}

var xxx_messageInfo_LocGroup proto.InternalMessageInfo

func (m *LocGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LocGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type LocGroupRef struct {
	// ID of the loc group
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocGroupRef) Reset()         { *m = LocGroupRef{} }
func (m *LocGroupRef) String() string { return proto.CompactTextString(m) }
func (*LocGroupRef) ProtoMessage()    {}
func (*LocGroupRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{9}
}
func (m *LocGroupRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocGroupRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocGroupRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocGroupRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocGroupRef.Merge(m, src)
}
func (m *LocGroupRef) XXX_Size() int {
	return m.Size()
}
func (m *LocGroupRef) XXX_DiscardUnknown() {
	xxx_messageInfo_LocGroupRef.DiscardUnknown(m)
}

var xxx_messageInfo_LocGroupRef proto.InternalMessageInfo

func (m *LocGroupRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type CommandStation struct {
	// ID of the command station
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the command station
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Settings of binkynet command station
	BinkynetCommandStation *BinkyNetCommandStation `protobuf:"bytes,10,opt,name=binkynet_command_station,json=binkynetCommandStation,proto3" json:"binkynet_command_station,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *CommandStation) Reset()         { *m = CommandStation{} }
func (m *CommandStation) String() string { return proto.CompactTextString(m) }
func (*CommandStation) ProtoMessage()    {}
func (*CommandStation) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{10}
}
func (m *CommandStation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandStation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStation.Merge(m, src)
}
func (m *CommandStation) XXX_Size() int {
	return m.Size()
}
func (m *CommandStation) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStation.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStation proto.InternalMessageInfo

func (m *CommandStation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CommandStation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CommandStation) GetBinkynetCommandStation() *BinkyNetCommandStation {
	if m != nil {
		return m.BinkynetCommandStation
	}
	return nil
}

type CommandStationRef struct {
	// ID of the command station
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandStationRef) Reset()         { *m = CommandStationRef{} }
func (m *CommandStationRef) String() string { return proto.CompactTextString(m) }
func (*CommandStationRef) ProtoMessage()    {}
func (*CommandStationRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{11}
}
func (m *CommandStationRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStationRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStationRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandStationRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStationRef.Merge(m, src)
}
func (m *CommandStationRef) XXX_Size() int {
	return m.Size()
}
func (m *CommandStationRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStationRef.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStationRef proto.InternalMessageInfo

func (m *CommandStationRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type BinkyNetCommandStation struct {
	// Network host address (defaults to 0.0.0.0)
	ServerHost string `protobuf:"bytes,1,opt,name=server_host,json=serverHost,proto3" json:"server_host,omitempty"`
	// Network Port of the command station
	GrpcPort int32 `protobuf:"varint,2,opt,name=grpc_port,json=grpcPort,proto3" json:"grpc_port,omitempty"`
	// The required version of local workers
	RequiredWorkerVersion string `protobuf:"bytes,3,opt,name=required_worker_version,json=requiredWorkerVersion,proto3" json:"required_worker_version,omitempty"`
	// Gets the configuration of local workers on the Binky network
	// that this command station is attached to.
	LocalWorkers         []*BinkyNetLocalWorkerRef `protobuf:"bytes,4,rep,name=local_workers,json=localWorkers,proto3" json:"local_workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *BinkyNetCommandStation) Reset()         { *m = BinkyNetCommandStation{} }
func (m *BinkyNetCommandStation) String() string { return proto.CompactTextString(m) }
func (*BinkyNetCommandStation) ProtoMessage()    {}
func (*BinkyNetCommandStation) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{12}
}
func (m *BinkyNetCommandStation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetCommandStation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetCommandStation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetCommandStation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetCommandStation.Merge(m, src)
}
func (m *BinkyNetCommandStation) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetCommandStation) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetCommandStation.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetCommandStation proto.InternalMessageInfo

func (m *BinkyNetCommandStation) GetServerHost() string {
	if m != nil {
		return m.ServerHost
	}
	return ""
}

func (m *BinkyNetCommandStation) GetGrpcPort() int32 {
	if m != nil {
		return m.GrpcPort
	}
	return 0
}

func (m *BinkyNetCommandStation) GetRequiredWorkerVersion() string {
	if m != nil {
		return m.RequiredWorkerVersion
	}
	return ""
}

func (m *BinkyNetCommandStation) GetLocalWorkers() []*BinkyNetLocalWorkerRef {
	if m != nil {
		return m.LocalWorkers
	}
	return nil
}

// Configuration of a binky local worker
type BinkyNetLocalWorker struct {
	// ID of the local worker
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the local worker
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the command station containing this worker
	CommandStationId string `protobuf:"bytes,3,opt,name=command_station_id,json=commandStationId,proto3" json:"command_station_id,omitempty"`
	// Hardware ID of the local worker.
	HardwareId string `protobuf:"bytes,4,opt,name=hardware_id,json=hardwareId,proto3" json:"hardware_id,omitempty"`
	// Optional alias for the local worker.
	Alias string `protobuf:"bytes,5,opt,name=alias,proto3" json:"alias,omitempty"`
	// Set of devices that must be configured on this local worker.
	Devices []*BinkyNetDevice `protobuf:"bytes,10,rep,name=devices,proto3" json:"devices,omitempty"`
	// Set of real world objects controlled by the local worker
	Objects              []*BinkyNetObject `protobuf:"bytes,11,rep,name=objects,proto3" json:"objects,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BinkyNetLocalWorker) Reset()         { *m = BinkyNetLocalWorker{} }
func (m *BinkyNetLocalWorker) String() string { return proto.CompactTextString(m) }
func (*BinkyNetLocalWorker) ProtoMessage()    {}
func (*BinkyNetLocalWorker) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{13}
}
func (m *BinkyNetLocalWorker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetLocalWorker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetLocalWorker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetLocalWorker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetLocalWorker.Merge(m, src)
}
func (m *BinkyNetLocalWorker) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetLocalWorker) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetLocalWorker.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetLocalWorker proto.InternalMessageInfo

func (m *BinkyNetLocalWorker) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetCommandStationId() string {
	if m != nil {
		return m.CommandStationId
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetHardwareId() string {
	if m != nil {
		return m.HardwareId
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *BinkyNetLocalWorker) GetDevices() []*BinkyNetDevice {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *BinkyNetLocalWorker) GetObjects() []*BinkyNetObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

type BinkyNetLocalWorkerRef struct {
	// ID of the local worker
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetLocalWorkerRef) Reset()         { *m = BinkyNetLocalWorkerRef{} }
func (m *BinkyNetLocalWorkerRef) String() string { return proto.CompactTextString(m) }
func (*BinkyNetLocalWorkerRef) ProtoMessage()    {}
func (*BinkyNetLocalWorkerRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{14}
}
func (m *BinkyNetLocalWorkerRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetLocalWorkerRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetLocalWorkerRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetLocalWorkerRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetLocalWorkerRef.Merge(m, src)
}
func (m *BinkyNetLocalWorkerRef) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetLocalWorkerRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetLocalWorkerRef.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetLocalWorkerRef proto.InternalMessageInfo

func (m *BinkyNetLocalWorkerRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type BinkyNetDevice struct {
	// ID of this object
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the device in the BinkyNet.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Type of the device
	DeviceType BinkyNetDeviceType `protobuf:"varint,3,opt,name=device_type,json=deviceType,proto3,enum=binkyrailways.v1.BinkyNetDeviceType" json:"device_type,omitempty"`
	// Address of the device
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	// If set, this device supports adding an object group of type MGV93
	CanAddMgv93Group     bool     `protobuf:"varint,10,opt,name=can_add_mgv93_group,json=canAddMgv93Group,proto3" json:"can_add_mgv93_group,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetDevice) Reset()         { *m = BinkyNetDevice{} }
func (m *BinkyNetDevice) String() string { return proto.CompactTextString(m) }
func (*BinkyNetDevice) ProtoMessage()    {}
func (*BinkyNetDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{15}
}
func (m *BinkyNetDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetDevice.Merge(m, src)
}
func (m *BinkyNetDevice) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetDevice.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetDevice proto.InternalMessageInfo

func (m *BinkyNetDevice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BinkyNetDevice) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *BinkyNetDevice) GetDeviceType() BinkyNetDeviceType {
	if m != nil {
		return m.DeviceType
	}
	return BinkyNetDeviceType_MCP23008
}

func (m *BinkyNetDevice) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *BinkyNetDevice) GetCanAddMgv93Group() bool {
	if m != nil {
		return m.CanAddMgv93Group
	}
	return false
}

type BinkyNetObject struct {
	// ID of this object
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the object in the binky network.
	ObjectId string `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Type of the object
	ObjectType BinkyNetObjectType `protobuf:"varint,3,opt,name=object_type,json=objectType,proto3,enum=binkyrailways.v1.BinkyNetObjectType" json:"object_type,omitempty"`
	// Connections to devices used by this object
	// The keys used in this map are specific to the type of object.
	Connections          []*BinkyNetConnection `protobuf:"bytes,4,rep,name=connections,proto3" json:"connections,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *BinkyNetObject) Reset()         { *m = BinkyNetObject{} }
func (m *BinkyNetObject) String() string { return proto.CompactTextString(m) }
func (*BinkyNetObject) ProtoMessage()    {}
func (*BinkyNetObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{16}
}
func (m *BinkyNetObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetObject.Merge(m, src)
}
func (m *BinkyNetObject) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetObject) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetObject.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetObject proto.InternalMessageInfo

func (m *BinkyNetObject) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BinkyNetObject) GetObjectId() string {
	if m != nil {
		return m.ObjectId
	}
	return ""
}

func (m *BinkyNetObject) GetObjectType() BinkyNetObjectType {
	if m != nil {
		return m.ObjectType
	}
	return BinkyNetObjectType_BINARYSENSOR
}

func (m *BinkyNetObject) GetConnections() []*BinkyNetConnection {
	if m != nil {
		return m.Connections
	}
	return nil
}

// BinkyNetConnection represents a connection from a BinkyNetObject to a
// BinkyNetDevice.
type BinkyNetConnection struct {
	// Key is specific to the type of device.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The pins of devices to connect to.
	Pins []*BinkyNetDevicePin `protobuf:"bytes,2,rep,name=pins,proto3" json:"pins,omitempty"`
	// Gets optional configuration for this connection.
	Configuration        map[string]string `protobuf:"bytes,3,rep,name=configuration,proto3" json:"configuration,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BinkyNetConnection) Reset()         { *m = BinkyNetConnection{} }
func (m *BinkyNetConnection) String() string { return proto.CompactTextString(m) }
func (*BinkyNetConnection) ProtoMessage()    {}
func (*BinkyNetConnection) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{17}
}
func (m *BinkyNetConnection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetConnection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetConnection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetConnection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetConnection.Merge(m, src)
}
func (m *BinkyNetConnection) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetConnection) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetConnection.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetConnection proto.InternalMessageInfo

func (m *BinkyNetConnection) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *BinkyNetConnection) GetPins() []*BinkyNetDevicePin {
	if m != nil {
		return m.Pins
	}
	return nil
}

func (m *BinkyNetConnection) GetConfiguration() map[string]string {
	if m != nil {
		return m.Configuration
	}
	return nil
}

// BinkyNetDevicePin identifies a hardware device and an index within that
// hardware address.
type BinkyNetDevicePin struct {
	// ID of the device that this connection refers to.
	DeviceId string `protobuf:"bytes,1,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Index on the device (1...)
	Index                uint32   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinkyNetDevicePin) Reset()         { *m = BinkyNetDevicePin{} }
func (m *BinkyNetDevicePin) String() string { return proto.CompactTextString(m) }
func (*BinkyNetDevicePin) ProtoMessage()    {}
func (*BinkyNetDevicePin) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{18}
}
func (m *BinkyNetDevicePin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinkyNetDevicePin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinkyNetDevicePin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinkyNetDevicePin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinkyNetDevicePin.Merge(m, src)
}
func (m *BinkyNetDevicePin) XXX_Size() int {
	return m.Size()
}
func (m *BinkyNetDevicePin) XXX_DiscardUnknown() {
	xxx_messageInfo_BinkyNetDevicePin.DiscardUnknown(m)
}

var xxx_messageInfo_BinkyNetDevicePin proto.InternalMessageInfo

func (m *BinkyNetDevicePin) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *BinkyNetDevicePin) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

// Block on the track
type Block struct {
	// ID of the block
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the block
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the block
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the block
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// Probability (in percentage) that a loc that is allowed to wait in this
	// block will actually wait. When set to 0, no locs will wait (unless there is
	// no route available). When set to 100, all locs (that are allowed) will
	// wait.
	WaitProbability int32 `protobuf:"varint,10,opt,name=wait_probability,json=waitProbability,proto3" json:"wait_probability,omitempty"`
	// Minimum amount of time to wait (if <see cref="WaitProbability"/> is set) in
	// seconds.
	MinimumWaitTime int32 `protobuf:"varint,11,opt,name=minimum_wait_time,json=minimumWaitTime,proto3" json:"minimum_wait_time,omitempty"`
	// Maximum amount of time to wait (if <see cref="WaitProbability"/> is set) in
	// seconds.
	MaximumWaitTime int32 `protobuf:"varint,12,opt,name=maximum_wait_time,json=maximumWaitTime,proto3" json:"maximum_wait_time,omitempty"`
	// Gets the predicate used to decide which locs are allowed to wait in this
	// block.
	WaitPermissions *LocStandardPredicate `protobuf:"bytes,13,opt,name=wait_permissions,json=waitPermissions,proto3" json:"wait_permissions,omitempty"`
	// By default the front of the block is on the right of the block.
	// When this property is set, that is reversed to the left of the block.
	// Setting this property will only alter the display behavior of the block.
	ReverseSides bool `protobuf:"varint,14,opt,name=reverse_sides,json=reverseSides,proto3" json:"reverse_sides,omitempty"`
	// Is it allowed for locs to change direction in this block?
	ChangeDirection ChangeDirection `protobuf:"varint,15,opt,name=change_direction,json=changeDirection,proto3,enum=binkyrailways.v1.ChangeDirection" json:"change_direction,omitempty"`
	// Must reversing locs change direction (back to normal) in this block?
	ChangeDirectionReversingLocs bool `protobuf:"varint,16,opt,name=change_direction_reversing_locs,json=changeDirectionReversingLocs,proto3" json:"change_direction_reversing_locs,omitempty"`
	// Is this block considered a station?
	IsStation bool `protobuf:"varint,18,opt,name=is_station,json=isStation,proto3" json:"is_station,omitempty"`
	// The block group that this block belongs to (if any).
	BlockGroup           *BlockGroupRef `protobuf:"bytes,19,opt,name=block_group,json=blockGroup,proto3" json:"block_group,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{19}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Block) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Block) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Block) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Block) GetWaitProbability() int32 {
	if m != nil {
		return m.WaitProbability
	}
	return 0
}

func (m *Block) GetMinimumWaitTime() int32 {
	if m != nil {
		return m.MinimumWaitTime
	}
	return 0
}

func (m *Block) GetMaximumWaitTime() int32 {
	if m != nil {
		return m.MaximumWaitTime
	}
	return 0
}

func (m *Block) GetWaitPermissions() *LocStandardPredicate {
	if m != nil {
		return m.WaitPermissions
	}
	return nil
}

func (m *Block) GetReverseSides() bool {
	if m != nil {
		return m.ReverseSides
	}
	return false
}

func (m *Block) GetChangeDirection() ChangeDirection {
	if m != nil {
		return m.ChangeDirection
	}
	return ChangeDirection_ALLOW
}

func (m *Block) GetChangeDirectionReversingLocs() bool {
	if m != nil {
		return m.ChangeDirectionReversingLocs
	}
	return false
}

func (m *Block) GetIsStation() bool {
	if m != nil {
		return m.IsStation
	}
	return false
}

func (m *Block) GetBlockGroup() *BlockGroupRef {
	if m != nil {
		return m.BlockGroup
	}
	return nil
}

// Reference to a Block
type BlockRef struct {
	// ID of the block
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRef) Reset()         { *m = BlockRef{} }
func (m *BlockRef) String() string { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()    {}
func (*BlockRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{20}
}
func (m *BlockRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRef.Merge(m, src)
}
func (m *BlockRef) XXX_Size() int {
	return m.Size()
}
func (m *BlockRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRef.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRef proto.InternalMessageInfo

func (m *BlockRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Group of blocks on the track
type BlockGroup struct {
	// ID of the block group
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the block group
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the block group
	ModuleId             string   `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockGroup) Reset()         { *m = BlockGroup{} }
func (m *BlockGroup) String() string { return proto.CompactTextString(m) }
func (*BlockGroup) ProtoMessage()    {}
func (*BlockGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{21}
}
func (m *BlockGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockGroup.Merge(m, src)
}
func (m *BlockGroup) XXX_Size() int {
	return m.Size()
}
func (m *BlockGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockGroup.DiscardUnknown(m)
}

var xxx_messageInfo_BlockGroup proto.InternalMessageInfo

func (m *BlockGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BlockGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BlockGroup) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

// Reference to a BlockGroup
type BlockGroupRef struct {
	// ID of the block group
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockGroupRef) Reset()         { *m = BlockGroupRef{} }
func (m *BlockGroupRef) String() string { return proto.CompactTextString(m) }
func (*BlockGroupRef) ProtoMessage()    {}
func (*BlockGroupRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{22}
}
func (m *BlockGroupRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockGroupRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockGroupRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockGroupRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockGroupRef.Merge(m, src)
}
func (m *BlockGroupRef) XXX_Size() int {
	return m.Size()
}
func (m *BlockGroupRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockGroupRef.DiscardUnknown(m)
}

var xxx_messageInfo_BlockGroupRef proto.InternalMessageInfo

func (m *BlockGroupRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Edge of a module on the track
type Edge struct {
	// ID of the edge
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the edge
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the edge
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the edge
	Position             *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Edge) Reset()         { *m = Edge{} }
func (m *Edge) String() string { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()    {}
func (*Edge) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{23}
}
func (m *Edge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Edge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Edge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Edge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Edge.Merge(m, src)
}
func (m *Edge) XXX_Size() int {
	return m.Size()
}
func (m *Edge) XXX_DiscardUnknown() {
	xxx_messageInfo_Edge.DiscardUnknown(m)
}

var xxx_messageInfo_Edge proto.InternalMessageInfo

func (m *Edge) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Edge) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Edge) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Edge) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// Reference to an Edge
type EdgeRef struct {
	// ID of the edge
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EdgeRef) Reset()         { *m = EdgeRef{} }
func (m *EdgeRef) String() string { return proto.CompactTextString(m) }
func (*EdgeRef) ProtoMessage()    {}
func (*EdgeRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{24}
}
func (m *EdgeRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeRef.Merge(m, src)
}
func (m *EdgeRef) XXX_Size() int {
	return m.Size()
}
func (m *EdgeRef) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeRef.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeRef proto.InternalMessageInfo

func (m *EdgeRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Junction on the track
type Junction struct {
	// ID of the Junction
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Junction
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Junction
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Junction
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// The block that this junction belongs to.
	// When set, this junction is considered lock if the block is locked.
	Block *BlockRef `protobuf:"bytes,5,opt,name=block,proto3" json:"block,omitempty"`
	// Set when this junction is of type switch.
	Switch               *Switch  `protobuf:"bytes,6,opt,name=switch,proto3" json:"switch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Junction) Reset()         { *m = Junction{} }
func (m *Junction) String() string { return proto.CompactTextString(m) }
func (*Junction) ProtoMessage()    {}
func (*Junction) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{25}
}
func (m *Junction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Junction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Junction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Junction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Junction.Merge(m, src)
}
func (m *Junction) XXX_Size() int {
	return m.Size()
}
func (m *Junction) XXX_DiscardUnknown() {
	xxx_messageInfo_Junction.DiscardUnknown(m)
}

var xxx_messageInfo_Junction proto.InternalMessageInfo

func (m *Junction) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Junction) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Junction) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Junction) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Junction) GetBlock() *BlockRef {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Junction) GetSwitch() *Switch {
	if m != nil {
		return m.Switch
	}
	return nil
}

// Reference to a Junction
type JunctionRef struct {
	// ID of the Junction
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JunctionRef) Reset()         { *m = JunctionRef{} }
func (m *JunctionRef) String() string { return proto.CompactTextString(m) }
func (*JunctionRef) ProtoMessage()    {}
func (*JunctionRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{26}
}
func (m *JunctionRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JunctionRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JunctionRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JunctionRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JunctionRef.Merge(m, src)
}
func (m *JunctionRef) XXX_Size() int {
	return m.Size()
}
func (m *JunctionRef) XXX_DiscardUnknown() {
	xxx_messageInfo_JunctionRef.DiscardUnknown(m)
}

var xxx_messageInfo_JunctionRef proto.InternalMessageInfo

func (m *JunctionRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Switch specialization of a Junction
type Switch struct {
	// Address of the switch
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Does this switch send a feedback when switched?
	HasFeedback bool `protobuf:"varint,2,opt,name=has_feedback,json=hasFeedback,proto3" json:"has_feedback,omitempty"`
	// Address of the feedback unit of the entity
	FeedbackAddress string `protobuf:"bytes,3,opt,name=feedback_address,json=feedbackAddress,proto3" json:"feedback_address,omitempty"`
	// Time (in ms) it takes for the switch to move from one direction to the
	// other? This property is only used when <see cref="HasFeedback"/> is false.
	SwitchDuration int32 `protobuf:"varint,4,opt,name=switch_duration,json=switchDuration,proto3" json:"switch_duration,omitempty"`
	// If set, the straight/off commands are inverted.
	Invert bool `protobuf:"varint,5,opt,name=invert,proto3" json:"invert,omitempty"`
	// If there is a different feedback address and this is set, the straight/off
	// feedback states are inverted.
	InvertFeedback bool `protobuf:"varint,6,opt,name=invert_feedback,json=invertFeedback,proto3" json:"invert_feedback,omitempty"`
	// At which direction should the switch be initialized?
	InitialDirection SwitchDirection `protobuf:"varint,7,opt,name=initial_direction,json=initialDirection,proto3,enum=binkyrailways.v1.SwitchDirection" json:"initial_direction,omitempty"`
	// Is this switch turning left?
	// Otherwise it is turning right.
	IsLeft               bool     `protobuf:"varint,8,opt,name=is_left,json=isLeft,proto3" json:"is_left,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Switch) Reset()         { *m = Switch{} }
func (m *Switch) String() string { return proto.CompactTextString(m) }
func (*Switch) ProtoMessage()    {}
func (*Switch) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{27}
}
func (m *Switch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Switch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Switch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Switch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Switch.Merge(m, src)
}
func (m *Switch) XXX_Size() int {
	return m.Size()
}
func (m *Switch) XXX_DiscardUnknown() {
	xxx_messageInfo_Switch.DiscardUnknown(m)
}

var xxx_messageInfo_Switch proto.InternalMessageInfo

func (m *Switch) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Switch) GetHasFeedback() bool {
	if m != nil {
		return m.HasFeedback
	}
	return false
}

func (m *Switch) GetFeedbackAddress() string {
	if m != nil {
		return m.FeedbackAddress
	}
	return ""
}

func (m *Switch) GetSwitchDuration() int32 {
	if m != nil {
		return m.SwitchDuration
	}
	return 0
}

func (m *Switch) GetInvert() bool {
	if m != nil {
		return m.Invert
	}
	return false
}

func (m *Switch) GetInvertFeedback() bool {
	if m != nil {
		return m.InvertFeedback
	}
	return false
}

func (m *Switch) GetInitialDirection() SwitchDirection {
	if m != nil {
		return m.InitialDirection
	}
	return SwitchDirection_STRAIGHT
}

func (m *Switch) GetIsLeft() bool {
	if m != nil {
		return m.IsLeft
	}
	return false
}

// Output on the track
type Output struct {
	// ID of the Output
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Output
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Output
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Output
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// Set when this output is of type binary output.
	BinaryOutput         *BinaryOutput `protobuf:"bytes,5,opt,name=binary_output,json=binaryOutput,proto3" json:"binary_output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Output) Reset()         { *m = Output{} }
func (m *Output) String() string { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()    {}
func (*Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{28}
}
func (m *Output) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Output.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Output.Merge(m, src)
}
func (m *Output) XXX_Size() int {
	return m.Size()
}
func (m *Output) XXX_DiscardUnknown() {
	xxx_messageInfo_Output.DiscardUnknown(m)
}

var xxx_messageInfo_Output proto.InternalMessageInfo

func (m *Output) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Output) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Output) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Output) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Output) GetBinaryOutput() *BinaryOutput {
	if m != nil {
		return m.BinaryOutput
	}
	return nil
}

// Reference to a Output
type OutputRef struct {
	// ID of the Output
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutputRef) Reset()         { *m = OutputRef{} }
func (m *OutputRef) String() string { return proto.CompactTextString(m) }
func (*OutputRef) ProtoMessage()    {}
func (*OutputRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{29}
}
func (m *OutputRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputRef.Merge(m, src)
}
func (m *OutputRef) XXX_Size() int {
	return m.Size()
}
func (m *OutputRef) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputRef.DiscardUnknown(m)
}

var xxx_messageInfo_OutputRef proto.InternalMessageInfo

func (m *OutputRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Sub type of Output
type BinaryOutput struct {
	// Output address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Type of output
	OutputType BinaryOutputType `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3,enum=binkyrailways.v1.BinaryOutputType" json:"output_type,omitempty"`
	// Text shown when output is in active state
	ActiveText string `protobuf:"bytes,3,opt,name=active_text,json=activeText,proto3" json:"active_text,omitempty"`
	// Text shown when output is in inactive state
	InactiveText         string   `protobuf:"bytes,4,opt,name=inactive_text,json=inactiveText,proto3" json:"inactive_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinaryOutput) Reset()         { *m = BinaryOutput{} }
func (m *BinaryOutput) String() string { return proto.CompactTextString(m) }
func (*BinaryOutput) ProtoMessage()    {}
func (*BinaryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{30}
}
func (m *BinaryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOutput.Merge(m, src)
}
func (m *BinaryOutput) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOutput proto.InternalMessageInfo

func (m *BinaryOutput) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *BinaryOutput) GetOutputType() BinaryOutputType {
	if m != nil {
		return m.OutputType
	}
	return BinaryOutputType_BOT_DEFAULT
}

func (m *BinaryOutput) GetActiveText() string {
	if m != nil {
		return m.ActiveText
	}
	return ""
}

func (m *BinaryOutput) GetInactiveText() string {
	if m != nil {
		return m.InactiveText
	}
	return ""
}

// Route on the track
type Route struct {
	// ID of the Route
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Route
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Route
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Start of the route
	From *Endpoint `protobuf:"bytes,4,opt,name=from,proto3" json:"from,omitempty"`
	// End of the route
	To *Endpoint `protobuf:"bytes,5,opt,name=to,proto3" json:"to,omitempty"`
	// Set of junctions with their states that are crossed when taking this route.
	CrossingJunctions []*JunctionWithState `protobuf:"bytes,6,rep,name=crossing_junctions,json=crossingJunctions,proto3" json:"crossing_junctions,omitempty"`
	// Set of events that change the state of the route and it's running loc.
	Events []*RouteEvent `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
	// Speed of locs when going this route.
	// This value is a percentage of the maximum / medium speed of the loc.
	// <value>0..100</value>
	Speed int32 `protobuf:"varint,10,opt,name=speed,proto3" json:"speed,omitempty"`
	// Probability (in percentage) that a loc will take this route.
	// When multiple routes are available to choose from the route with the
	// highest probability will have the highest chance or being chosen.
	// <value>0..100</value>
	ChooseProbability int32 `protobuf:"varint,11,opt,name=choose_probability,json=chooseProbability,proto3" json:"choose_probability,omitempty"`
	/// Gets the predicate used to decide which locs are allowed to use this
	/// route.
	Permissions *LocStandardPredicate `protobuf:"bytes,12,opt,name=permissions,proto3" json:"permissions,omitempty"`
	// Is this rout open for traffic or not?
	// Setting to true, allows for maintance etc. on this route.
	Closed bool `protobuf:"varint,13,opt,name=closed,proto3" json:"closed,omitempty"`
	// Maximum time in seconds that this route should take.
	// If a loc takes this route and exceeds this duration, a warning is given.
	MaxDuration          int32    `protobuf:"varint,14,opt,name=max_duration,json=maxDuration,proto3" json:"max_duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{31}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Route) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Route) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Route) GetFrom() *Endpoint {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Route) GetTo() *Endpoint {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Route) GetCrossingJunctions() []*JunctionWithState {
	if m != nil {
		return m.CrossingJunctions
	}
	return nil
}

func (m *Route) GetEvents() []*RouteEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Route) GetSpeed() int32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Route) GetChooseProbability() int32 {
	if m != nil {
		return m.ChooseProbability
	}
	return 0
}

func (m *Route) GetPermissions() *LocStandardPredicate {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Route) GetClosed() bool {
	if m != nil {
		return m.Closed
	}
	return false
}

func (m *Route) GetMaxDuration() int32 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

// Reference to a Route
type RouteRef struct {
	// ID of the Route
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteRef) Reset()         { *m = RouteRef{} }
func (m *RouteRef) String() string { return proto.CompactTextString(m) }
func (*RouteRef) ProtoMessage()    {}
func (*RouteRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{32}
}
func (m *RouteRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteRef.Merge(m, src)
}
func (m *RouteRef) XXX_Size() int {
	return m.Size()
}
func (m *RouteRef) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteRef.DiscardUnknown(m)
}

var xxx_messageInfo_RouteRef proto.InternalMessageInfo

func (m *RouteRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Source or destination of a route
type Endpoint struct {
	// Set if endpoint is a block
	Block *BlockRef `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	// Set if endpoint is an edge
	Edge *EdgeRef `protobuf:"bytes,2,opt,name=edge,proto3" json:"edge,omitempty"`
	// Set if endpoint is a block
	BlockSide            BlockSide `protobuf:"varint,3,opt,name=block_side,json=blockSide,proto3,enum=binkyrailways.v1.BlockSide" json:"block_side,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{33}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetBlock() *BlockRef {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Endpoint) GetEdge() *EdgeRef {
	if m != nil {
		return m.Edge
	}
	return nil
}

func (m *Endpoint) GetBlockSide() BlockSide {
	if m != nil {
		return m.BlockSide
	}
	return BlockSide_FRONT
}

// Reference to a junction with specific state
type JunctionWithState struct {
	// Junction reference
	Junction *JunctionRef `protobuf:"bytes,1,opt,name=junction,proto3" json:"junction,omitempty"`
	// Desired state of switch. Only set when junction is of type switch.
	SwitchState          *SwitchWithState `protobuf:"bytes,10,opt,name=switch_state,json=switchState,proto3" json:"switch_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *JunctionWithState) Reset()         { *m = JunctionWithState{} }
func (m *JunctionWithState) String() string { return proto.CompactTextString(m) }
func (*JunctionWithState) ProtoMessage()    {}
func (*JunctionWithState) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{34}
}
func (m *JunctionWithState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JunctionWithState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JunctionWithState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JunctionWithState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JunctionWithState.Merge(m, src)
}
func (m *JunctionWithState) XXX_Size() int {
	return m.Size()
}
func (m *JunctionWithState) XXX_DiscardUnknown() {
	xxx_messageInfo_JunctionWithState.DiscardUnknown(m)
}

var xxx_messageInfo_JunctionWithState proto.InternalMessageInfo

func (m *JunctionWithState) GetJunction() *JunctionRef {
	if m != nil {
		return m.Junction
	}
	return nil
}

func (m *JunctionWithState) GetSwitchState() *SwitchWithState {
	if m != nil {
		return m.SwitchState
	}
	return nil
}

type SwitchWithState struct {
	Direction            SwitchDirection `protobuf:"varint,1,opt,name=direction,proto3,enum=binkyrailways.v1.SwitchDirection" json:"direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SwitchWithState) Reset()         { *m = SwitchWithState{} }
func (m *SwitchWithState) String() string { return proto.CompactTextString(m) }
func (*SwitchWithState) ProtoMessage()    {}
func (*SwitchWithState) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{35}
}
func (m *SwitchWithState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWithState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWithState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchWithState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWithState.Merge(m, src)
}
func (m *SwitchWithState) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWithState) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWithState.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWithState proto.InternalMessageInfo

func (m *SwitchWithState) GetDirection() SwitchDirection {
	if m != nil {
		return m.Direction
	}
	return SwitchDirection_STRAIGHT
}

// RouteEvent specifies a sensor event in a route.
type RouteEvent struct {
	// Sensor that triggers the event
	Sensor *SensorRef `protobuf:"bytes,1,opt,name=sensor,proto3" json:"sensor,omitempty"`
	// Gets the list of behaviors to choose from.
	// The first matching behavior is used.
	Behaviors            []*RouteEventBehavior `protobuf:"bytes,2,rep,name=behaviors,proto3" json:"behaviors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RouteEvent) Reset()         { *m = RouteEvent{} }
func (m *RouteEvent) String() string { return proto.CompactTextString(m) }
func (*RouteEvent) ProtoMessage()    {}
func (*RouteEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{36}
}
func (m *RouteEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteEvent.Merge(m, src)
}
func (m *RouteEvent) XXX_Size() int {
	return m.Size()
}
func (m *RouteEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RouteEvent proto.InternalMessageInfo

func (m *RouteEvent) GetSensor() *SensorRef {
	if m != nil {
		return m.Sensor
	}
	return nil
}

func (m *RouteEvent) GetBehaviors() []*RouteEventBehavior {
	if m != nil {
		return m.Behaviors
	}
	return nil
}

type RouteEventBehavior struct {
	// Predicate used to select the locs to which this event applies.
	AppliesTo *LocPredicate `protobuf:"bytes,1,opt,name=applies_to,json=appliesTo,proto3" json:"applies_to,omitempty"`
	// How is the state of the route changed.
	StateBehavior RouteStateBehavior `protobuf:"varint,2,opt,name=state_behavior,json=stateBehavior,proto3,enum=binkyrailways.v1.RouteStateBehavior" json:"state_behavior,omitempty"`
	// How is the speed of the occupying loc changed.
	SpeedBehavior        LocSpeedBehavior `protobuf:"varint,3,opt,name=speed_behavior,json=speedBehavior,proto3,enum=binkyrailways.v1.LocSpeedBehavior" json:"speed_behavior,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RouteEventBehavior) Reset()         { *m = RouteEventBehavior{} }
func (m *RouteEventBehavior) String() string { return proto.CompactTextString(m) }
func (*RouteEventBehavior) ProtoMessage()    {}
func (*RouteEventBehavior) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{37}
}
func (m *RouteEventBehavior) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteEventBehavior) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteEventBehavior.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteEventBehavior) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteEventBehavior.Merge(m, src)
}
func (m *RouteEventBehavior) XXX_Size() int {
	return m.Size()
}
func (m *RouteEventBehavior) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteEventBehavior.DiscardUnknown(m)
}

var xxx_messageInfo_RouteEventBehavior proto.InternalMessageInfo

func (m *RouteEventBehavior) GetAppliesTo() *LocPredicate {
	if m != nil {
		return m.AppliesTo
	}
	return nil
}

func (m *RouteEventBehavior) GetStateBehavior() RouteStateBehavior {
	if m != nil {
		return m.StateBehavior
	}
	return RouteStateBehavior_RSB_NOCHANGE
}

func (m *RouteEventBehavior) GetSpeedBehavior() LocSpeedBehavior {
	if m != nil {
		return m.SpeedBehavior
	}
	return LocSpeedBehavior_LSB_DEFAULT
}

// Sensor on the track
type Sensor struct {
	// ID of the Sensor
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Sensor
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Sensor
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Sensor
	Position *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	// Address of the sensor
	Address string `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	// The block that this sensor belongs to.
	// When set, this connection is used in the loc-to-block assignment process.
	Block *BlockRef `protobuf:"bytes,6,opt,name=block,proto3" json:"block,omitempty"`
	// Shape used to visualize this sensor
	Shape Shape `protobuf:"varint,7,opt,name=shape,proto3,enum=binkyrailways.v1.Shape" json:"shape,omitempty"`
	// Set when this sensor is of type binary sensor.
	BinarySensor         *BinarySensor `protobuf:"bytes,8,opt,name=binary_sensor,json=binarySensor,proto3" json:"binary_sensor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Sensor) Reset()         { *m = Sensor{} }
func (m *Sensor) String() string { return proto.CompactTextString(m) }
func (*Sensor) ProtoMessage()    {}
func (*Sensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{38}
}
func (m *Sensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sensor.Merge(m, src)
}
func (m *Sensor) XXX_Size() int {
	return m.Size()
}
func (m *Sensor) XXX_DiscardUnknown() {
	xxx_messageInfo_Sensor.DiscardUnknown(m)
}

var xxx_messageInfo_Sensor proto.InternalMessageInfo

func (m *Sensor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Sensor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Sensor) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Sensor) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Sensor) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Sensor) GetBlock() *BlockRef {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Sensor) GetShape() Shape {
	if m != nil {
		return m.Shape
	}
	return Shape_CIRCLE
}

func (m *Sensor) GetBinarySensor() *BinarySensor {
	if m != nil {
		return m.BinarySensor
	}
	return nil
}

// Reference to a Sensor
type SensorRef struct {
	// ID of the Sensor
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SensorRef) Reset()         { *m = SensorRef{} }
func (m *SensorRef) String() string { return proto.CompactTextString(m) }
func (*SensorRef) ProtoMessage()    {}
func (*SensorRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{39}
}
func (m *SensorRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorRef.Merge(m, src)
}
func (m *SensorRef) XXX_Size() int {
	return m.Size()
}
func (m *SensorRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorRef.DiscardUnknown(m)
}

var xxx_messageInfo_SensorRef proto.InternalMessageInfo

func (m *SensorRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Sub type of Sensor
type BinarySensor struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinarySensor) Reset()         { *m = BinarySensor{} }
func (m *BinarySensor) String() string { return proto.CompactTextString(m) }
func (*BinarySensor) ProtoMessage()    {}
func (*BinarySensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{40}
}
func (m *BinarySensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinarySensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinarySensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinarySensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinarySensor.Merge(m, src)
}
func (m *BinarySensor) XXX_Size() int {
	return m.Size()
}
func (m *BinarySensor) XXX_DiscardUnknown() {
	xxx_messageInfo_BinarySensor.DiscardUnknown(m)
}

var xxx_messageInfo_BinarySensor proto.InternalMessageInfo

// Signal on the track
type Signal struct {
	// ID of the Signal
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Description of the Signal
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// ID of the module containing the Signal
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Position of the Signal
	Position             *Position `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Signal) Reset()         { *m = Signal{} }
func (m *Signal) String() string { return proto.CompactTextString(m) }
func (*Signal) ProtoMessage()    {}
func (*Signal) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{41}
}
func (m *Signal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signal.Merge(m, src)
}
func (m *Signal) XXX_Size() int {
	return m.Size()
}
func (m *Signal) XXX_DiscardUnknown() {
	xxx_messageInfo_Signal.DiscardUnknown(m)
}

var xxx_messageInfo_Signal proto.InternalMessageInfo

func (m *Signal) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Signal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Signal) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Signal) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// Reference to a Signal
type SignalRef struct {
	// ID of the Signal
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignalRef) Reset()         { *m = SignalRef{} }
func (m *SignalRef) String() string { return proto.CompactTextString(m) }
func (*SignalRef) ProtoMessage()    {}
func (*SignalRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{42}
}
func (m *SignalRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignalRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignalRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignalRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignalRef.Merge(m, src)
}
func (m *SignalRef) XXX_Size() int {
	return m.Size()
}
func (m *SignalRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SignalRef.DiscardUnknown(m)
}

var xxx_messageInfo_SignalRef proto.InternalMessageInfo

func (m *SignalRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Loc predicate allows expressions to select locs.
type LocPredicate struct {
	// Set if predicate is of type And.
	And *LocAndPredicate `protobuf:"bytes,1,opt,name=and,proto3" json:"and,omitempty"`
	// Set if predicate is of type Or.
	Or *LocOrPredicate `protobuf:"bytes,2,opt,name=or,proto3" json:"or,omitempty"`
	// Set if predicate is of type Equals.
	Equals *LocEqualsPredicate `protobuf:"bytes,3,opt,name=equals,proto3" json:"equals,omitempty"`
	// Set if predicate is of type GroupEquals.
	Group *LocGroupEqualsPredicate `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty"`
	// Set if predicate is of type CanChangeDirection.
	CanChangeDirection *LocCanChangeDirectionPredicate `protobuf:"bytes,5,opt,name=canChangeDirection,proto3" json:"canChangeDirection,omitempty"`
	// Set if predicate is of type Standard.
	Standard             *LocStandardPredicate `protobuf:"bytes,6,opt,name=standard,proto3" json:"standard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *LocPredicate) Reset()         { *m = LocPredicate{} }
func (m *LocPredicate) String() string { return proto.CompactTextString(m) }
func (*LocPredicate) ProtoMessage()    {}
func (*LocPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{43}
}
func (m *LocPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocPredicate.Merge(m, src)
}
func (m *LocPredicate) XXX_Size() int {
	return m.Size()
}
func (m *LocPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_LocPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_LocPredicate proto.InternalMessageInfo

func (m *LocPredicate) GetAnd() *LocAndPredicate {
	if m != nil {
		return m.And
	}
	return nil
}

func (m *LocPredicate) GetOr() *LocOrPredicate {
	if m != nil {
		return m.Or
	}
	return nil
}

func (m *LocPredicate) GetEquals() *LocEqualsPredicate {
	if m != nil {
		return m.Equals
	}
	return nil
}

func (m *LocPredicate) GetGroup() *LocGroupEqualsPredicate {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *LocPredicate) GetCanChangeDirection() *LocCanChangeDirectionPredicate {
	if m != nil {
		return m.CanChangeDirection
	}
	return nil
}

func (m *LocPredicate) GetStandard() *LocStandardPredicate {
	if m != nil {
		return m.Standard
	}
	return nil
}

// Loc predicate that evaluates to true if all predicates evaluate to true.
type LocAndPredicate struct {
	Predicates           []*LocPredicate `protobuf:"bytes,1,rep,name=predicates,proto3" json:"predicates,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LocAndPredicate) Reset()         { *m = LocAndPredicate{} }
func (m *LocAndPredicate) String() string { return proto.CompactTextString(m) }
func (*LocAndPredicate) ProtoMessage()    {}
func (*LocAndPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{44}
}
func (m *LocAndPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocAndPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocAndPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocAndPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocAndPredicate.Merge(m, src)
}
func (m *LocAndPredicate) XXX_Size() int {
	return m.Size()
}
func (m *LocAndPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_LocAndPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_LocAndPredicate proto.InternalMessageInfo

func (m *LocAndPredicate) GetPredicates() []*LocPredicate {
	if m != nil {
		return m.Predicates
	}
	return nil
}

// Loc predicate that evaluates to true if and on the predicates evaluate to true.
type LocOrPredicate struct {
	Predicates           []*LocPredicate `protobuf:"bytes,1,rep,name=predicates,proto3" json:"predicates,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LocOrPredicate) Reset()         { *m = LocOrPredicate{} }
func (m *LocOrPredicate) String() string { return proto.CompactTextString(m) }
func (*LocOrPredicate) ProtoMessage()    {}
func (*LocOrPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{45}
}
func (m *LocOrPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocOrPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocOrPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocOrPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocOrPredicate.Merge(m, src)
}
func (m *LocOrPredicate) XXX_Size() int {
	return m.Size()
}
func (m *LocOrPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_LocOrPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_LocOrPredicate proto.InternalMessageInfo

func (m *LocOrPredicate) GetPredicates() []*LocPredicate {
	if m != nil {
		return m.Predicates
	}
	return nil
}

// Loc predicate that evaluates to true if the loc equals the given loc reference.
type LocEqualsPredicate struct {
	Loc                  *LocRef  `protobuf:"bytes,1,opt,name=loc,proto3" json:"loc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocEqualsPredicate) Reset()         { *m = LocEqualsPredicate{} }
func (m *LocEqualsPredicate) String() string { return proto.CompactTextString(m) }
func (*LocEqualsPredicate) ProtoMessage()    {}
func (*LocEqualsPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{46}
}
func (m *LocEqualsPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocEqualsPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocEqualsPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocEqualsPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocEqualsPredicate.Merge(m, src)
}
func (m *LocEqualsPredicate) XXX_Size() int {
	return m.Size()
}
func (m *LocEqualsPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_LocEqualsPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_LocEqualsPredicate proto.InternalMessageInfo

func (m *LocEqualsPredicate) GetLoc() *LocRef {
	if m != nil {
		return m.Loc
	}
	return nil
}

// Loc predicate that evaluates to true if the loc is member of the given group.
type LocGroupEqualsPredicate struct {
	Group                *LocGroupRef `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LocGroupEqualsPredicate) Reset()         { *m = LocGroupEqualsPredicate{} }
func (m *LocGroupEqualsPredicate) String() string { return proto.CompactTextString(m) }
func (*LocGroupEqualsPredicate) ProtoMessage()    {}
func (*LocGroupEqualsPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{47}
}
func (m *LocGroupEqualsPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocGroupEqualsPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocGroupEqualsPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocGroupEqualsPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocGroupEqualsPredicate.Merge(m, src)
}
func (m *LocGroupEqualsPredicate) XXX_Size() int {
	return m.Size()
}
func (m *LocGroupEqualsPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_LocGroupEqualsPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_LocGroupEqualsPredicate proto.InternalMessageInfo

func (m *LocGroupEqualsPredicate) GetGroup() *LocGroupRef {
	if m != nil {
		return m.Group
	}
	return nil
}

// Loc predicate that evaluates to true if the loc can change direction.
type LocCanChangeDirectionPredicate struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocCanChangeDirectionPredicate) Reset()         { *m = LocCanChangeDirectionPredicate{} }
func (m *LocCanChangeDirectionPredicate) String() string { return proto.CompactTextString(m) }
func (*LocCanChangeDirectionPredicate) ProtoMessage()    {}
func (*LocCanChangeDirectionPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{48}
}
func (m *LocCanChangeDirectionPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocCanChangeDirectionPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocCanChangeDirectionPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocCanChangeDirectionPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocCanChangeDirectionPredicate.Merge(m, src)
}
func (m *LocCanChangeDirectionPredicate) XXX_Size() int {
	return m.Size()
}
func (m *LocCanChangeDirectionPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_LocCanChangeDirectionPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_LocCanChangeDirectionPredicate proto.InternalMessageInfo

// LocStandardPredicate is a predicate that evaluates to true based on includes and excludes predicates.
// The predicate evaluates to true if:
// - Includes is empty and the excludes predicate for the loc evaluates to false.
// - The Includes predicate evaluates to true and the excludes predicate for the loc evaluates to false
type LocStandardPredicate struct {
	// Including predicates
	Includes []*LocPredicate `protobuf:"bytes,1,rep,name=includes,proto3" json:"includes,omitempty"`
	// Excluding predicates
	Excludes             []*LocPredicate `protobuf:"bytes,2,rep,name=excludes,proto3" json:"excludes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LocStandardPredicate) Reset()         { *m = LocStandardPredicate{} }
func (m *LocStandardPredicate) String() string { return proto.CompactTextString(m) }
func (*LocStandardPredicate) ProtoMessage()    {}
func (*LocStandardPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_054508b9601a8429, []int{49}
}
func (m *LocStandardPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocStandardPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocStandardPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocStandardPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocStandardPredicate.Merge(m, src)
}
func (m *LocStandardPredicate) XXX_Size() int {
	return m.Size()
}
func (m *LocStandardPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_LocStandardPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_LocStandardPredicate proto.InternalMessageInfo

func (m *LocStandardPredicate) GetIncludes() []*LocPredicate {
	if m != nil {
		return m.Includes
	}
	return nil
}

func (m *LocStandardPredicate) GetExcludes() []*LocPredicate {
	if m != nil {
		return m.Excludes
	}
	return nil
}

func init() {
	proto.RegisterEnum("binkyrailways.v1.ChangeDirection", ChangeDirection_name, ChangeDirection_value)
	proto.RegisterEnum("binkyrailways.v1.BinkyNetDeviceType", BinkyNetDeviceType_name, BinkyNetDeviceType_value)
	proto.RegisterEnum("binkyrailways.v1.BinkyNetObjectType", BinkyNetObjectType_name, BinkyNetObjectType_value)
	proto.RegisterEnum("binkyrailways.v1.SwitchDirection", SwitchDirection_name, SwitchDirection_value)
	proto.RegisterEnum("binkyrailways.v1.BinaryOutputType", BinaryOutputType_name, BinaryOutputType_value)
	proto.RegisterEnum("binkyrailways.v1.BlockSide", BlockSide_name, BlockSide_value)
	proto.RegisterEnum("binkyrailways.v1.RouteStateBehavior", RouteStateBehavior_name, RouteStateBehavior_value)
	proto.RegisterEnum("binkyrailways.v1.LocSpeedBehavior", LocSpeedBehavior_name, LocSpeedBehavior_value)
	proto.RegisterEnum("binkyrailways.v1.Shape", Shape_name, Shape_value)
	proto.RegisterType((*Empty)(nil), "binkyrailways.v1.Empty")
	proto.RegisterType((*Image)(nil), "binkyrailways.v1.Image")
	proto.RegisterType((*Railway)(nil), "binkyrailways.v1.Railway")
	proto.RegisterType((*Module)(nil), "binkyrailways.v1.Module")
	proto.RegisterType((*ModuleRef)(nil), "binkyrailways.v1.ModuleRef")
	proto.RegisterType((*Position)(nil), "binkyrailways.v1.Position")
	proto.RegisterType((*Loc)(nil), "binkyrailways.v1.Loc")
	proto.RegisterType((*LocRef)(nil), "binkyrailways.v1.LocRef")
	proto.RegisterType((*LocGroup)(nil), "binkyrailways.v1.LocGroup")
	proto.RegisterType((*LocGroupRef)(nil), "binkyrailways.v1.LocGroupRef")
	proto.RegisterType((*CommandStation)(nil), "binkyrailways.v1.CommandStation")
	proto.RegisterType((*CommandStationRef)(nil), "binkyrailways.v1.CommandStationRef")
	proto.RegisterType((*BinkyNetCommandStation)(nil), "binkyrailways.v1.BinkyNetCommandStation")
	proto.RegisterType((*BinkyNetLocalWorker)(nil), "binkyrailways.v1.BinkyNetLocalWorker")
	proto.RegisterType((*BinkyNetLocalWorkerRef)(nil), "binkyrailways.v1.BinkyNetLocalWorkerRef")
	proto.RegisterType((*BinkyNetDevice)(nil), "binkyrailways.v1.BinkyNetDevice")
	proto.RegisterType((*BinkyNetObject)(nil), "binkyrailways.v1.BinkyNetObject")
	proto.RegisterType((*BinkyNetConnection)(nil), "binkyrailways.v1.BinkyNetConnection")
	proto.RegisterMapType((map[string]string)(nil), "binkyrailways.v1.BinkyNetConnection.ConfigurationEntry")
	proto.RegisterType((*BinkyNetDevicePin)(nil), "binkyrailways.v1.BinkyNetDevicePin")
	proto.RegisterType((*Block)(nil), "binkyrailways.v1.Block")
	proto.RegisterType((*BlockRef)(nil), "binkyrailways.v1.BlockRef")
	proto.RegisterType((*BlockGroup)(nil), "binkyrailways.v1.BlockGroup")
	proto.RegisterType((*BlockGroupRef)(nil), "binkyrailways.v1.BlockGroupRef")
	proto.RegisterType((*Edge)(nil), "binkyrailways.v1.Edge")
	proto.RegisterType((*EdgeRef)(nil), "binkyrailways.v1.EdgeRef")
	proto.RegisterType((*Junction)(nil), "binkyrailways.v1.Junction")
	proto.RegisterType((*JunctionRef)(nil), "binkyrailways.v1.JunctionRef")
	proto.RegisterType((*Switch)(nil), "binkyrailways.v1.Switch")
	proto.RegisterType((*Output)(nil), "binkyrailways.v1.Output")
	proto.RegisterType((*OutputRef)(nil), "binkyrailways.v1.OutputRef")
	proto.RegisterType((*BinaryOutput)(nil), "binkyrailways.v1.BinaryOutput")
	proto.RegisterType((*Route)(nil), "binkyrailways.v1.Route")
	proto.RegisterType((*RouteRef)(nil), "binkyrailways.v1.RouteRef")
	proto.RegisterType((*Endpoint)(nil), "binkyrailways.v1.Endpoint")
	proto.RegisterType((*JunctionWithState)(nil), "binkyrailways.v1.JunctionWithState")
	proto.RegisterType((*SwitchWithState)(nil), "binkyrailways.v1.SwitchWithState")
	proto.RegisterType((*RouteEvent)(nil), "binkyrailways.v1.RouteEvent")
	proto.RegisterType((*RouteEventBehavior)(nil), "binkyrailways.v1.RouteEventBehavior")
	proto.RegisterType((*Sensor)(nil), "binkyrailways.v1.Sensor")
	proto.RegisterType((*SensorRef)(nil), "binkyrailways.v1.SensorRef")
	proto.RegisterType((*BinarySensor)(nil), "binkyrailways.v1.BinarySensor")
	proto.RegisterType((*Signal)(nil), "binkyrailways.v1.Signal")
	proto.RegisterType((*SignalRef)(nil), "binkyrailways.v1.SignalRef")
	proto.RegisterType((*LocPredicate)(nil), "binkyrailways.v1.LocPredicate")
	proto.RegisterType((*LocAndPredicate)(nil), "binkyrailways.v1.LocAndPredicate")
	proto.RegisterType((*LocOrPredicate)(nil), "binkyrailways.v1.LocOrPredicate")
	proto.RegisterType((*LocEqualsPredicate)(nil), "binkyrailways.v1.LocEqualsPredicate")
	proto.RegisterType((*LocGroupEqualsPredicate)(nil), "binkyrailways.v1.LocGroupEqualsPredicate")
	proto.RegisterType((*LocCanChangeDirectionPredicate)(nil), "binkyrailways.v1.LocCanChangeDirectionPredicate")
	proto.RegisterType((*LocStandardPredicate)(nil), "binkyrailways.v1.LocStandardPredicate")
}

func init() { proto.RegisterFile("br_model_types.proto", fileDescriptor_054508b9601a8429) }

var fileDescriptor_054508b9601a8429 = []byte{
	// 2823 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xcb, 0x73, 0x1b, 0xc7,
	0xd1, 0xd7, 0xe2, 0x45, 0xa0, 0x01, 0x82, 0xcb, 0xb1, 0x6c, 0xad, 0x25, 0x8b, 0xa2, 0xd6, 0xfe,
	0x3e, 0xd3, 0x2c, 0x9b, 0xa2, 0x24, 0x5b, 0x92, 0xf5, 0xf9, 0x8b, 0x0d, 0x82, 0xa0, 0x04, 0x1b,
	0x7c, 0x78, 0x00, 0x49, 0x71, 0x52, 0xa9, 0xcd, 0x62, 0x77, 0x08, 0x8c, 0x09, 0xec, 0xc2, 0xbb,
	0x0b, 0x92, 0xc8, 0x29, 0x97, 0xf8, 0x94, 0xc7, 0x25, 0x87, 0x54, 0xce, 0xa9, 0xe4, 0x0f, 0xc8,
	0x7f, 0x90, 0x5c, 0x72, 0x48, 0x2a, 0x39, 0xa4, 0x2a, 0xb9, 0xa4, 0x2a, 0xe5, 0x1c, 0x73, 0xce,
	0x39, 0xa9, 0x79, 0xec, 0x03, 0x2f, 0x8a, 0x52, 0x7c, 0xd0, 0x0d, 0xd3, 0xf3, 0xeb, 0xde, 0x7e,
	0x4d, 0x77, 0xcf, 0x90, 0x70, 0xb1, 0xed, 0x19, 0x7d, 0xd7, 0x26, 0x3d, 0x23, 0x18, 0x0d, 0x88,
	0xbf, 0x31, 0xf0, 0xdc, 0xc0, 0x45, 0x6a, 0x9b, 0x3a, 0x47, 0x23, 0xcf, 0xa4, 0xbd, 0x13, 0x73,
	0xe4, 0x6f, 0x1c, 0xdf, 0xd4, 0x17, 0x20, 0x5b, 0xeb, 0x0f, 0x82, 0x91, 0xbe, 0x01, 0xd9, 0x7a,
	0xdf, 0xec, 0x10, 0xf4, 0x3f, 0x50, 0xb6, 0x5c, 0x27, 0x20, 0x4e, 0x60, 0xb4, 0x4d, 0x9f, 0xdc,
	0x79, 0x57, 0x53, 0x56, 0x95, 0xb5, 0x02, 0x5e, 0x94, 0xd4, 0x2d, 0x4e, 0xd4, 0x7f, 0x93, 0x82,
	0x05, 0x2c, 0x04, 0xa1, 0x32, 0xa4, 0xa8, 0x2d, 0x61, 0x29, 0x6a, 0xa3, 0x55, 0x28, 0xda, 0xc4,
	0xb7, 0x3c, 0x3a, 0x08, 0xa8, 0xeb, 0x68, 0x29, 0xbe, 0x91, 0x24, 0xa1, 0x8b, 0x90, 0xb5, 0xa9,
	0x17, 0x8c, 0xb4, 0xf4, 0xaa, 0xb2, 0x96, 0xc7, 0x62, 0x81, 0xde, 0x83, 0x85, 0xbe, 0x6b, 0x0f,
	0x7b, 0xc4, 0xd7, 0xec, 0xd5, 0xf4, 0x5a, 0xf1, 0xd6, 0x95, 0x8d, 0x49, 0x85, 0x37, 0x76, 0x39,
	0x00, 0x93, 0x43, 0x1c, 0x62, 0xd1, 0xdb, 0x90, 0xe9, 0xb9, 0x96, 0xaf, 0x11, 0xce, 0xa3, 0x4d,
	0xf3, 0x34, 0x5c, 0x8b, 0x31, 0x70, 0x14, 0xfa, 0x3f, 0x28, 0xf4, 0x5c, 0xeb, 0x81, 0xe7, 0x0e,
	0x07, 0xbe, 0x76, 0xc8, 0x59, 0xae, 0xce, 0x64, 0xe1, 0x10, 0xc6, 0x17, 0xe3, 0xd1, 0x2e, 0x2c,
	0x59, 0x6e, 0xbf, 0x6f, 0x3a, 0x76, 0x33, 0x30, 0x99, 0x25, 0xbe, 0xd6, 0xe1, 0x22, 0x5e, 0x9f,
	0x16, 0x51, 0x1d, 0x03, 0x32, 0x41, 0x93, 0xbc, 0xfa, 0x5f, 0x33, 0x90, 0x13, 0x06, 0x3d, 0x9f,
	0x0f, 0x4f, 0xa8, 0x1d, 0x74, 0xb9, 0x0f, 0xb3, 0x58, 0x2c, 0xd0, 0x2b, 0x90, 0xeb, 0x12, 0xda,
	0xe9, 0x06, 0x5a, 0x86, 0x93, 0xe5, 0x0a, 0x6d, 0xc2, 0xc5, 0xae, 0xe9, 0x1b, 0x6d, 0xd3, 0x3a,
	0xea, 0x78, 0xee, 0xd0, 0xb1, 0x0d, 0xca, 0xc2, 0xad, 0x65, 0x79, 0x00, 0x50, 0xd7, 0xf4, 0xb7,
	0xa2, 0x2d, 0x91, 0x08, 0xb7, 0x20, 0xd7, 0xee, 0xb9, 0xd6, 0x51, 0x18, 0x8c, 0xcb, 0xd3, 0x26,
	0x6e, 0xb1, 0x7d, 0x66, 0x99, 0x44, 0xa2, 0x0a, 0x14, 0xf9, 0x2f, 0xe9, 0x5e, 0x11, 0x91, 0x6b,
	0x73, 0x18, 0x23, 0x07, 0x27, 0x79, 0xd0, 0x0d, 0xc8, 0x12, 0xbb, 0x43, 0xc2, 0xd8, 0xbc, 0x3a,
	0xcd, 0x5c, 0xb3, 0x3b, 0x3c, 0x01, 0x04, 0x8e, 0x05, 0xf4, 0xf3, 0xa1, 0x63, 0x25, 0xa3, 0x31,
	0x23, 0xa0, 0x1f, 0x4b, 0x08, 0x0f, 0x68, 0x84, 0x67, 0x29, 0xe7, 0x0e, 0x83, 0xc1, 0x30, 0xf0,
	0xb5, 0xee, 0xbc, 0x94, 0xdb, 0xe7, 0x00, 0x9e, 0x72, 0x12, 0xcb, 0x7c, 0xe3, 0xb9, 0xc3, 0x80,
	0xf8, 0x1a, 0x9d, 0xe7, 0x1b, 0xcc, 0xf6, 0xb9, 0x6f, 0x04, 0x92, 0x7d, 0xca, 0x27, 0x8e, 0xef,
	0x7a, 0xbe, 0xf6, 0xf9, 0xbc, 0x4f, 0x35, 0x39, 0x80, 0x7f, 0x4a, 0x62, 0x39, 0x1b, 0xed, 0x38,
	0x66, 0xcf, 0xd7, 0x8e, 0xe6, 0xb2, 0x71, 0x80, 0x60, 0x13, 0x58, 0xfd, 0x87, 0x0a, 0x14, 0xa2,
	0xb3, 0x32, 0x95, 0x5d, 0x77, 0x20, 0x3f, 0x70, 0x7d, 0x1a, 0xa5, 0xd6, 0x4c, 0x0b, 0x0e, 0x24,
	0x02, 0x47, 0x58, 0x74, 0x0d, 0x8a, 0xdf, 0x73, 0xdd, 0xbe, 0x71, 0x68, 0x5a, 0x81, 0xeb, 0xc9,
	0xcc, 0x03, 0x46, 0xda, 0xe1, 0x14, 0x96, 0x7e, 0x2c, 0x96, 0xc4, 0xe6, 0xe9, 0x97, 0xc7, 0x72,
	0xa5, 0x7f, 0xa9, 0x40, 0x3e, 0x94, 0x87, 0x4a, 0xa0, 0x9c, 0x72, 0x65, 0xb2, 0x58, 0x39, 0x65,
	0xab, 0x11, 0x57, 0x22, 0x8b, 0x95, 0xd1, 0x33, 0x66, 0xf5, 0x65, 0xc8, 0x7b, 0xae, 0x38, 0x4d,
	0x3c, 0x93, 0xb3, 0x38, 0x5a, 0x33, 0x49, 0x3d, 0x73, 0x44, 0x3c, 0x2d, 0xc7, 0xcd, 0x16, 0x0b,
	0xfd, 0x2f, 0x29, 0x48, 0x37, 0x5c, 0xeb, 0xf9, 0xce, 0x9b, 0x7b, 0xe2, 0x10, 0x61, 0x75, 0x01,
	0x8b, 0x05, 0xd2, 0x60, 0xc1, 0x23, 0x7d, 0xd3, 0x3b, 0xf2, 0xb9, 0x6a, 0x05, 0x1c, 0x2e, 0xd9,
	0x8e, 0x69, 0xdb, 0x1e, 0xf1, 0x7d, 0xae, 0x5a, 0x01, 0x87, 0x4b, 0x74, 0x15, 0xc0, 0xef, 0xb9,
	0x27, 0x86, 0x3f, 0x20, 0xc4, 0xd6, 0x6c, 0xae, 0x77, 0x81, 0x51, 0x9a, 0x8c, 0x80, 0xae, 0x43,
	0xa9, 0x4f, 0x6c, 0x3a, 0xec, 0x4b, 0x00, 0xe1, 0x80, 0xa2, 0xa0, 0x09, 0xc8, 0xeb, 0xb0, 0xd8,
	0x37, 0x4f, 0x69, 0x3f, 0xc2, 0x1c, 0x72, 0x4c, 0x49, 0x12, 0x05, 0xe8, 0x1a, 0x14, 0xf9, 0xa6,
	0xe1, 0x07, 0x64, 0xe0, 0x6b, 0x8e, 0x08, 0x16, 0x27, 0x35, 0x19, 0x05, 0x35, 0x40, 0xb5, 0xba,
	0xa6, 0xd3, 0x21, 0x86, 0x4d, 0x3d, 0xc2, 0x4f, 0x84, 0x76, 0xba, 0xaa, 0xac, 0x95, 0x6f, 0x5d,
	0x9f, 0x51, 0xce, 0x38, 0x72, 0x3b, 0x04, 0xe2, 0x25, 0x6b, 0x9c, 0xa0, 0x6b, 0x90, 0x13, 0x85,
	0x76, 0xd2, 0xb7, 0xfa, 0x07, 0x90, 0x0f, 0xeb, 0xe9, 0xb3, 0xfb, 0x5d, 0xbf, 0x0a, 0xc5, 0x44,
	0x35, 0x9e, 0x12, 0xfe, 0x4b, 0x05, 0xca, 0xe3, 0xa5, 0xf6, 0x39, 0x62, 0xdb, 0x06, 0x8d, 0x1b,
	0xec, 0x90, 0xc0, 0x90, 0x45, 0xda, 0xf0, 0x65, 0x5e, 0x01, 0x3f, 0x1f, 0x6b, 0x33, 0x8a, 0x18,
	0x23, 0xec, 0x91, 0x60, 0xa2, 0xd0, 0xbf, 0x12, 0x4a, 0x1a, 0xa7, 0xeb, 0xaf, 0xc3, 0xf2, 0x54,
	0x4b, 0x98, 0xb2, 0xe6, 0x6f, 0x0a, 0xbc, 0x32, 0x5b, 0x2e, 0x0f, 0x27, 0xf1, 0x8e, 0x89, 0x67,
	0x74, 0x5d, 0x3f, 0x90, 0x3c, 0x20, 0x48, 0x0f, 0x5d, 0x3f, 0x40, 0x57, 0xa0, 0xd0, 0xf1, 0x06,
	0x96, 0x31, 0x70, 0xbd, 0x40, 0x1e, 0xa8, 0x3c, 0x23, 0x1c, 0xb8, 0x5e, 0x80, 0xee, 0xc0, 0x25,
	0x8f, 0x7c, 0x31, 0xa4, 0x1e, 0xb1, 0x8d, 0x13, 0xd7, 0x3b, 0x22, 0x9e, 0x71, 0x4c, 0x3c, 0x9f,
	0x19, 0x28, 0xf2, 0xf9, 0xe5, 0x70, 0xfb, 0x09, 0xdf, 0x7d, 0x2c, 0x36, 0xd1, 0x2e, 0x2c, 0xf6,
	0x5c, 0xcb, 0xec, 0x49, 0x26, 0x96, 0xe5, 0xe9, 0xb3, 0xdd, 0xd1, 0x60, 0x70, 0x21, 0x84, 0x55,
	0xa4, 0x52, 0x2f, 0x5e, 0xfb, 0xfa, 0x2f, 0x52, 0xf0, 0xd2, 0x0c, 0xe0, 0x73, 0x84, 0xec, 0x6d,
	0x40, 0x13, 0x91, 0x32, 0xa8, 0x2d, 0x6d, 0x51, 0xc7, 0x1b, 0x6d, 0x9d, 0x9f, 0x85, 0xae, 0xe9,
	0xd9, 0x27, 0xa6, 0x47, 0x18, 0x4c, 0x1c, 0x55, 0x08, 0x49, 0x75, 0x9b, 0x9d, 0x6e, 0xb3, 0x47,
	0xcd, 0xf0, 0xac, 0x8a, 0x05, 0xba, 0x0f, 0x0b, 0x36, 0x39, 0xa6, 0x16, 0xf1, 0x35, 0xe0, 0x76,
	0xaf, 0xce, 0xb7, 0x7b, 0x9b, 0x03, 0x71, 0xc8, 0xc0, 0x78, 0xdd, 0xf6, 0xe7, 0xc4, 0x0a, 0x7c,
	0xad, 0xf8, 0x34, 0xde, 0x7d, 0x0e, 0xc4, 0x21, 0x83, 0xbe, 0x16, 0x67, 0xc1, 0xb8, 0x3b, 0xa7,
	0x12, 0xe6, 0x0f, 0x0a, 0x94, 0xc7, 0x35, 0x98, 0xf2, 0xe5, 0x15, 0x28, 0x08, 0x9d, 0x98, 0xe5,
	0xc2, 0x93, 0x79, 0x41, 0xa8, 0xdb, 0xa8, 0xc6, 0x1c, 0xcd, 0x37, 0xd9, 0xa0, 0xc8, 0xfd, 0x57,
	0xbe, 0xf5, 0xc6, 0xd3, 0xac, 0x6c, 0x8d, 0x06, 0x04, 0x83, 0x1d, 0xfd, 0x4e, 0x16, 0xbb, 0xcc,
	0x78, 0xb1, 0x7b, 0x07, 0x5e, 0xb2, 0x4c, 0xc7, 0x30, 0x6d, 0xdb, 0xe8, 0x77, 0x8e, 0xdf, 0xbf,
	0x6d, 0xb0, 0x19, 0x63, 0xc0, 0x4f, 0x55, 0x1e, 0xab, 0x96, 0xe9, 0x54, 0x6c, 0x7b, 0x97, 0x6d,
	0xf0, 0x13, 0xae, 0xff, 0x3e, 0x61, 0x8f, 0xf0, 0xca, 0x2c, 0x7b, 0x84, 0x9f, 0x12, 0xf6, 0x08,
	0x82, 0xb0, 0x47, 0x6e, 0x9e, 0xcf, 0x1e, 0xf1, 0x0d, 0x61, 0x8f, 0x1b, 0xfd, 0x46, 0x3b, 0x50,
	0xb4, 0x5c, 0xc7, 0x21, 0x72, 0xac, 0x10, 0x49, 0xff, 0xc6, 0x59, 0x35, 0x20, 0x04, 0xe3, 0x24,
	0xa3, 0xfe, 0xfd, 0x14, 0xa0, 0x69, 0x0c, 0x52, 0x21, 0x7d, 0x44, 0x46, 0xd2, 0x26, 0xf6, 0x13,
	0xdd, 0x85, 0xcc, 0x80, 0x3a, 0xbe, 0x96, 0x9a, 0x37, 0x4e, 0x8e, 0x07, 0xe0, 0x80, 0x3a, 0x98,
	0x33, 0xa0, 0xef, 0x00, 0x9b, 0xcc, 0x0f, 0x69, 0x67, 0xe8, 0x89, 0x7a, 0x95, 0xe6, 0x12, 0xee,
	0x9e, 0x47, 0xd7, 0x8d, 0x6a, 0x92, 0xb3, 0xe6, 0x04, 0xde, 0x08, 0x8f, 0x4b, 0xbb, 0xfc, 0x11,
	0xa0, 0x69, 0xd0, 0x0c, 0xfd, 0x2f, 0x42, 0xf6, 0xd8, 0xec, 0x0d, 0x89, 0x0c, 0x88, 0x58, 0xdc,
	0x4f, 0xdd, 0x53, 0xf4, 0x1d, 0x58, 0x9e, 0xd2, 0x7d, 0x3c, 0x27, 0x95, 0x89, 0x9c, 0xbc, 0x08,
	0x59, 0xea, 0xd8, 0xe4, 0x94, 0xcb, 0x5a, 0xc4, 0x62, 0xa1, 0xff, 0x3b, 0x03, 0x59, 0x3e, 0x37,
	0x3e, 0x47, 0xb1, 0xb8, 0x02, 0x05, 0x71, 0x5b, 0x88, 0x6b, 0x44, 0x5e, 0x10, 0xea, 0xe3, 0xc3,
	0x50, 0xe6, 0x19, 0x86, 0xa1, 0xb7, 0x40, 0x3d, 0x31, 0x69, 0x60, 0x0c, 0x3c, 0xb7, 0x6d, 0xb6,
	0x69, 0x8f, 0x06, 0x23, 0x9e, 0xd6, 0x59, 0xbc, 0xc4, 0xe8, 0x07, 0x31, 0x19, 0xad, 0xc3, 0x72,
	0x9f, 0x3a, 0xbc, 0x5f, 0x73, 0x96, 0x80, 0xf6, 0x89, 0x56, 0x14, 0x58, 0xb9, 0xf1, 0xc4, 0xa4,
	0x41, 0x8b, 0xf6, 0x09, 0xc7, 0xca, 0xde, 0x1e, 0x63, 0x4b, 0x12, 0x2b, 0x36, 0x22, 0xec, 0xa7,
	0xa1, 0x0a, 0xc4, 0xeb, 0x53, 0xdf, 0xe7, 0xb9, 0xba, 0xc8, 0x4d, 0xf8, 0xdf, 0x99, 0x77, 0x9a,
	0x66, 0x60, 0x3a, 0xb6, 0xe9, 0xd9, 0x07, 0x1e, 0xb1, 0xa9, 0x65, 0x06, 0x44, 0xaa, 0x1a, 0xb3,
	0xb3, 0xd1, 0xc2, 0x23, 0xac, 0x35, 0x10, 0xc3, 0xa7, 0x36, 0xf1, 0xb5, 0x32, 0x3f, 0xa9, 0x25,
	0x49, 0x6c, 0x32, 0xda, 0xcc, 0xc9, 0x61, 0xe9, 0x79, 0x27, 0x07, 0x54, 0x83, 0x6b, 0x93, 0xd2,
	0x0c, 0xf1, 0x39, 0xea, 0x74, 0x0c, 0x7e, 0xb7, 0x53, 0xb9, 0x12, 0xaf, 0x4d, 0x70, 0xe2, 0x10,
	0xd4, 0x60, 0x37, 0xbb, 0xab, 0x00, 0xd4, 0x8f, 0xda, 0x36, 0xe2, 0x1c, 0x05, 0xea, 0x87, 0xfd,
	0xf3, 0x23, 0x79, 0x37, 0x91, 0x05, 0xe8, 0x25, 0xee, 0xa6, 0xa7, 0xde, 0x4d, 0x20, 0xbe, 0x9b,
	0xe8, 0x97, 0x21, 0x1f, 0xde, 0x78, 0xa6, 0xea, 0xf0, 0xb7, 0x01, 0x62, 0xc6, 0xaf, 0x39, 0x43,
	0xf5, 0x6b, 0xb0, 0x38, 0xa6, 0xd5, 0xd4, 0xd7, 0x7f, 0xa4, 0x40, 0x86, 0x5d, 0x8b, 0x5e, 0x90,
	0xa3, 0xa1, 0xbf, 0x0a, 0x0b, 0xf2, 0x96, 0x36, 0xa5, 0xea, 0xbf, 0x14, 0xc8, 0x87, 0x97, 0xb1,
	0x17, 0xe5, 0x24, 0x6f, 0x42, 0x96, 0x87, 0x99, 0x37, 0xff, 0xb3, 0x6f, 0xba, 0x02, 0x88, 0x36,
	0x21, 0xe7, 0x9f, 0xd0, 0xc0, 0xea, 0xf2, 0xdb, 0xc5, 0xcc, 0x57, 0x87, 0x26, 0xdf, 0xc7, 0x12,
	0xc7, 0xc6, 0xd8, 0xc4, 0x1d, 0x74, 0xca, 0x2d, 0xbf, 0x4d, 0x41, 0x4e, 0x70, 0x24, 0x7b, 0xa9,
	0x32, 0xde, 0x4b, 0xaf, 0x43, 0x89, 0x5d, 0xe2, 0x0f, 0x09, 0xb1, 0xd9, 0x45, 0x9e, 0xfb, 0x27,
	0x8f, 0x8b, 0x5d, 0xd3, 0xdf, 0x91, 0x24, 0x56, 0x94, 0xc2, 0x6d, 0x23, 0x94, 0x22, 0xdc, 0xb4,
	0x14, 0xd2, 0x2b, 0x52, 0xda, 0x9b, 0xb0, 0x24, 0x74, 0x33, 0xec, 0xb0, 0x77, 0x88, 0xdb, 0x55,
	0x59, 0x90, 0xb7, 0x25, 0x95, 0xdd, 0xbe, 0xa8, 0x73, 0x4c, 0xbc, 0x40, 0xbe, 0x16, 0xc8, 0x15,
	0x13, 0x20, 0x7e, 0xc5, 0x1a, 0xe5, 0x38, 0xa0, 0x2c, 0xc8, 0x91, 0x52, 0x7b, 0xb0, 0x4c, 0x1d,
	0x1a, 0x50, 0xb3, 0x97, 0xa8, 0x17, 0x0b, 0xf3, 0xea, 0x85, 0x70, 0x43, 0x7c, 0xc8, 0x55, 0xc9,
	0x1b, 0x17, 0x8c, 0x4b, 0xb0, 0x40, 0x7d, 0xa3, 0x47, 0x0e, 0x03, 0x2d, 0x2f, 0x35, 0xf2, 0x1b,
	0xe4, 0x30, 0xd0, 0xff, 0xac, 0x40, 0x4e, 0x5c, 0xd7, 0x5f, 0x94, 0xd4, 0xaa, 0xc2, 0x62, 0x9b,
	0x3a, 0xa6, 0x37, 0x32, 0xc4, 0xdb, 0x81, 0x4c, 0xb1, 0x95, 0x99, 0xed, 0xd9, 0xf4, 0x46, 0xf2,
	0xb1, 0xa1, 0xd4, 0x4e, 0xac, 0xf4, 0x2b, 0x50, 0x88, 0x1e, 0x21, 0xa6, 0x32, 0xe7, 0xd7, 0x0a,
	0x94, 0x92, 0xbc, 0x67, 0xe4, 0x4f, 0x15, 0x8a, 0x42, 0x0b, 0x31, 0x1c, 0xa5, 0x78, 0x04, 0xf4,
	0xb3, 0x55, 0x91, 0xa3, 0x51, 0xf4, 0x9b, 0x8d, 0xd2, 0xa6, 0x15, 0xd0, 0x63, 0x62, 0x04, 0xe4,
	0x34, 0x90, 0x8e, 0x02, 0x41, 0x6a, 0x91, 0xd3, 0x80, 0x75, 0x10, 0xea, 0x24, 0x21, 0x62, 0x22,
	0x2c, 0x85, 0x44, 0x06, 0xd2, 0xbf, 0xcc, 0x40, 0x96, 0x3f, 0x91, 0x7c, 0xdd, 0x81, 0xda, 0x80,
	0xcc, 0xa1, 0xe7, 0xf6, 0xe7, 0x07, 0xa9, 0xe6, 0xd8, 0x03, 0x97, 0x3a, 0x01, 0xe6, 0x38, 0xb4,
	0x0e, 0xa9, 0xc0, 0x9d, 0x7f, 0xf0, 0x23, 0x74, 0x2a, 0x70, 0x11, 0x06, 0x64, 0x79, 0xae, 0xcf,
	0xdb, 0x52, 0xfc, 0xe6, 0x94, 0x9b, 0x37, 0xb2, 0x85, 0xe7, 0xfd, 0x09, 0x0d, 0xba, 0xac, 0x0b,
	0x11, 0xbc, 0x1c, 0xb2, 0x7f, 0x1c, 0xbd, 0x40, 0xbd, 0x0b, 0x39, 0x72, 0x4c, 0x9c, 0xc0, 0xd7,
	0x16, 0xb8, 0x9c, 0xd7, 0xe6, 0x3c, 0x25, 0xd5, 0x18, 0x08, 0x4b, 0x2c, 0x1b, 0x91, 0xc4, 0xc5,
	0x5f, 0x0c, 0x1c, 0x62, 0x81, 0xde, 0x01, 0x64, 0x75, 0x5d, 0xd7, 0x27, 0x63, 0x33, 0x89, 0x98,
	0x33, 0x96, 0xc5, 0x4e, 0x72, 0x2a, 0x79, 0x08, 0xc5, 0xe4, 0xe0, 0x50, 0x7a, 0xa6, 0xc1, 0x21,
	0xc9, 0xca, 0x2a, 0x84, 0xd5, 0x73, 0x7d, 0x62, 0xf3, 0xe9, 0x23, 0x8f, 0xe5, 0x8a, 0x3f, 0x65,
	0x98, 0xa7, 0x71, 0x7d, 0x29, 0xcb, 0xa7, 0x0c, 0xf3, 0x34, 0x2c, 0x2e, 0xac, 0xa9, 0x86, 0x4f,
	0x65, 0x53, 0xa9, 0xfd, 0x2b, 0x05, 0xf2, 0x61, 0x00, 0xe2, 0x22, 0xad, 0x9c, 0xb7, 0x48, 0xbf,
	0x03, 0x19, 0x62, 0x77, 0x88, 0x7c, 0xe1, 0x3a, 0xe3, 0x25, 0x91, 0xc3, 0xd0, 0x7d, 0x10, 0xcd,
	0x9e, 0xcf, 0x3d, 0xf2, 0xe6, 0x70, 0x65, 0xce, 0x57, 0xd8, 0x18, 0x84, 0x0b, 0xed, 0xf0, 0xa7,
	0xfe, 0x53, 0x05, 0x96, 0xa7, 0xc2, 0x8d, 0xde, 0x87, 0x7c, 0x98, 0x26, 0x52, 0xeb, 0xa7, 0xbc,
	0x4c, 0x46, 0x70, 0xb4, 0x0d, 0x25, 0x59, 0x9c, 0xd9, 0x40, 0x43, 0xe4, 0x2b, 0xc4, 0xdc, 0x6a,
	0x19, 0xa7, 0x58, 0x51, 0xb0, 0xf1, 0x85, 0x8e, 0x61, 0x69, 0x62, 0x1f, 0x7d, 0x08, 0x85, 0xb8,
	0x06, 0x2b, 0xe7, 0xad, 0xc1, 0x31, 0x8f, 0xfe, 0x03, 0x05, 0x20, 0xce, 0x48, 0x74, 0x1b, 0x72,
	0xe2, 0xa9, 0x52, 0x5a, 0x78, 0xe6, 0xab, 0xa6, 0x84, 0xa2, 0x2d, 0x28, 0xb4, 0x49, 0xd7, 0x3c,
	0xa6, 0xae, 0x17, 0x5e, 0x79, 0xde, 0x38, 0x2b, 0xef, 0xb7, 0x24, 0x18, 0xc7, 0x6c, 0xfa, 0x3f,
	0x15, 0x40, 0xd3, 0x08, 0xf4, 0xff, 0x00, 0xe6, 0x60, 0xd0, 0xa3, 0xc4, 0x37, 0x02, 0x57, 0xea,
	0xb4, 0x32, 0x33, 0xa7, 0xe3, 0x5c, 0x2e, 0x48, 0x8e, 0x96, 0x8b, 0x3e, 0x81, 0x32, 0x77, 0xb8,
	0x11, 0x7e, 0x48, 0x56, 0xc9, 0x79, 0xea, 0x71, 0xa7, 0x46, 0xea, 0x2d, 0xfa, 0xc9, 0x25, 0xaa,
	0x43, 0x59, 0xbc, 0xc0, 0x45, 0xc2, 0xd2, 0xf3, 0x4a, 0x2e, 0x3b, 0x63, 0x0c, 0x9a, 0x10, 0x95,
	0x5c, 0xea, 0x7f, 0x64, 0xf3, 0x81, 0x70, 0xde, 0x0b, 0xd2, 0xd9, 0xe6, 0xbf, 0x6f, 0x46, 0x27,
	0x35, 0x77, 0xfe, 0x93, 0x9a, 0xf5, 0xbb, 0xe6, 0x80, 0xc8, 0xa1, 0xe0, 0xd2, 0x8c, 0x1c, 0x62,
	0xdb, 0x58, 0xa0, 0x12, 0x4d, 0x55, 0xa6, 0x5e, 0xfe, 0xec, 0xa6, 0x2a, 0x13, 0x50, 0x36, 0x55,
	0xb1, 0x62, 0x4d, 0x35, 0x4a, 0xcc, 0xa9, 0xca, 0x53, 0x0e, 0x7b, 0xaa, 0x04, 0xff, 0x44, 0x81,
	0x9c, 0x78, 0x65, 0x7f, 0x51, 0x46, 0x6c, 0xa6, 0x7e, 0xf8, 0xec, 0x3f, 0xa5, 0xfe, 0xcf, 0xd3,
	0x50, 0x4a, 0x66, 0x38, 0xba, 0x0d, 0x69, 0xd3, 0xb1, 0xe5, 0x71, 0xb8, 0x3e, 0x33, 0xfd, 0x2a,
	0x4e, 0xa2, 0xba, 0x33, 0x34, 0xda, 0x84, 0x94, 0xcc, 0xff, 0x99, 0x8f, 0x57, 0x0d, 0xd7, 0xda,
	0xf7, 0x62, 0x96, 0x94, 0xeb, 0xa1, 0x0f, 0x20, 0x47, 0xbe, 0x18, 0x9a, 0x3d, 0x31, 0x73, 0xce,
	0x3c, 0xd4, 0x0d, 0xd7, 0xaa, 0x71, 0x48, 0xcc, 0x29, 0x79, 0xd0, 0x87, 0x90, 0x15, 0x77, 0x33,
	0xe1, 0x87, 0xb7, 0xe6, 0xff, 0x59, 0x6e, 0x52, 0x82, 0xe0, 0x43, 0xdf, 0x05, 0x64, 0x99, 0xce,
	0xc4, 0x7d, 0x53, 0xf6, 0xf6, 0xcd, 0x99, 0xd2, 0xaa, 0x53, 0xf0, 0x58, 0xe8, 0x0c, 0x59, 0x68,
	0x0b, 0xf2, 0xbe, 0x6c, 0x85, 0x32, 0xbb, 0xcf, 0xdb, 0x2f, 0x23, 0x3e, 0xfd, 0x53, 0x58, 0x9a,
	0x70, 0x37, 0xfa, 0x06, 0xc0, 0x20, 0x5c, 0xb0, 0xa9, 0x2d, 0x7d, 0x8e, 0xa2, 0x95, 0xe0, 0xd0,
	0x0f, 0xa0, 0x3c, 0x1e, 0x8d, 0xff, 0x5a, 0xe2, 0x47, 0x80, 0xa6, 0x23, 0x85, 0xd6, 0x21, 0xdd,
	0x73, 0x2d, 0x99, 0x46, 0xf3, 0xff, 0xd2, 0xca, 0x40, 0xfa, 0x1e, 0x5c, 0x9a, 0x13, 0x2e, 0x74,
	0x3b, 0x0c, 0xf4, 0xdc, 0xa6, 0x98, 0xfc, 0xfb, 0xab, 0xc0, 0xea, 0xab, 0xb0, 0x72, 0x76, 0xc0,
	0xf4, 0x1f, 0x2b, 0x70, 0x71, 0x96, 0xef, 0xd1, 0x7d, 0xc8, 0x53, 0xc7, 0xea, 0x0d, 0xed, 0x73,
	0xbb, 0x22, 0xc2, 0x33, 0x5e, 0x72, 0x2a, 0x79, 0x53, 0xe7, 0xe3, 0x0d, 0xf1, 0xeb, 0x6f, 0xc2,
	0xd2, 0x64, 0x02, 0x15, 0x20, 0x5b, 0x69, 0x34, 0xf6, 0x9f, 0xa8, 0x17, 0xf8, 0xcf, 0xc7, 0xfb,
	0xf5, 0x6d, 0x55, 0x59, 0xff, 0x38, 0x7e, 0x25, 0x8c, 0x1f, 0x58, 0x51, 0x09, 0xf2, 0xbb, 0xd5,
	0x83, 0x5b, 0xb7, 0x37, 0x37, 0xef, 0xa9, 0x17, 0xe2, 0xd5, 0xcd, 0xbb, 0xaa, 0x82, 0x8a, 0xb0,
	0x70, 0x50, 0xad, 0xbc, 0x7f, 0xe7, 0xde, 0x7b, 0x6a, 0x4a, 0x2c, 0x76, 0xee, 0xbd, 0x77, 0xf7,
	0x5d, 0x35, 0xbd, 0xde, 0x8f, 0x65, 0xc5, 0x8f, 0x9b, 0x48, 0x85, 0xd2, 0x56, 0x7d, 0xaf, 0x82,
	0x3f, 0x6b, 0xd6, 0xf6, 0x9a, 0xfb, 0x58, 0xbd, 0x10, 0x53, 0xf6, 0x1f, 0xb5, 0x0e, 0x1e, 0xb5,
	0x54, 0x05, 0x2d, 0x41, 0xb1, 0x59, 0xc3, 0x8f, 0xf7, 0x9b, 0x4f, 0xea, 0xad, 0xea, 0x43, 0x35,
	0xc5, 0x08, 0xb8, 0xd6, 0xa8, 0x7c, 0x26, 0x09, 0x69, 0xb4, 0x0c, 0x8b, 0x2d, 0x5c, 0xa9, 0x7e,
	0x52, 0xdf, 0x7b, 0x5c, 0xc3, 0xad, 0x1a, 0x56, 0x33, 0xeb, 0x6b, 0xe1, 0x88, 0x11, 0xdb, 0x58,
	0x82, 0x7c, 0xb3, 0x85, 0x2b, 0xf5, 0x07, 0x0f, 0x5b, 0xea, 0x05, 0xb4, 0x00, 0xe9, 0xfd, 0x9d,
	0x1d, 0x55, 0x59, 0xbf, 0x0f, 0xea, 0xe4, 0xc5, 0x82, 0x7d, 0x61, 0x6b, 0xbf, 0x65, 0x6c, 0xd7,
	0x76, 0x2a, 0x8f, 0x1a, 0x0c, 0xfd, 0x32, 0x2c, 0x33, 0xc2, 0xf8, 0x57, 0x94, 0xf5, 0x55, 0x28,
	0x44, 0x73, 0x17, 0x73, 0xdc, 0x0e, 0xde, 0xdf, 0x63, 0xf0, 0x3c, 0x64, 0xb6, 0x2a, 0xd5, 0x4f,
	0x54, 0x65, 0x7d, 0x47, 0x4e, 0x03, 0x63, 0x0d, 0x99, 0x19, 0x89, 0x9b, 0x5b, 0xc6, 0xde, 0x7e,
	0xf5, 0x61, 0x65, 0xef, 0x41, 0x4d, 0xbd, 0x80, 0x16, 0xa1, 0xc0, 0x28, 0xb5, 0x3d, 0x2e, 0x98,
	0x9b, 0xd8, 0xdc, 0x32, 0x70, 0xad, 0x52, 0x7d, 0x58, 0xdb, 0x56, 0x53, 0xeb, 0x1d, 0x50, 0x27,
	0x7b, 0x31, 0x03, 0x35, 0x9a, 0x5b, 0x09, 0x2d, 0x55, 0x28, 0x35, 0x92, 0x62, 0x15, 0x54, 0x06,
	0x60, 0x94, 0xdd, 0xda, 0x76, 0xfd, 0xd1, 0xae, 0x70, 0x1d, 0x5f, 0xd7, 0xf7, 0xea, 0xbb, 0x8f,
	0x76, 0xd5, 0x74, 0x44, 0xa8, 0x7c, 0x93, 0x13, 0x32, 0xeb, 0xf7, 0x21, 0xcb, 0x9b, 0x1a, 0x02,
	0xc8, 0x55, 0xeb, 0xb8, 0xda, 0xa8, 0x89, 0x20, 0xb7, 0x70, 0xbd, 0xb2, 0xf7, 0xa0, 0xc1, 0x84,
	0x02, 0xe4, 0x9a, 0x9f, 0x3e, 0xaa, 0xe0, 0x9a, 0x88, 0xf1, 0x76, 0xbd, 0xb2, 0xbb, 0xbf, 0xb7,
	0xad, 0xa6, 0xb7, 0xaa, 0xbf, 0xfb, 0x6a, 0x45, 0xf9, 0xd3, 0x57, 0x2b, 0xca, 0xdf, 0xbf, 0x5a,
	0x51, 0x7e, 0xf6, 0x8f, 0x95, 0x0b, 0xdf, 0xba, 0xd9, 0xa1, 0x41, 0x77, 0xd8, 0xde, 0xb0, 0xdc,
	0xfe, 0x8d, 0xb1, 0xf4, 0xbc, 0xc1, 0x93, 0x01, 0x87, 0xab, 0xc1, 0x51, 0xe7, 0x86, 0x39, 0xa0,
	0x37, 0x8e, 0x6f, 0xb6, 0x73, 0xfc, 0x9f, 0x42, 0x6e, 0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0xb7,
	0x13, 0x93, 0xf2, 0x2c, 0x22, 0x00, 0x00,
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContentBase64) > 0 {
		i -= len(m.ContentBase64)
		copy(dAtA[i:], m.ContentBase64)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ContentBase64)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Railway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Railway) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Railway) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CommandStations) > 0 {
		for iNdEx := len(m.CommandStations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommandStations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.LocGroups) > 0 {
		for iNdEx := len(m.LocGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Locs) > 0 {
		for iNdEx := len(m.Locs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Modules) > 0 {
		for iNdEx := len(m.Modules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Modules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Dirty {
		i--
		if m.Dirty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Module) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Module) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Module) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signals) > 0 {
		for iNdEx := len(m.Signals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.Sensors) > 0 {
		for iNdEx := len(m.Sensors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sensors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Junctions) > 0 {
		for iNdEx := len(m.Junctions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Junctions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.Edges) > 0 {
		for iNdEx := len(m.Edges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Edges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.BlockGroups) > 0 {
		for iNdEx := len(m.BlockGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.HasBackgroundImage {
		i--
		if m.HasBackgroundImage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Height != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if m.Width != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModuleRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ZoomFactor != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ZoomFactor))
		i--
		dAtA[i] = 0x18
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Layer) > 0 {
		i -= len(m.Layer)
		copy(dAtA[i:], m.Layer)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Layer)))
		i--
		dAtA[i] = 0x32
	}
	if m.Rotation != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Rotation))
		i--
		dAtA[i] = 0x28
	}
	if m.Height != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if m.Width != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Loc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Loc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Loc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangeDirection != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ChangeDirection))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.SpeedSteps != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SpeedSteps))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if m.MaximumSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MaximumSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.MediumSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MediumSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.SlowSpeed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SlowSpeed))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Remarks) > 0 {
		i -= len(m.Remarks)
		copy(dAtA[i:], m.Remarks)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Remarks)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocGroupRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocGroupRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocGroupRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandStation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandStation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinkynetCommandStation != nil {
		{
			size, err := m.BinkynetCommandStation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandStationRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStationRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandStationRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetCommandStation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetCommandStation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetCommandStation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LocalWorkers) > 0 {
		for iNdEx := len(m.LocalWorkers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalWorkers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RequiredWorkerVersion) > 0 {
		i -= len(m.RequiredWorkerVersion)
		copy(dAtA[i:], m.RequiredWorkerVersion)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.RequiredWorkerVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GrpcPort != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.GrpcPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ServerHost) > 0 {
		i -= len(m.ServerHost)
		copy(dAtA[i:], m.ServerHost)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ServerHost)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetLocalWorker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetLocalWorker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetLocalWorker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Alias) > 0 {
		i -= len(m.Alias)
		copy(dAtA[i:], m.Alias)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Alias)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HardwareId) > 0 {
		i -= len(m.HardwareId)
		copy(dAtA[i:], m.HardwareId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.HardwareId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CommandStationId) > 0 {
		i -= len(m.CommandStationId)
		copy(dAtA[i:], m.CommandStationId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.CommandStationId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetLocalWorkerRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetLocalWorkerRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetLocalWorkerRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CanAddMgv93Group {
		i--
		if m.CanAddMgv93Group {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if m.DeviceType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.DeviceType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Connections) > 0 {
		for iNdEx := len(m.Connections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Connections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ObjectType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ObjectType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ObjectId) > 0 {
		i -= len(m.ObjectId)
		copy(dAtA[i:], m.ObjectId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ObjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetConnection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetConnection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetConnection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Configuration) > 0 {
		for k := range m.Configuration {
			v := m.Configuration[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBrModelTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBrModelTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Pins) > 0 {
		for iNdEx := len(m.Pins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinkyNetDevicePin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinkyNetDevicePin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinkyNetDevicePin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockGroup != nil {
		{
			size, err := m.BlockGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.IsStation {
		i--
		if m.IsStation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ChangeDirectionReversingLocs {
		i--
		if m.ChangeDirectionReversingLocs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ChangeDirection != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ChangeDirection))
		i--
		dAtA[i] = 0x78
	}
	if m.ReverseSides {
		i--
		if m.ReverseSides {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.WaitPermissions != nil {
		{
			size, err := m.WaitPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.MaximumWaitTime != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MaximumWaitTime))
		i--
		dAtA[i] = 0x60
	}
	if m.MinimumWaitTime != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MinimumWaitTime))
		i--
		dAtA[i] = 0x58
	}
	if m.WaitProbability != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.WaitProbability))
		i--
		dAtA[i] = 0x50
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockGroupRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockGroupRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockGroupRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Edge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Edge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Edge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EdgeRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Junction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Junction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Junction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Switch != nil {
		{
			size, err := m.Switch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JunctionRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunctionRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JunctionRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Switch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Switch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Switch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsLeft {
		i--
		if m.IsLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.InitialDirection != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.InitialDirection))
		i--
		dAtA[i] = 0x38
	}
	if m.InvertFeedback {
		i--
		if m.InvertFeedback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Invert {
		i--
		if m.Invert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SwitchDuration != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SwitchDuration))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FeedbackAddress) > 0 {
		i -= len(m.FeedbackAddress)
		copy(dAtA[i:], m.FeedbackAddress)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.FeedbackAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.HasFeedback {
		i--
		if m.HasFeedback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinaryOutput != nil {
		{
			size, err := m.BinaryOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OutputRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InactiveText) > 0 {
		i -= len(m.InactiveText)
		copy(dAtA[i:], m.InactiveText)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.InactiveText)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ActiveText) > 0 {
		i -= len(m.ActiveText)
		copy(dAtA[i:], m.ActiveText)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ActiveText)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OutputType != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxDuration != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.MaxDuration))
		i--
		dAtA[i] = 0x70
	}
	if m.Closed {
		i--
		if m.Closed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Permissions != nil {
		{
			size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ChooseProbability != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.ChooseProbability))
		i--
		dAtA[i] = 0x58
	}
	if m.Speed != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CrossingJunctions) > 0 {
		for iNdEx := len(m.CrossingJunctions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CrossingJunctions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockSide != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.BlockSide))
		i--
		dAtA[i] = 0x18
	}
	if m.Edge != nil {
		{
			size, err := m.Edge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JunctionWithState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunctionWithState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JunctionWithState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SwitchState != nil {
		{
			size, err := m.SwitchState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Junction != nil {
		{
			size, err := m.Junction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwitchWithState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWithState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchWithState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Direction != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Behaviors) > 0 {
		for iNdEx := len(m.Behaviors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Behaviors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Sensor != nil {
		{
			size, err := m.Sensor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteEventBehavior) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteEventBehavior) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteEventBehavior) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SpeedBehavior != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.SpeedBehavior))
		i--
		dAtA[i] = 0x18
	}
	if m.StateBehavior != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.StateBehavior))
		i--
		dAtA[i] = 0x10
	}
	if m.AppliesTo != nil {
		{
			size, err := m.AppliesTo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinarySensor != nil {
		{
			size, err := m.BinarySensor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Shape != 0 {
		i = encodeVarintBrModelTypes(dAtA, i, uint64(m.Shape))
		i--
		dAtA[i] = 0x38
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SensorRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinarySensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinarySensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinarySensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Signal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModuleId) > 0 {
		i -= len(m.ModuleId)
		copy(dAtA[i:], m.ModuleId)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.ModuleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignalRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrModelTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Standard != nil {
		{
			size, err := m.Standard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CanChangeDirection != nil {
		{
			size, err := m.CanChangeDirection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Equals != nil {
		{
			size, err := m.Equals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Or != nil {
		{
			size, err := m.Or.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.And != nil {
		{
			size, err := m.And.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocAndPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocAndPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocAndPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Predicates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocOrPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocOrPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocOrPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Predicates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocEqualsPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocEqualsPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocEqualsPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Loc != nil {
		{
			size, err := m.Loc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocGroupEqualsPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocGroupEqualsPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocGroupEqualsPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocCanChangeDirectionPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocCanChangeDirectionPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocCanChangeDirectionPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *LocStandardPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocStandardPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocStandardPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Excludes) > 0 {
		for iNdEx := len(m.Excludes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Excludes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Includes) > 0 {
		for iNdEx := len(m.Includes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Includes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrModelTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBrModelTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovBrModelTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentBase64)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Railway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Dirty {
		n += 2
	}
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Locs) > 0 {
		for _, e := range m.Locs {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.LocGroups) > 0 {
		for _, e := range m.LocGroups {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.CommandStations) > 0 {
		for _, e := range m.CommandStations {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Module) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Height))
	}
	if m.HasBackgroundImage {
		n += 2
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.BlockGroups) > 0 {
		for _, e := range m.BlockGroups {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Junctions) > 0 {
		for _, e := range m.Junctions {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Sensors) > 0 {
		for _, e := range m.Sensors {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Signals) > 0 {
		for _, e := range m.Signals {
			l = e.Size()
			n += 2 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModuleRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.ZoomFactor != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ZoomFactor))
	}
	if m.Locked {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovBrModelTypes(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Y))
	}
	if m.Width != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Height))
	}
	if m.Rotation != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Rotation))
	}
	l = len(m.Layer)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Loc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Remarks)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.SlowSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.SlowSpeed))
	}
	if m.MediumSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.MediumSpeed))
	}
	if m.MaximumSpeed != 0 {
		n += 2 + sovBrModelTypes(uint64(m.MaximumSpeed))
	}
	if m.SpeedSteps != 0 {
		n += 2 + sovBrModelTypes(uint64(m.SpeedSteps))
	}
	if m.ChangeDirection != 0 {
		n += 2 + sovBrModelTypes(uint64(m.ChangeDirection))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocGroupRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandStation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BinkynetCommandStation != nil {
		l = m.BinkynetCommandStation.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandStationRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetCommandStation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerHost)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.GrpcPort != 0 {
		n += 1 + sovBrModelTypes(uint64(m.GrpcPort))
	}
	l = len(m.RequiredWorkerVersion)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.LocalWorkers) > 0 {
		for _, e := range m.LocalWorkers {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetLocalWorker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.CommandStationId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.HardwareId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetLocalWorkerRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.DeviceType != 0 {
		n += 1 + sovBrModelTypes(uint64(m.DeviceType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.CanAddMgv93Group {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.ObjectType != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ObjectType))
	}
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetConnection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.Pins) > 0 {
		for _, e := range m.Pins {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Configuration) > 0 {
		for k, v := range m.Configuration {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBrModelTypes(uint64(len(k))) + 1 + len(v) + sovBrModelTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovBrModelTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinkyNetDevicePin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.WaitProbability != 0 {
		n += 1 + sovBrModelTypes(uint64(m.WaitProbability))
	}
	if m.MinimumWaitTime != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MinimumWaitTime))
	}
	if m.MaximumWaitTime != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MaximumWaitTime))
	}
	if m.WaitPermissions != nil {
		l = m.WaitPermissions.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.ReverseSides {
		n += 2
	}
	if m.ChangeDirection != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ChangeDirection))
	}
	if m.ChangeDirectionReversingLocs {
		n += 3
	}
	if m.IsStation {
		n += 3
	}
	if m.BlockGroup != nil {
		l = m.BlockGroup.Size()
		n += 2 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockGroupRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Edge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EdgeRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Junction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Switch != nil {
		l = m.Switch.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JunctionRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Switch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.HasFeedback {
		n += 2
	}
	l = len(m.FeedbackAddress)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.SwitchDuration != 0 {
		n += 1 + sovBrModelTypes(uint64(m.SwitchDuration))
	}
	if m.Invert {
		n += 2
	}
	if m.InvertFeedback {
		n += 2
	}
	if m.InitialDirection != 0 {
		n += 1 + sovBrModelTypes(uint64(m.InitialDirection))
	}
	if m.IsLeft {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BinaryOutput != nil {
		l = m.BinaryOutput.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OutputRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinaryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.OutputType != 0 {
		n += 1 + sovBrModelTypes(uint64(m.OutputType))
	}
	l = len(m.ActiveText)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.InactiveText)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.CrossingJunctions) > 0 {
		for _, e := range m.CrossingJunctions {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.Speed != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Speed))
	}
	if m.ChooseProbability != 0 {
		n += 1 + sovBrModelTypes(uint64(m.ChooseProbability))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Closed {
		n += 2
	}
	if m.MaxDuration != 0 {
		n += 1 + sovBrModelTypes(uint64(m.MaxDuration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Edge != nil {
		l = m.Edge.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.BlockSide != 0 {
		n += 1 + sovBrModelTypes(uint64(m.BlockSide))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JunctionWithState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Junction != nil {
		l = m.Junction.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.SwitchState != nil {
		l = m.SwitchState.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwitchWithState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Direction))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sensor != nil {
		l = m.Sensor.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if len(m.Behaviors) > 0 {
		for _, e := range m.Behaviors {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteEventBehavior) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppliesTo != nil {
		l = m.AppliesTo.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.StateBehavior != 0 {
		n += 1 + sovBrModelTypes(uint64(m.StateBehavior))
	}
	if m.SpeedBehavior != 0 {
		n += 1 + sovBrModelTypes(uint64(m.SpeedBehavior))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Shape != 0 {
		n += 1 + sovBrModelTypes(uint64(m.Shape))
	}
	if m.BinarySensor != nil {
		l = m.BinarySensor.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinarySensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Signal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.And != nil {
		l = m.And.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Or != nil {
		l = m.Or.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Equals != nil {
		l = m.Equals.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.CanChangeDirection != nil {
		l = m.CanChangeDirection.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.Standard != nil {
		l = m.Standard.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocAndPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for _, e := range m.Predicates {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocOrPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for _, e := range m.Predicates {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocEqualsPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Loc != nil {
		l = m.Loc.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocGroupEqualsPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovBrModelTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocCanChangeDirectionPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocStandardPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Includes) > 0 {
		for _, e := range m.Includes {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if len(m.Excludes) > 0 {
		for _, e := range m.Excludes {
			l = e.Size()
			n += 1 + l + sovBrModelTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBrModelTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBrModelTypes(x uint64) (n int) {
	return sovBrModelTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentBase64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentBase64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Railway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Railway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Railway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dirty = bool(v != 0)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modules = append(m.Modules, &ModuleRef{})
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locs = append(m.Locs, &LocRef{})
			if err := m.Locs[len(m.Locs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocGroups = append(m.LocGroups, &LocGroupRef{})
			if err := m.LocGroups[len(m.LocGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandStations = append(m.CommandStations, &CommandStationRef{})
			if err := m.CommandStations[len(m.CommandStations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Module) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Module: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Module: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasBackgroundImage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasBackgroundImage = bool(v != 0)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockRef{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockGroups = append(m.BlockGroups, &BlockGroupRef{})
			if err := m.BlockGroups[len(m.BlockGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &EdgeRef{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Junctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Junctions = append(m.Junctions, &JunctionRef{})
			if err := m.Junctions[len(m.Junctions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &OutputRef{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteRef{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sensors = append(m.Sensors, &SensorRef{})
			if err := m.Sensors[len(m.Sensors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signals = append(m.Signals, &SignalRef{})
			if err := m.Signals[len(m.Signals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoomFactor", wireType)
			}
			m.ZoomFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZoomFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			m.Rotation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Loc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Loc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Loc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remarks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remarks = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowSpeed", wireType)
			}
			m.SlowSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlowSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediumSpeed", wireType)
			}
			m.MediumSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediumSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumSpeed", wireType)
			}
			m.MaximumSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedSteps", wireType)
			}
			m.SpeedSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedSteps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDirection", wireType)
			}
			m.ChangeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeDirection |= ChangeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocGroupRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocGroupRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocGroupRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinkynetCommandStation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinkynetCommandStation == nil {
				m.BinkynetCommandStation = &BinkyNetCommandStation{}
			}
			if err := m.BinkynetCommandStation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStationRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStationRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStationRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetCommandStation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetCommandStation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetCommandStation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcPort", wireType)
			}
			m.GrpcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredWorkerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredWorkerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalWorkers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalWorkers = append(m.LocalWorkers, &BinkyNetLocalWorkerRef{})
			if err := m.LocalWorkers[len(m.LocalWorkers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetLocalWorker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetLocalWorker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetLocalWorker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandStationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &BinkyNetDevice{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &BinkyNetObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetLocalWorkerRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetLocalWorkerRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetLocalWorkerRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= BinkyNetDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddMgv93Group", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAddMgv93Group = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			m.ObjectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectType |= BinkyNetObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &BinkyNetConnection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetConnection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetConnection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetConnection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pins = append(m.Pins, &BinkyNetDevicePin{})
			if err := m.Pins[len(m.Pins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBrModelTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrModelTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrModelTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBrModelTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBrModelTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Configuration[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinkyNetDevicePin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinkyNetDevicePin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinkyNetDevicePin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitProbability", wireType)
			}
			m.WaitProbability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitProbability |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumWaitTime", wireType)
			}
			m.MinimumWaitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumWaitTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumWaitTime", wireType)
			}
			m.MaximumWaitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumWaitTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WaitPermissions == nil {
				m.WaitPermissions = &LocStandardPredicate{}
			}
			if err := m.WaitPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseSides", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReverseSides = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDirection", wireType)
			}
			m.ChangeDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeDirection |= ChangeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDirectionReversingLocs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeDirectionReversingLocs = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStation = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockGroup == nil {
				m.BlockGroup = &BlockGroupRef{}
			}
			if err := m.BlockGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockGroupRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockGroupRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockGroupRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Edge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Junction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Junction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Junction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockRef{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Switch == nil {
				m.Switch = &Switch{}
			}
			if err := m.Switch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunctionRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunctionRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunctionRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Switch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFeedback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFeedback = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedbackAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedbackAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchDuration", wireType)
			}
			m.SwitchDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchDuration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Invert = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertFeedback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertFeedback = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialDirection", wireType)
			}
			m.InitialDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialDirection |= SwitchDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeft = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinaryOutput == nil {
				m.BinaryOutput = &BinaryOutput{}
			}
			if err := m.BinaryOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= BinaryOutputType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InactiveText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Endpoint{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Endpoint{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossingJunctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossingJunctions = append(m.CrossingJunctions, &JunctionWithState{})
			if err := m.CrossingJunctions[len(m.CrossingJunctions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &RouteEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChooseProbability", wireType)
			}
			m.ChooseProbability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChooseProbability |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &LocStandardPredicate{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Closed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Closed = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			m.MaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDuration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockRef{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Edge == nil {
				m.Edge = &EdgeRef{}
			}
			if err := m.Edge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSide", wireType)
			}
			m.BlockSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSide |= BlockSide(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunctionWithState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunctionWithState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunctionWithState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Junction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Junction == nil {
				m.Junction = &JunctionRef{}
			}
			if err := m.Junction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwitchState == nil {
				m.SwitchState = &SwitchWithState{}
			}
			if err := m.SwitchState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWithState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWithState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWithState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= SwitchDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sensor == nil {
				m.Sensor = &SensorRef{}
			}
			if err := m.Sensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Behaviors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Behaviors = append(m.Behaviors, &RouteEventBehavior{})
			if err := m.Behaviors[len(m.Behaviors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteEventBehavior) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteEventBehavior: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteEventBehavior: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliesTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppliesTo == nil {
				m.AppliesTo = &LocPredicate{}
			}
			if err := m.AppliesTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateBehavior", wireType)
			}
			m.StateBehavior = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StateBehavior |= RouteStateBehavior(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedBehavior", wireType)
			}
			m.SpeedBehavior = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedBehavior |= LocSpeedBehavior(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockRef{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			m.Shape = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shape |= Shape(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinarySensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinarySensor == nil {
				m.BinarySensor = &BinarySensor{}
			}
			if err := m.BinarySensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinarySensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinarySensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinarySensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignalRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignalRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignalRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field And", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.And == nil {
				m.And = &LocAndPredicate{}
			}
			if err := m.And.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Or", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Or == nil {
				m.Or = &LocOrPredicate{}
			}
			if err := m.Or.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equals == nil {
				m.Equals = &LocEqualsPredicate{}
			}
			if err := m.Equals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &LocGroupEqualsPredicate{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeDirection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CanChangeDirection == nil {
				m.CanChangeDirection = &LocCanChangeDirectionPredicate{}
			}
			if err := m.CanChangeDirection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Standard == nil {
				m.Standard = &LocStandardPredicate{}
			}
			if err := m.Standard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocAndPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocAndPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocAndPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, &LocPredicate{})
			if err := m.Predicates[len(m.Predicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocOrPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocOrPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocOrPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, &LocPredicate{})
			if err := m.Predicates[len(m.Predicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocEqualsPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocEqualsPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocEqualsPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Loc == nil {
				m.Loc = &LocRef{}
			}
			if err := m.Loc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocGroupEqualsPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocGroupEqualsPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocGroupEqualsPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &LocGroupRef{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocCanChangeDirectionPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocCanChangeDirectionPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocCanChangeDirectionPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocStandardPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocStandardPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocStandardPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Includes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Includes = append(m.Includes, &LocPredicate{})
			if err := m.Includes[len(m.Includes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Excludes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Excludes = append(m.Excludes, &LocPredicate{})
			if err := m.Excludes[len(m.Excludes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrModelTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrModelTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrModelTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrModelTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrModelTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBrModelTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBrModelTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBrModelTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBrModelTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrModelTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBrModelTypes = fmt.Errorf("proto: unexpected end of group")
)
