// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: br_state_types.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Direction of a loc
type LocDirection int32

const (
	LocDirection_FORWARD LocDirection = 0
	LocDirection_REVERSE LocDirection = 1
)

var LocDirection_name = map[int32]string{
	0: "FORWARD",
	1: "REVERSE",
}

var LocDirection_value = map[string]int32{
	"FORWARD": 0,
	"REVERSE": 1,
}

func (x LocDirection) String() string {
	return proto.EnumName(LocDirection_name, int32(x))
}

func (LocDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{0}
}

type AutoLocState int32

const (
	// Loc has not been assigned a route, but is ready to be assigned and run that
	// route. If the loc is no longer is automatic mode, it will be removed from
	// the automatic loc controller. If no suitable route can be found, the loc
	// will stay in this state. When the loc has been assigned a route, the route
	// will be prepared and the state will change to <see
	// cref="WaitingForAssignedRouteReady"/>.
	AutoLocState_ASSIGNROUTE AutoLocState = 0
	// The loc that was reversing is changing direction back to normal.
	// Once the direction is consistent, the state will change to <see
	// cref="AssignRoute"/>.
	AutoLocState_REVERSINGWAITINGFORDIRECTIONCHANGE AutoLocState = 1
	// The loc has been assigned a route and it waiting for this route to
	// become ready. Typically all junctions in the route will be set in the
	// correct position now. When the route is ready, the state will change to
	// <see cref="Running"/>.
	AutoLocState_WAITINGFORASSIGNEDROUTEREADY AutoLocState = 2
	// The loc is running the assigned route.
	// The state of the loc will not change until a sensor trigger is
	// received.
	AutoLocState_RUNNING AutoLocState = 3
	// The loc has triggered one of the 'entering destination' sensors of the
	// assigned route. No changes are made to the loc state when switching to
	// this state.
	AutoLocState_ENTERSENSORACTIVATED AutoLocState = 4
	// The loc has triggered one of the 'entering destination' sensors of the
	// assigned route. The state of the loc will not change until a 'reached
	// destination' sensor trigger is received.
	AutoLocState_ENTERINGDESTINATION AutoLocState = 5
	// The loc has triggered one of the 'reached destination' sensors of the
	// assigned route. No changes are made to the loc state when switching to
	// this state.
	AutoLocState_REACHEDSENSORACTIVATED AutoLocState = 6
	// The loc has triggered one of the 'reached destination' sensors of the
	// assigned route. If the destination let's the loc wait, a timeout is
	// started and the state is changed to <see
	// cref="WaitingForDestinationTimeout"/>. Otherwise the state will change
	// to <see cref="AssignRoute"/>. If the loc is no longer is automatic
	// mode, it will be removed from the automatic loc controller.
	AutoLocState_REACHEDDESTINATION AutoLocState = 7
	// The loc has stopped at the destination and is waiting for a timeout
	// until it can be assigned a new route.
	AutoLocState_WAITINGFORDESTINATIONTIMEOUT AutoLocState = 8
	// The loc has stopped at the destination and is waiting for a requirement
	// on the group that contains the destination block.
	AutoLocState_WAITINGFORDESTINATIONGROUPMINIMUM AutoLocState = 9
)

var AutoLocState_name = map[int32]string{
	0: "ASSIGNROUTE",
	1: "REVERSINGWAITINGFORDIRECTIONCHANGE",
	2: "WAITINGFORASSIGNEDROUTEREADY",
	3: "RUNNING",
	4: "ENTERSENSORACTIVATED",
	5: "ENTERINGDESTINATION",
	6: "REACHEDSENSORACTIVATED",
	7: "REACHEDDESTINATION",
	8: "WAITINGFORDESTINATIONTIMEOUT",
	9: "WAITINGFORDESTINATIONGROUPMINIMUM",
}

var AutoLocState_value = map[string]int32{
	"ASSIGNROUTE":                        0,
	"REVERSINGWAITINGFORDIRECTIONCHANGE": 1,
	"WAITINGFORASSIGNEDROUTEREADY":       2,
	"RUNNING":                            3,
	"ENTERSENSORACTIVATED":               4,
	"ENTERINGDESTINATION":                5,
	"REACHEDSENSORACTIVATED":             6,
	"REACHEDDESTINATION":                 7,
	"WAITINGFORDESTINATIONTIMEOUT":       8,
	"WAITINGFORDESTINATIONGROUPMINIMUM":  9,
}

func (x AutoLocState) String() string {
	return proto.EnumName(AutoLocState_name, int32(x))
}

func (AutoLocState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{1}
}

// BlockStateState describes the current state of a block.
type BlockStateState int32

const (
	// BlockStateFree means the block is available, but not occupied, not claimed
	BlockStateState_FREE BlockStateState = 0
	// BlockStateOccupied means the block is occupied by a loc, which is expected
	BlockStateState_OCCUPIED BlockStateState = 1
	// BlockStateOccupiedUnexpected means a sensor of this block is active, which is unexpected
	BlockStateState_OCCUPIEDUNEXPECTED BlockStateState = 2
	// BlockStateDestination means the block is locked by a coming loc.
	// That loc is now taking a route that leads to this block.
	BlockStateState_DESTINATION BlockStateState = 3
	// BlockStateEntering means the block is locked by a coming loc.
	// That loc is now entering this block.
	BlockStateState_ENTERING BlockStateState = 4
	// BlockStateLocked means the block is locked by a coming loc.
	// That loc's next route will lead to this block.
	BlockStateState_LOCKED BlockStateState = 5
	// BlockStateClosed means the block has been taken out of use
	BlockStateState_CLOSED BlockStateState = 6
)

var BlockStateState_name = map[int32]string{
	0: "FREE",
	1: "OCCUPIED",
	2: "OCCUPIEDUNEXPECTED",
	3: "DESTINATION",
	4: "ENTERING",
	5: "LOCKED",
	6: "CLOSED",
}

var BlockStateState_value = map[string]int32{
	"FREE":               0,
	"OCCUPIED":           1,
	"OCCUPIEDUNEXPECTED": 2,
	"DESTINATION":        3,
	"ENTERING":           4,
	"LOCKED":             5,
	"CLOSED":             6,
}

func (x BlockStateState) String() string {
	return proto.EnumName(BlockStateState_name, int32(x))
}

func (BlockStateState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{2}
}

// Railway contrains a description of a single model railway.
type RailwayState struct {
	// Set when the server is in run mode (otherwise editing mode)
	IsRunModeEnabled bool `protobuf:"varint,2,opt,name=is_run_mode_enabled,json=isRunModeEnabled,proto3" json:"is_run_mode_enabled,omitempty"`
	// Set when the server is in run mode with virtual mode enabled
	IsVirtualModeEnabled bool `protobuf:"varint,3,opt,name=is_virtual_mode_enabled,json=isVirtualModeEnabled,proto3" json:"is_virtual_mode_enabled,omitempty"`
	// Set when the server is in run mode with virtual auto run enabled
	IsVirtualAutorunEnabled bool `protobuf:"varint,4,opt,name=is_virtual_autorun_enabled,json=isVirtualAutorunEnabled,proto3" json:"is_virtual_autorun_enabled,omitempty"`
	// Is the actual power status on?
	PowerActual bool `protobuf:"varint,10,opt,name=power_actual,json=powerActual,proto3" json:"power_actual,omitempty"`
	// Is the requested power status on?
	PowerRequested bool `protobuf:"varint,11,opt,name=power_requested,json=powerRequested,proto3" json:"power_requested,omitempty"`
	// Is the automatic controller currently active?
	AutomaticControlActual bool `protobuf:"varint,12,opt,name=automatic_control_actual,json=automaticControlActual,proto3" json:"automatic_control_actual,omitempty"`
	// Is the automatic controller requested to become active?
	AutomaticControlRequested bool                 `protobuf:"varint,13,opt,name=automatic_control_requested,json=automaticControlRequested,proto3" json:"automatic_control_requested,omitempty"`
	Blocks                    []*BlockRef          `protobuf:"bytes,50,rep,name=blocks,proto3" json:"blocks,omitempty"`
	BlockGroups               []*BlockGroupRef     `protobuf:"bytes,51,rep,name=block_groups,json=blockGroups,proto3" json:"block_groups,omitempty"`
	CommandStations           []*CommandStationRef `protobuf:"bytes,52,rep,name=command_stations,json=commandStations,proto3" json:"command_stations,omitempty"`
	Junctions                 []*JunctionRef       `protobuf:"bytes,53,rep,name=junctions,proto3" json:"junctions,omitempty"`
	Locs                      []*LocRef            `protobuf:"bytes,54,rep,name=locs,proto3" json:"locs,omitempty"`
	Outputs                   []*OutputRef         `protobuf:"bytes,55,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Routes                    []*RouteRef          `protobuf:"bytes,56,rep,name=routes,proto3" json:"routes,omitempty"`
	Sensors                   []*SensorRef         `protobuf:"bytes,57,rep,name=sensors,proto3" json:"sensors,omitempty"`
	Signals                   []*SignalRef         `protobuf:"bytes,58,rep,name=signals,proto3" json:"signals,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}             `json:"-"`
	XXX_unrecognized          []byte               `json:"-"`
	XXX_sizecache             int32                `json:"-"`
}

func (m *RailwayState) Reset()         { *m = RailwayState{} }
func (m *RailwayState) String() string { return proto.CompactTextString(m) }
func (*RailwayState) ProtoMessage()    {}
func (*RailwayState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{0}
}
func (m *RailwayState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RailwayState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RailwayState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RailwayState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RailwayState.Merge(m, src)
}
func (m *RailwayState) XXX_Size() int {
	return m.Size()
}
func (m *RailwayState) XXX_DiscardUnknown() {
	xxx_messageInfo_RailwayState.DiscardUnknown(m)
}

var xxx_messageInfo_RailwayState proto.InternalMessageInfo

func (m *RailwayState) GetIsRunModeEnabled() bool {
	if m != nil {
		return m.IsRunModeEnabled
	}
	return false
}

func (m *RailwayState) GetIsVirtualModeEnabled() bool {
	if m != nil {
		return m.IsVirtualModeEnabled
	}
	return false
}

func (m *RailwayState) GetIsVirtualAutorunEnabled() bool {
	if m != nil {
		return m.IsVirtualAutorunEnabled
	}
	return false
}

func (m *RailwayState) GetPowerActual() bool {
	if m != nil {
		return m.PowerActual
	}
	return false
}

func (m *RailwayState) GetPowerRequested() bool {
	if m != nil {
		return m.PowerRequested
	}
	return false
}

func (m *RailwayState) GetAutomaticControlActual() bool {
	if m != nil {
		return m.AutomaticControlActual
	}
	return false
}

func (m *RailwayState) GetAutomaticControlRequested() bool {
	if m != nil {
		return m.AutomaticControlRequested
	}
	return false
}

func (m *RailwayState) GetBlocks() []*BlockRef {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *RailwayState) GetBlockGroups() []*BlockGroupRef {
	if m != nil {
		return m.BlockGroups
	}
	return nil
}

func (m *RailwayState) GetCommandStations() []*CommandStationRef {
	if m != nil {
		return m.CommandStations
	}
	return nil
}

func (m *RailwayState) GetJunctions() []*JunctionRef {
	if m != nil {
		return m.Junctions
	}
	return nil
}

func (m *RailwayState) GetLocs() []*LocRef {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *RailwayState) GetOutputs() []*OutputRef {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *RailwayState) GetRoutes() []*RouteRef {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *RailwayState) GetSensors() []*SensorRef {
	if m != nil {
		return m.Sensors
	}
	return nil
}

func (m *RailwayState) GetSignals() []*SignalRef {
	if m != nil {
		return m.Signals
	}
	return nil
}

// State of a single loc
type LocState struct {
	// Model of the loc
	Model *Loc `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// If set, this loc is currently controlled automatically.
	ControlledAutomaticallyActual bool `protobuf:"varint,10,opt,name=controlled_automatically_actual,json=controlledAutomaticallyActual,proto3" json:"controlled_automatically_actual,omitempty"`
	// If set, this loc wants to be controlled automatically.
	ControlledAutomaticallyRequested bool `protobuf:"varint,11,opt,name=controlled_automatically_requested,json=controlledAutomaticallyRequested,proto3" json:"controlled_automatically_requested,omitempty"`
	// Is it allowed to set the ControlledAutomatically property to true?
	CanBeControlledAutomatically bool `protobuf:"varint,12,opt,name=can_be_controlled_automatically,json=canBeControlledAutomatically,proto3" json:"can_be_controlled_automatically,omitempty"`
	// The current state of this loc in the automatic loc controller.
	AutomaticState AutoLocState `protobuf:"varint,13,opt,name=automatic_state,json=automaticState,proto3,enum=binkyrailways.v1.AutoLocState" json:"automatic_state,omitempty"`
	// Gets the route that this loc is currently taking.
	// Do not assign this property directly, instead use the assign methods.
	CurrentRoute *RouteRef `protobuf:"bytes,18,opt,name=current_route,json=currentRoute,proto3" json:"current_route,omitempty"`
	// Should the loc wait when the current route has finished?
	WaitAfterCurrentRoute bool `protobuf:"varint,20,opt,name=wait_after_current_route,json=waitAfterCurrentRoute,proto3" json:"wait_after_current_route,omitempty"`
	// Is the maximum duration of the current route this loc is taken exceeded?
	IsCurrentRouteDurationExceeded bool `protobuf:"varint,22,opt,name=is_current_route_duration_exceeded,json=isCurrentRouteDurationExceeded,proto3" json:"is_current_route_duration_exceeded,omitempty"`
	// Gets the route that this loc will take when the current route has finished.
	// This property is only set by the automatic loc controller.
	NextRoute *RouteRef `protobuf:"bytes,23,opt,name=next_route,json=nextRoute,proto3" json:"next_route,omitempty"`
	// Gets the block that the loc is currently in.
	CurrentBlock *BlockRef `protobuf:"bytes,24,opt,name=current_block,json=currentBlock,proto3" json:"current_block,omitempty"`
	// Gets the side at which the current block was entered.
	CurrentBlockEnterSide BlockSide `protobuf:"varint,25,opt,name=current_block_enter_side,json=currentBlockEnterSide,proto3,enum=binkyrailways.v1.BlockSide" json:"current_block_enter_side,omitempty"`
	// Current speed of this loc as percentage of the speed steps of the loc.
	// Value between 0 and 100.
	// Setting this value will result in a request to its command station to alter
	// the speed.
	SpeedActual    int32 `protobuf:"varint,50,opt,name=speed_actual,json=speedActual,proto3" json:"speed_actual,omitempty"`
	SpeedRequested int32 `protobuf:"varint,51,opt,name=speed_requested,json=speedRequested,proto3" json:"speed_requested,omitempty"`
	// Gets a human readable representation of the speed of the loc.
	SpeedText string `protobuf:"bytes,52,opt,name=speed_text,json=speedText,proto3" json:"speed_text,omitempty"`
	// Gets a human readable representation of the state of the loc.
	StateText string `protobuf:"bytes,53,opt,name=state_text,json=stateText,proto3" json:"state_text,omitempty"`
	// Gets the actual speed of the loc in speed steps
	// Value between 0 and the maximum number of speed steps supported by this
	// loc. Setting this value will result in a request to its command station to
	// alter the speed.
	SpeedInStepsActual    int32 `protobuf:"varint,54,opt,name=speed_in_steps_actual,json=speedInStepsActual,proto3" json:"speed_in_steps_actual,omitempty"`
	SpeedInStepsRequested int32 `protobuf:"varint,55,opt,name=speed_in_steps_requested,json=speedInStepsRequested,proto3" json:"speed_in_steps_requested,omitempty"`
	// Current direction of this loc.
	// Setting this value will result in a request to its command station to alter
	// the direction.
	DirectionActual    LocDirection `protobuf:"varint,56,opt,name=direction_actual,json=directionActual,proto3,enum=binkyrailways.v1.LocDirection" json:"direction_actual,omitempty"`
	DirectionRequested LocDirection `protobuf:"varint,57,opt,name=direction_requested,json=directionRequested,proto3,enum=binkyrailways.v1.LocDirection" json:"direction_requested,omitempty"`
	// Is this loc reversing out of a dead end?
	// This can only be true for locs that are not allowed to change
	// direction.
	IsReversing bool `protobuf:"varint,60,opt,name=is_reversing,json=isReversing,proto3" json:"is_reversing,omitempty"`
	// Directional lighting of the loc.
	// Setting this value will result in a request to its command station to alter
	// the value.
	F0Actual    bool `protobuf:"varint,70,opt,name=f0_actual,json=f0Actual,proto3" json:"f0_actual,omitempty"`
	F0Requested bool `protobuf:"varint,71,opt,name=f0_requested,json=f0Requested,proto3" json:"f0_requested,omitempty"`
	// Gets the enabled state of this loc.
	// If not enabled, the loc state will not be sent to
	// command stations.
	IsEnabled            bool     `protobuf:"varint,80,opt,name=is_enabled,json=isEnabled,proto3" json:"is_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocState) Reset()         { *m = LocState{} }
func (m *LocState) String() string { return proto.CompactTextString(m) }
func (*LocState) ProtoMessage()    {}
func (*LocState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{1}
}
func (m *LocState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocState.Merge(m, src)
}
func (m *LocState) XXX_Size() int {
	return m.Size()
}
func (m *LocState) XXX_DiscardUnknown() {
	xxx_messageInfo_LocState.DiscardUnknown(m)
}

var xxx_messageInfo_LocState proto.InternalMessageInfo

func (m *LocState) GetModel() *Loc {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *LocState) GetControlledAutomaticallyActual() bool {
	if m != nil {
		return m.ControlledAutomaticallyActual
	}
	return false
}

func (m *LocState) GetControlledAutomaticallyRequested() bool {
	if m != nil {
		return m.ControlledAutomaticallyRequested
	}
	return false
}

func (m *LocState) GetCanBeControlledAutomatically() bool {
	if m != nil {
		return m.CanBeControlledAutomatically
	}
	return false
}

func (m *LocState) GetAutomaticState() AutoLocState {
	if m != nil {
		return m.AutomaticState
	}
	return AutoLocState_ASSIGNROUTE
}

func (m *LocState) GetCurrentRoute() *RouteRef {
	if m != nil {
		return m.CurrentRoute
	}
	return nil
}

func (m *LocState) GetWaitAfterCurrentRoute() bool {
	if m != nil {
		return m.WaitAfterCurrentRoute
	}
	return false
}

func (m *LocState) GetIsCurrentRouteDurationExceeded() bool {
	if m != nil {
		return m.IsCurrentRouteDurationExceeded
	}
	return false
}

func (m *LocState) GetNextRoute() *RouteRef {
	if m != nil {
		return m.NextRoute
	}
	return nil
}

func (m *LocState) GetCurrentBlock() *BlockRef {
	if m != nil {
		return m.CurrentBlock
	}
	return nil
}

func (m *LocState) GetCurrentBlockEnterSide() BlockSide {
	if m != nil {
		return m.CurrentBlockEnterSide
	}
	return BlockSide_FRONT
}

func (m *LocState) GetSpeedActual() int32 {
	if m != nil {
		return m.SpeedActual
	}
	return 0
}

func (m *LocState) GetSpeedRequested() int32 {
	if m != nil {
		return m.SpeedRequested
	}
	return 0
}

func (m *LocState) GetSpeedText() string {
	if m != nil {
		return m.SpeedText
	}
	return ""
}

func (m *LocState) GetStateText() string {
	if m != nil {
		return m.StateText
	}
	return ""
}

func (m *LocState) GetSpeedInStepsActual() int32 {
	if m != nil {
		return m.SpeedInStepsActual
	}
	return 0
}

func (m *LocState) GetSpeedInStepsRequested() int32 {
	if m != nil {
		return m.SpeedInStepsRequested
	}
	return 0
}

func (m *LocState) GetDirectionActual() LocDirection {
	if m != nil {
		return m.DirectionActual
	}
	return LocDirection_FORWARD
}

func (m *LocState) GetDirectionRequested() LocDirection {
	if m != nil {
		return m.DirectionRequested
	}
	return LocDirection_FORWARD
}

func (m *LocState) GetIsReversing() bool {
	if m != nil {
		return m.IsReversing
	}
	return false
}

func (m *LocState) GetF0Actual() bool {
	if m != nil {
		return m.F0Actual
	}
	return false
}

func (m *LocState) GetF0Requested() bool {
	if m != nil {
		return m.F0Requested
	}
	return false
}

func (m *LocState) GetIsEnabled() bool {
	if m != nil {
		return m.IsEnabled
	}
	return false
}

// State of a single command station
type CommandStationState struct {
	// Model of the command station
	Model *CommandStation `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// Status of hardware modules connected to this command station
	HardwareModules      []*HardwareModule `protobuf:"bytes,2,rep,name=hardware_modules,json=hardwareModules,proto3" json:"hardware_modules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CommandStationState) Reset()         { *m = CommandStationState{} }
func (m *CommandStationState) String() string { return proto.CompactTextString(m) }
func (*CommandStationState) ProtoMessage()    {}
func (*CommandStationState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{2}
}
func (m *CommandStationState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStationState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStationState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandStationState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStationState.Merge(m, src)
}
func (m *CommandStationState) XXX_Size() int {
	return m.Size()
}
func (m *CommandStationState) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStationState.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStationState proto.InternalMessageInfo

func (m *CommandStationState) GetModel() *CommandStation {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *CommandStationState) GetHardwareModules() []*HardwareModule {
	if m != nil {
		return m.HardwareModules
	}
	return nil
}

// State specific a hardware module that is connected to the command station
type HardwareModule struct {
	// ID of the module
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Uptime in seconds
	Uptime int64 `protobuf:"varint,2,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// Time of last update of this information.
	// Formatted at RFC3339
	LastUpdatedAt string `protobuf:"bytes,3,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	// Error messages related to this module
	ErrorMessages []string `protobuf:"bytes,4,rep,name=error_messages,json=errorMessages,proto3" json:"error_messages,omitempty"`
	// IP address of this module (if any)
	Address string `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	// Seconds since the module sent it's last ping update
	SecondsSinceLastUpdated int64 `protobuf:"varint,6,opt,name=seconds_since_last_updated,json=secondsSinceLastUpdated,proto3" json:"seconds_since_last_updated,omitempty"`
	// URL to fetch metrics from this module
	MetricsUrl string `protobuf:"bytes,7,opt,name=metrics_url,json=metricsUrl,proto3" json:"metrics_url,omitempty"`
	// URL to fetch DCC generator info from this module
	DccGeneratorUrl string `protobuf:"bytes,8,opt,name=dcc_generator_url,json=dccGeneratorUrl,proto3" json:"dcc_generator_url,omitempty"`
	// URL to open an SSH session towards this module
	SshUrl               string   `protobuf:"bytes,9,opt,name=ssh_url,json=sshUrl,proto3" json:"ssh_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HardwareModule) Reset()         { *m = HardwareModule{} }
func (m *HardwareModule) String() string { return proto.CompactTextString(m) }
func (*HardwareModule) ProtoMessage()    {}
func (*HardwareModule) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{3}
}
func (m *HardwareModule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardwareModule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HardwareModule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HardwareModule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardwareModule.Merge(m, src)
}
func (m *HardwareModule) XXX_Size() int {
	return m.Size()
}
func (m *HardwareModule) XXX_DiscardUnknown() {
	xxx_messageInfo_HardwareModule.DiscardUnknown(m)
}

var xxx_messageInfo_HardwareModule proto.InternalMessageInfo

func (m *HardwareModule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *HardwareModule) GetUptime() int64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *HardwareModule) GetLastUpdatedAt() string {
	if m != nil {
		return m.LastUpdatedAt
	}
	return ""
}

func (m *HardwareModule) GetErrorMessages() []string {
	if m != nil {
		return m.ErrorMessages
	}
	return nil
}

func (m *HardwareModule) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *HardwareModule) GetSecondsSinceLastUpdated() int64 {
	if m != nil {
		return m.SecondsSinceLastUpdated
	}
	return 0
}

func (m *HardwareModule) GetMetricsUrl() string {
	if m != nil {
		return m.MetricsUrl
	}
	return ""
}

func (m *HardwareModule) GetDccGeneratorUrl() string {
	if m != nil {
		return m.DccGeneratorUrl
	}
	return ""
}

func (m *HardwareModule) GetSshUrl() string {
	if m != nil {
		return m.SshUrl
	}
	return ""
}

// State of a single block
type BlockState struct {
	// Model of the block
	Model *Block `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// If set, contains the loc that has locked this block
	LockedBy *LocRef `protobuf:"bytes,2,opt,name=locked_by,json=lockedBy,proto3" json:"locked_by,omitempty"`
	// Gets the current state of this block
	State BlockStateState `protobuf:"varint,3,opt,name=state,proto3,enum=binkyrailways.v1.BlockStateState" json:"state,omitempty"`
	// Is this block closed for traffic?
	ClosedActual    bool `protobuf:"varint,10,opt,name=closed_actual,json=closedActual,proto3" json:"closed_actual,omitempty"`
	ClosedRequested bool `protobuf:"varint,11,opt,name=closed_requested,json=closedRequested,proto3" json:"closed_requested,omitempty"`
	// Can a loc only leave this block at the same side it got in?
	IsDeadend bool `protobuf:"varint,20,opt,name=is_deadend,json=isDeadend,proto3" json:"is_deadend,omitempty"`
	// Is this block considered a station?
	IsStation bool `protobuf:"varint,21,opt,name=is_station,json=isStation,proto3" json:"is_station,omitempty"`
	// Is there a loc waiting in this block?
	HasWaitingLoc        bool     `protobuf:"varint,22,opt,name=has_waiting_loc,json=hasWaitingLoc,proto3" json:"has_waiting_loc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockState) Reset()         { *m = BlockState{} }
func (m *BlockState) String() string { return proto.CompactTextString(m) }
func (*BlockState) ProtoMessage()    {}
func (*BlockState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{4}
}
func (m *BlockState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockState.Merge(m, src)
}
func (m *BlockState) XXX_Size() int {
	return m.Size()
}
func (m *BlockState) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockState.DiscardUnknown(m)
}

var xxx_messageInfo_BlockState proto.InternalMessageInfo

func (m *BlockState) GetModel() *Block {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *BlockState) GetLockedBy() *LocRef {
	if m != nil {
		return m.LockedBy
	}
	return nil
}

func (m *BlockState) GetState() BlockStateState {
	if m != nil {
		return m.State
	}
	return BlockStateState_FREE
}

func (m *BlockState) GetClosedActual() bool {
	if m != nil {
		return m.ClosedActual
	}
	return false
}

func (m *BlockState) GetClosedRequested() bool {
	if m != nil {
		return m.ClosedRequested
	}
	return false
}

func (m *BlockState) GetIsDeadend() bool {
	if m != nil {
		return m.IsDeadend
	}
	return false
}

func (m *BlockState) GetIsStation() bool {
	if m != nil {
		return m.IsStation
	}
	return false
}

func (m *BlockState) GetHasWaitingLoc() bool {
	if m != nil {
		return m.HasWaitingLoc
	}
	return false
}

// State of a single block group
type BlockGroupState struct {
	// Model of the block group
	Model                *BlockGroup `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BlockGroupState) Reset()         { *m = BlockGroupState{} }
func (m *BlockGroupState) String() string { return proto.CompactTextString(m) }
func (*BlockGroupState) ProtoMessage()    {}
func (*BlockGroupState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{5}
}
func (m *BlockGroupState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockGroupState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockGroupState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockGroupState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockGroupState.Merge(m, src)
}
func (m *BlockGroupState) XXX_Size() int {
	return m.Size()
}
func (m *BlockGroupState) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockGroupState.DiscardUnknown(m)
}

var xxx_messageInfo_BlockGroupState proto.InternalMessageInfo

func (m *BlockGroupState) GetModel() *BlockGroup {
	if m != nil {
		return m.Model
	}
	return nil
}

// State of a single junction
type JunctionState struct {
	// Model of the junction
	Model *Junction `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// Set if junction is a switch
	Switch               *SwitchState `protobuf:"bytes,2,opt,name=switch,proto3" json:"switch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *JunctionState) Reset()         { *m = JunctionState{} }
func (m *JunctionState) String() string { return proto.CompactTextString(m) }
func (*JunctionState) ProtoMessage()    {}
func (*JunctionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{6}
}
func (m *JunctionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JunctionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JunctionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JunctionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JunctionState.Merge(m, src)
}
func (m *JunctionState) XXX_Size() int {
	return m.Size()
}
func (m *JunctionState) XXX_DiscardUnknown() {
	xxx_messageInfo_JunctionState.DiscardUnknown(m)
}

var xxx_messageInfo_JunctionState proto.InternalMessageInfo

func (m *JunctionState) GetModel() *Junction {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *JunctionState) GetSwitch() *SwitchState {
	if m != nil {
		return m.Switch
	}
	return nil
}

// Switch specialization of junction
type SwitchState struct {
	// Actual direction of switch
	DirectionActual SwitchDirection `protobuf:"varint,1,opt,name=direction_actual,json=directionActual,proto3,enum=binkyrailways.v1.SwitchDirection" json:"direction_actual,omitempty"`
	// Requested direction of switch
	DirectionRequested   SwitchDirection `protobuf:"varint,2,opt,name=direction_requested,json=directionRequested,proto3,enum=binkyrailways.v1.SwitchDirection" json:"direction_requested,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SwitchState) Reset()         { *m = SwitchState{} }
func (m *SwitchState) String() string { return proto.CompactTextString(m) }
func (*SwitchState) ProtoMessage()    {}
func (*SwitchState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{7}
}
func (m *SwitchState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchState.Merge(m, src)
}
func (m *SwitchState) XXX_Size() int {
	return m.Size()
}
func (m *SwitchState) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchState.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchState proto.InternalMessageInfo

func (m *SwitchState) GetDirectionActual() SwitchDirection {
	if m != nil {
		return m.DirectionActual
	}
	return SwitchDirection_STRAIGHT
}

func (m *SwitchState) GetDirectionRequested() SwitchDirection {
	if m != nil {
		return m.DirectionRequested
	}
	return SwitchDirection_STRAIGHT
}

// State of a single output
type OutputState struct {
	// Model of the output
	Model *Output `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// Set if output is a binary output
	BinaryOutput         *BinaryOutputState `protobuf:"bytes,2,opt,name=binary_output,json=binaryOutput,proto3" json:"binary_output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *OutputState) Reset()         { *m = OutputState{} }
func (m *OutputState) String() string { return proto.CompactTextString(m) }
func (*OutputState) ProtoMessage()    {}
func (*OutputState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{8}
}
func (m *OutputState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutputState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutputState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputState.Merge(m, src)
}
func (m *OutputState) XXX_Size() int {
	return m.Size()
}
func (m *OutputState) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputState.DiscardUnknown(m)
}

var xxx_messageInfo_OutputState proto.InternalMessageInfo

func (m *OutputState) GetModel() *Output {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *OutputState) GetBinaryOutput() *BinaryOutputState {
	if m != nil {
		return m.BinaryOutput
	}
	return nil
}

type BinaryOutputState struct {
	// Actual active state
	ActiveActual bool `protobuf:"varint,1,opt,name=active_actual,json=activeActual,proto3" json:"active_actual,omitempty"`
	// Requested active state
	ActiveRequested      bool     `protobuf:"varint,2,opt,name=active_requested,json=activeRequested,proto3" json:"active_requested,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinaryOutputState) Reset()         { *m = BinaryOutputState{} }
func (m *BinaryOutputState) String() string { return proto.CompactTextString(m) }
func (*BinaryOutputState) ProtoMessage()    {}
func (*BinaryOutputState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{9}
}
func (m *BinaryOutputState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOutputState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOutputState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOutputState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOutputState.Merge(m, src)
}
func (m *BinaryOutputState) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOutputState) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOutputState.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOutputState proto.InternalMessageInfo

func (m *BinaryOutputState) GetActiveActual() bool {
	if m != nil {
		return m.ActiveActual
	}
	return false
}

func (m *BinaryOutputState) GetActiveRequested() bool {
	if m != nil {
		return m.ActiveRequested
	}
	return false
}

// State of a single route
type RouteState struct {
	// Model of the route
	Model                *Route   `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteState) Reset()         { *m = RouteState{} }
func (m *RouteState) String() string { return proto.CompactTextString(m) }
func (*RouteState) ProtoMessage()    {}
func (*RouteState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{10}
}
func (m *RouteState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteState.Merge(m, src)
}
func (m *RouteState) XXX_Size() int {
	return m.Size()
}
func (m *RouteState) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteState.DiscardUnknown(m)
}

var xxx_messageInfo_RouteState proto.InternalMessageInfo

func (m *RouteState) GetModel() *Route {
	if m != nil {
		return m.Model
	}
	return nil
}

// State of a single sensor
type SensorState struct {
	// Model of the sensor
	Model *Sensor `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// Is the sensor indicating an active input?
	Active               bool     `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SensorState) Reset()         { *m = SensorState{} }
func (m *SensorState) String() string { return proto.CompactTextString(m) }
func (*SensorState) ProtoMessage()    {}
func (*SensorState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{11}
}
func (m *SensorState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorState.Merge(m, src)
}
func (m *SensorState) XXX_Size() int {
	return m.Size()
}
func (m *SensorState) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorState.DiscardUnknown(m)
}

var xxx_messageInfo_SensorState proto.InternalMessageInfo

func (m *SensorState) GetModel() *Sensor {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *SensorState) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// State of a single signal
type SignalState struct {
	// Model of the route
	Model                *Signal  `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignalState) Reset()         { *m = SignalState{} }
func (m *SignalState) String() string { return proto.CompactTextString(m) }
func (*SignalState) ProtoMessage()    {}
func (*SignalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ba3d7758196798e, []int{12}
}
func (m *SignalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignalState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignalState.Merge(m, src)
}
func (m *SignalState) XXX_Size() int {
	return m.Size()
}
func (m *SignalState) XXX_DiscardUnknown() {
	xxx_messageInfo_SignalState.DiscardUnknown(m)
}

var xxx_messageInfo_SignalState proto.InternalMessageInfo

func (m *SignalState) GetModel() *Signal {
	if m != nil {
		return m.Model
	}
	return nil
}

func init() {
	proto.RegisterEnum("binkyrailways.v1.LocDirection", LocDirection_name, LocDirection_value)
	proto.RegisterEnum("binkyrailways.v1.AutoLocState", AutoLocState_name, AutoLocState_value)
	proto.RegisterEnum("binkyrailways.v1.BlockStateState", BlockStateState_name, BlockStateState_value)
	proto.RegisterType((*RailwayState)(nil), "binkyrailways.v1.RailwayState")
	proto.RegisterType((*LocState)(nil), "binkyrailways.v1.LocState")
	proto.RegisterType((*CommandStationState)(nil), "binkyrailways.v1.CommandStationState")
	proto.RegisterType((*HardwareModule)(nil), "binkyrailways.v1.HardwareModule")
	proto.RegisterType((*BlockState)(nil), "binkyrailways.v1.BlockState")
	proto.RegisterType((*BlockGroupState)(nil), "binkyrailways.v1.BlockGroupState")
	proto.RegisterType((*JunctionState)(nil), "binkyrailways.v1.JunctionState")
	proto.RegisterType((*SwitchState)(nil), "binkyrailways.v1.SwitchState")
	proto.RegisterType((*OutputState)(nil), "binkyrailways.v1.OutputState")
	proto.RegisterType((*BinaryOutputState)(nil), "binkyrailways.v1.BinaryOutputState")
	proto.RegisterType((*RouteState)(nil), "binkyrailways.v1.RouteState")
	proto.RegisterType((*SensorState)(nil), "binkyrailways.v1.SensorState")
	proto.RegisterType((*SignalState)(nil), "binkyrailways.v1.SignalState")
}

func init() { proto.RegisterFile("br_state_types.proto", fileDescriptor_7ba3d7758196798e) }

var fileDescriptor_7ba3d7758196798e = []byte{
	// 1780 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x58, 0xcd, 0x72, 0xdb, 0xc8,
	0x11, 0x36, 0x29, 0x89, 0x22, 0x9b, 0x94, 0x88, 0x1d, 0x5b, 0x12, 0x56, 0xb6, 0x65, 0x8a, 0x5b,
	0xbb, 0x51, 0x9c, 0x44, 0x96, 0xe5, 0x95, 0x65, 0xc7, 0xf9, 0x29, 0x8a, 0x84, 0x68, 0xee, 0x52,
	0xa4, 0x0a, 0x24, 0xed, 0x24, 0x17, 0x14, 0x08, 0x8c, 0x24, 0xc4, 0x10, 0xc0, 0x60, 0x40, 0xfd,
	0x9c, 0x73, 0x48, 0xe5, 0x0d, 0x52, 0x79, 0x80, 0x5c, 0xf3, 0x12, 0x39, 0xe4, 0x98, 0x47, 0x48,
	0x9c, 0x17, 0xd9, 0x9a, 0x9e, 0x01, 0x01, 0x48, 0xa4, 0x56, 0x37, 0x4e, 0xf7, 0xf7, 0x75, 0x37,
	0x7a, 0x7a, 0xba, 0xbb, 0x08, 0x8f, 0x86, 0x81, 0xc1, 0x42, 0x33, 0xa4, 0x46, 0x78, 0x3d, 0xa2,
	0x6c, 0x7b, 0x14, 0xf8, 0xa1, 0x4f, 0x94, 0xa1, 0xe3, 0x7d, 0xba, 0x0e, 0x4c, 0xc7, 0xbd, 0x34,
	0xaf, 0xd9, 0xf6, 0xc5, 0xcb, 0x75, 0x8e, 0x3b, 0xf7, 0x6d, 0xea, 0x26, 0x71, 0xd5, 0x3f, 0x2f,
	0x42, 0x49, 0x17, 0xa8, 0x1e, 0x37, 0x42, 0x7e, 0x01, 0x0f, 0x1d, 0x66, 0x04, 0x63, 0x0f, 0xc1,
	0x06, 0xf5, 0xcc, 0xa1, 0x4b, 0x6d, 0x35, 0x5b, 0xc9, 0x6c, 0xe5, 0x75, 0xc5, 0x61, 0xfa, 0xd8,
	0x3b, 0xf2, 0x6d, 0xaa, 0x09, 0x39, 0xd9, 0x83, 0x35, 0x87, 0x19, 0x17, 0x4e, 0x10, 0x8e, 0x4d,
	0x37, 0x4d, 0x99, 0x43, 0xca, 0x23, 0x87, 0x7d, 0x10, 0xda, 0x24, 0xed, 0x1d, 0xac, 0x27, 0x68,
	0xe6, 0x38, 0xf4, 0xb9, 0xc7, 0x88, 0x39, 0x8f, 0xcc, 0xb5, 0x09, 0xb3, 0x26, 0xf4, 0x11, 0x79,
	0x13, 0x4a, 0x23, 0xff, 0x92, 0x06, 0x86, 0x69, 0x71, 0xad, 0x0a, 0x08, 0x2f, 0xa2, 0xac, 0x86,
	0x22, 0xf2, 0x13, 0x28, 0x0b, 0x48, 0x40, 0xff, 0x34, 0xa6, 0x2c, 0xa4, 0xb6, 0x5a, 0x44, 0xd4,
	0x32, 0x8a, 0xf5, 0x48, 0x4a, 0xde, 0x80, 0xca, 0xbd, 0x9f, 0x9b, 0xa1, 0x63, 0x19, 0x96, 0xef,
	0x85, 0x81, 0xef, 0x46, 0x76, 0x4b, 0xc8, 0x58, 0x9d, 0xe8, 0xeb, 0x42, 0x2d, 0x5d, 0xfc, 0x06,
	0x1e, 0xdf, 0x66, 0xc6, 0xee, 0x96, 0x90, 0xfc, 0xe5, 0x4d, 0x72, 0xec, 0x79, 0x17, 0x72, 0x43,
	0xd7, 0xb7, 0x3e, 0x31, 0x75, 0xb7, 0x32, 0xb7, 0x55, 0xdc, 0x5d, 0xdf, 0xbe, 0x79, 0x65, 0xdb,
	0x07, 0x5c, 0xaf, 0xd3, 0x13, 0x5d, 0x22, 0xc9, 0x01, 0x94, 0xf0, 0x97, 0x71, 0x1a, 0xf8, 0xe3,
	0x11, 0x53, 0x5f, 0x21, 0xf3, 0xd9, 0x0c, 0x66, 0x93, 0x83, 0x38, 0xbd, 0x38, 0x9c, 0x1c, 0x19,
	0xe9, 0x80, 0x62, 0xf9, 0xe7, 0xe7, 0xa6, 0x67, 0x63, 0xd9, 0x38, 0xbe, 0xc7, 0xd4, 0x6f, 0xd1,
	0xce, 0x57, 0xb7, 0xed, 0xd4, 0x05, 0xb2, 0x27, 0x80, 0xdc, 0x56, 0xd9, 0x4a, 0x89, 0x18, 0x79,
	0x07, 0x85, 0x3f, 0x8e, 0x3d, 0x4b, 0x18, 0xda, 0x43, 0x43, 0x4f, 0x6f, 0x1b, 0xfa, 0x4e, 0x42,
	0xb8, 0x89, 0x18, 0x4f, 0x7e, 0x0e, 0xf3, 0xae, 0x6f, 0x31, 0xf5, 0x35, 0xf2, 0xd4, 0xdb, 0xbc,
	0xb6, 0x6f, 0x71, 0x0a, 0xa2, 0xc8, 0x1e, 0x2c, 0xfa, 0xe3, 0x70, 0x34, 0x0e, 0x99, 0xba, 0x8f,
	0x84, 0xc7, 0xb7, 0x09, 0x5d, 0x04, 0x70, 0x4e, 0x84, 0xe5, 0x99, 0x0e, 0xfc, 0x71, 0x48, 0x99,
	0xfa, 0x66, 0x56, 0xa6, 0x75, 0xae, 0xc7, 0x4c, 0x0b, 0x24, 0x77, 0xc5, 0xa8, 0xc7, 0xfc, 0x80,
	0xa9, 0x6f, 0x67, 0xb9, 0xea, 0x21, 0x00, 0x5d, 0x49, 0x2c, 0xd2, 0x9c, 0x53, 0xcf, 0x74, 0x99,
	0xfa, 0xcb, 0x99, 0x34, 0x04, 0x08, 0x9a, 0xc0, 0x56, 0xff, 0x0a, 0x90, 0x6f, 0xfb, 0x96, 0x78,
	0x81, 0x3f, 0x83, 0x05, 0x7c, 0xa7, 0x6a, 0xa6, 0x92, 0xd9, 0x2a, 0xee, 0xae, 0x4c, 0x4f, 0x8a,
	0xc0, 0x90, 0x43, 0x78, 0x26, 0x6b, 0xcf, 0xa5, 0xb6, 0x31, 0xa9, 0x36, 0xd3, 0x75, 0xaf, 0xd3,
	0xcf, 0xe3, 0x69, 0x0c, 0xab, 0x25, 0x51, 0xb2, 0x9a, 0xdb, 0x50, 0x9d, 0x69, 0xe7, 0xe6, 0x1b,
	0xaa, 0xcc, 0x30, 0x15, 0xd7, 0xb6, 0x06, 0xcf, 0x2c, 0xd3, 0x33, 0x86, 0xd4, 0x98, 0x65, 0x54,
	0x3e, 0xae, 0x27, 0x96, 0xe9, 0x1d, 0xd0, 0xfa, 0x74, 0x7b, 0xa4, 0x09, 0xe5, 0xf8, 0x89, 0x61,
	0x8f, 0xc3, 0x67, 0xb5, 0xbc, 0xbb, 0x71, 0x3b, 0x27, 0x9c, 0x19, 0xa5, 0x50, 0x5f, 0x9e, 0xd0,
	0x44, 0x4a, 0x7f, 0x0b, 0x4b, 0xd6, 0x38, 0x08, 0xa8, 0x17, 0x1a, 0x78, 0xbf, 0x2a, 0xc1, 0xd4,
	0xde, 0x55, 0x08, 0x25, 0x49, 0x40, 0x01, 0xd9, 0x07, 0xf5, 0xd2, 0x74, 0x42, 0xc3, 0x3c, 0x09,
	0x69, 0x60, 0xa4, 0x6d, 0x3d, 0xc2, 0x2f, 0x59, 0xe1, 0xfa, 0x1a, 0x57, 0xd7, 0x93, 0xc4, 0xef,
	0xa0, 0xea, 0xb0, 0x34, 0xc1, 0xb0, 0xc7, 0x01, 0xbe, 0x1d, 0x83, 0x5e, 0x59, 0x94, 0xda, 0xd4,
	0x56, 0x57, 0xd1, 0xc4, 0x86, 0xc3, 0x92, 0xdc, 0x86, 0x84, 0x69, 0x12, 0x45, 0xde, 0x02, 0x78,
	0xf4, 0x2a, 0x72, 0xbb, 0xf6, 0xa3, 0x9f, 0x50, 0xe0, 0x68, 0x11, 0x46, 0x22, 0x01, 0xd8, 0x0b,
	0x54, 0x75, 0x16, 0x7b, 0xd2, 0x73, 0xa2, 0x04, 0xa0, 0x80, 0xf4, 0x41, 0x4d, 0x19, 0x30, 0xa8,
	0xc7, 0x33, 0xc1, 0x1c, 0x9b, 0xaa, 0x5f, 0xe2, 0x9d, 0x3c, 0x9e, 0x61, 0xab, 0xe7, 0xd8, 0x54,
	0x5f, 0x49, 0x1a, 0xd3, 0x38, 0x95, 0x8b, 0x79, 0x27, 0x67, 0x23, 0xca, 0x6b, 0x43, 0x94, 0xea,
	0x6e, 0x25, 0xb3, 0xb5, 0xa0, 0x17, 0x51, 0x16, 0x77, 0x72, 0x01, 0x89, 0xab, 0xf0, 0x15, 0xa2,
	0x96, 0x51, 0x1c, 0xd7, 0xdc, 0x53, 0x00, 0x01, 0x0c, 0xe9, 0x55, 0xa8, 0x7e, 0x5b, 0xc9, 0x6c,
	0x15, 0xf4, 0x02, 0x4a, 0xfa, 0xf4, 0x2a, 0x44, 0xb5, 0x98, 0x92, 0x5c, 0xbd, 0x27, 0xd5, 0x5c,
	0x82, 0xea, 0x97, 0xb0, 0x22, 0xd8, 0x8e, 0x67, 0xb0, 0x90, 0x8e, 0x58, 0x14, 0xd2, 0x6b, 0x74,
	0x46, 0x50, 0xd9, 0xf2, 0x7a, 0x5c, 0x25, 0x23, 0xdb, 0x07, 0xf5, 0x06, 0x25, 0x0e, 0x71, 0x1f,
	0x59, 0x2b, 0x49, 0x56, 0x1c, 0x69, 0x0b, 0x14, 0xdb, 0x09, 0x28, 0xb6, 0xc0, 0xc8, 0xcd, 0x9b,
	0x59, 0x75, 0xdd, 0xf6, 0xad, 0x46, 0x04, 0xd6, 0xcb, 0x13, 0x9e, 0x8c, 0xa1, 0x0b, 0x0f, 0x63,
	0x53, 0xb1, 0xfb, 0xb7, 0xf7, 0xb2, 0x46, 0x26, 0xd4, 0x38, 0xb6, 0x4d, 0x28, 0xf1, 0xf1, 0x4f,
	0x2f, 0x68, 0xc0, 0x1c, 0xef, 0x54, 0xfd, 0x95, 0x98, 0xad, 0x0e, 0xd3, 0x23, 0x11, 0x79, 0x0c,
	0x85, 0x93, 0x9d, 0x28, 0xee, 0x43, 0xd4, 0xe7, 0x4f, 0x76, 0x64, 0x40, 0x9b, 0x50, 0x3a, 0xd9,
	0x49, 0x44, 0xd2, 0x14, 0xfc, 0x93, 0x9d, 0xd4, 0x45, 0x39, 0x6c, 0x32, 0xeb, 0x8f, 0x11, 0x50,
	0x70, 0x98, 0x9c, 0xee, 0xd5, 0xbf, 0x67, 0xe0, 0x61, 0x7a, 0xec, 0x88, 0x37, 0xfc, 0x3a, 0xdd,
	0x16, 0x2b, 0x3f, 0x3a, 0xac, 0x64, 0x87, 0xfc, 0x1e, 0x94, 0x33, 0x33, 0xb0, 0x2f, 0xcd, 0x80,
	0xf2, 0xfd, 0x64, 0xec, 0x52, 0xa6, 0x66, 0xb1, 0x37, 0x4f, 0x31, 0xf1, 0x5e, 0x22, 0x8f, 0x10,
	0xa8, 0x97, 0xcf, 0x52, 0x67, 0x56, 0xfd, 0x57, 0x16, 0x96, 0xd3, 0x18, 0xb2, 0x0c, 0x59, 0xc7,
	0xc6, 0xa0, 0x0a, 0x7a, 0xd6, 0xb1, 0xc9, 0x2a, 0xe4, 0xc6, 0xa3, 0xd0, 0x39, 0xa7, 0xb8, 0x33,
	0xcd, 0xe9, 0xf2, 0x44, 0xbe, 0x81, 0xb2, 0x6b, 0xb2, 0xd0, 0x18, 0x8f, 0x6c, 0x33, 0xe4, 0x25,
	0x1f, 0xe2, 0x86, 0x54, 0xd0, 0x97, 0xb8, 0x78, 0x20, 0xa4, 0xb5, 0x90, 0x7c, 0x0d, 0xcb, 0x34,
	0x08, 0xfc, 0xc0, 0x38, 0xa7, 0x8c, 0x99, 0xa7, 0x94, 0xa9, 0xf3, 0x95, 0x39, 0x0e, 0x43, 0xe9,
	0x91, 0x14, 0x12, 0x15, 0x16, 0x4d, 0xdb, 0x0e, 0x28, 0x63, 0xea, 0x02, 0x9a, 0x89, 0x8e, 0x7c,
	0xb7, 0x62, 0xd4, 0xf2, 0x3d, 0x9b, 0x19, 0xcc, 0xf1, 0x2c, 0x6a, 0x24, 0xdd, 0xaa, 0x39, 0x0c,
	0x6a, 0x4d, 0x22, 0x7a, 0x1c, 0xd0, 0x8e, 0xfd, 0x93, 0x67, 0x50, 0x3c, 0xa7, 0x61, 0xe0, 0x58,
	0xcc, 0x18, 0x07, 0xae, 0xba, 0x88, 0xa6, 0x41, 0x8a, 0x06, 0x81, 0x4b, 0x9e, 0xc3, 0x17, 0xb6,
	0x65, 0x19, 0xa7, 0xd4, 0xa3, 0x81, 0x19, 0xfa, 0x01, 0xc2, 0xf2, 0x08, 0x2b, 0xdb, 0x96, 0xd5,
	0x8c, 0xe4, 0x1c, 0xbb, 0x06, 0x8b, 0x8c, 0x9d, 0x21, 0xa2, 0x80, 0x88, 0x1c, 0x63, 0x67, 0x83,
	0xc0, 0xad, 0xfe, 0x2f, 0x0b, 0x20, 0x9a, 0x83, 0xdc, 0x39, 0x53, 0x57, 0xbb, 0x36, 0xab, 0x2b,
	0xc9, 0x1b, 0xdd, 0x83, 0x02, 0x3f, 0x52, 0xdb, 0x18, 0x5e, 0x63, 0x92, 0xef, 0xda, 0x1c, 0xf2,
	0x02, 0x7a, 0x70, 0x4d, 0xf6, 0x61, 0x41, 0xcc, 0x90, 0x39, 0x7c, 0x1d, 0x9b, 0xb3, 0xfa, 0x15,
	0xc7, 0x88, 0x31, 0x22, 0xf0, 0xe4, 0x2b, 0x58, 0xb2, 0x5c, 0x9f, 0xc5, 0x6d, 0x4a, 0x4c, 0xd4,
	0x92, 0x10, 0xca, 0xc2, 0xff, 0x29, 0x28, 0x12, 0x74, 0x73, 0x5c, 0x96, 0x85, 0xfc, 0xe6, 0x03,
	0xb0, 0xa9, 0x69, 0x53, 0xcf, 0x96, 0xe3, 0xa3, 0xe0, 0xb0, 0x86, 0x10, 0x48, 0xb5, 0xdc, 0xcd,
	0xd4, 0x95, 0x48, 0x2d, 0xcb, 0x9a, 0xd7, 0xd1, 0x99, 0xc9, 0x0c, 0x3e, 0x6e, 0x1c, 0xef, 0xd4,
	0x70, 0x7d, 0x4b, 0x8e, 0x8f, 0xa5, 0x33, 0x93, 0x7d, 0x14, 0xd2, 0xb6, 0x6f, 0x55, 0x35, 0x28,
	0xc7, 0x5b, 0xa0, 0xc8, 0xf3, 0x6e, 0x3a, 0xcf, 0x4f, 0xee, 0xdc, 0x1b, 0x05, 0xb4, 0x7a, 0x05,
	0x4b, 0xd1, 0xee, 0x26, 0x8c, 0xec, 0xa4, 0x8d, 0xac, 0xdf, 0xb1, 0xeb, 0x4d, 0xee, 0x2b, 0xc7,
	0x2e, 0x9d, 0xd0, 0x3a, 0x93, 0x97, 0x35, 0x65, 0x3d, 0xec, 0xa1, 0x5e, 0x64, 0x5d, 0x82, 0xab,
	0xff, 0xcc, 0x40, 0x31, 0x21, 0x27, 0xed, 0x29, 0x6d, 0x33, 0x33, 0xeb, 0x2a, 0x05, 0xf1, 0x8e,
	0xce, 0xa9, 0x4f, 0xef, 0x9c, 0xd9, 0xfb, 0x1a, 0x9c, 0xd2, 0x3c, 0xab, 0x7f, 0xc9, 0x40, 0x51,
	0xec, 0x9f, 0x22, 0xe2, 0xed, 0x74, 0xaa, 0xd4, 0x99, 0xdb, 0xaa, 0x4c, 0xd4, 0x7b, 0x58, 0x1a,
	0x3a, 0x9e, 0x19, 0x5c, 0x1b, 0x62, 0x75, 0x95, 0xf9, 0x9a, 0xb2, 0x97, 0x1f, 0x20, 0x2c, 0xe1,
	0x4b, 0x2f, 0x0d, 0x13, 0xa2, 0xaa, 0x05, 0x5f, 0xdc, 0x82, 0xf0, 0x3a, 0x36, 0xad, 0xd0, 0xb9,
	0xa0, 0xc9, 0xec, 0xe5, 0xf5, 0x92, 0x10, 0xc6, 0x75, 0x2c, 0x41, 0xe9, 0xa4, 0xe4, 0xf5, 0xb2,
	0x90, 0xc7, 0x9f, 0xfb, 0x0e, 0x00, 0xb7, 0x8b, 0xfb, 0x3e, 0x62, 0xb1, 0x98, 0xc8, 0xba, 0x1a,
	0x40, 0x51, 0xec, 0xcf, 0xf7, 0x4d, 0x95, 0xdc, 0xb6, 0x65, 0xaa, 0x56, 0x21, 0x27, 0xc2, 0x91,
	0xc1, 0xc9, 0x53, 0xf5, 0xd7, 0x50, 0x14, 0xfb, 0xf5, 0xbd, 0xcd, 0x8a, 0x6d, 0x5c, 0xc0, 0x9e,
	0x6f, 0x41, 0x29, 0x39, 0x22, 0x49, 0x11, 0x16, 0x0f, 0xbb, 0xfa, 0xc7, 0x9a, 0xde, 0x50, 0x1e,
	0xf0, 0x83, 0xae, 0x7d, 0xd0, 0xf4, 0x9e, 0xa6, 0x64, 0x9e, 0xff, 0x23, 0x0b, 0xa5, 0xe4, 0xce,
	0x49, 0xca, 0x50, 0xac, 0xf5, 0x7a, 0xad, 0x66, 0x47, 0xef, 0x0e, 0xfa, 0x9a, 0xf2, 0x80, 0x7c,
	0x03, 0x55, 0x01, 0x6f, 0x75, 0x9a, 0x1f, 0x6b, 0xad, 0x7e, 0xab, 0xd3, 0x3c, 0xec, 0xea, 0x8d,
	0x96, 0xae, 0xd5, 0xfb, 0xad, 0x6e, 0xa7, 0xfe, 0xbe, 0xd6, 0x69, 0x6a, 0x4a, 0x86, 0x54, 0xe0,
	0x49, 0xac, 0x16, 0x26, 0xb4, 0x06, 0x1a, 0xd1, 0xb5, 0x5a, 0xe3, 0xf7, 0x4a, 0x16, 0x1d, 0x0f,
	0x3a, 0x9d, 0x56, 0xa7, 0xa9, 0xcc, 0x11, 0x15, 0x1e, 0x69, 0x9d, 0x3e, 0x8f, 0xa2, 0xd3, 0xeb,
	0xea, 0xb5, 0x7a, 0xbf, 0xf5, 0xa1, 0xd6, 0xd7, 0x1a, 0xca, 0x3c, 0x59, 0x83, 0x87, 0xa8, 0x69,
	0x75, 0x9a, 0x0d, 0xad, 0xd7, 0x6f, 0x75, 0x6a, 0xdc, 0x8f, 0xb2, 0x40, 0xd6, 0x61, 0x55, 0xd7,
	0x6a, 0xf5, 0xf7, 0x5a, 0xe3, 0x26, 0x29, 0x47, 0x56, 0x81, 0x48, 0x5d, 0x92, 0xb3, 0x98, 0x8e,
	0x2a, 0xa1, 0xea, 0xb7, 0x8e, 0xb4, 0xee, 0xa0, 0xaf, 0xe4, 0xc9, 0xd7, 0xb0, 0x39, 0x15, 0xd1,
	0xd4, 0xbb, 0x83, 0xe3, 0xa3, 0x56, 0xa7, 0x75, 0x34, 0x38, 0x52, 0x0a, 0xcf, 0xaf, 0x64, 0x1f,
	0x8a, 0xfb, 0x2a, 0xc9, 0xc3, 0xfc, 0xa1, 0xae, 0xf1, 0x1c, 0x95, 0x20, 0xdf, 0xad, 0xd7, 0x07,
	0xc7, 0x2d, 0xad, 0xa1, 0x64, 0x78, 0x2c, 0xd1, 0x69, 0xd0, 0xd1, 0x7e, 0x77, 0xac, 0xd5, 0x79,
	0x8c, 0x59, 0x9e, 0xda, 0x64, 0x70, 0x73, 0x9c, 0x16, 0x7d, 0xa9, 0x32, 0x4f, 0x00, 0x72, 0xed,
	0x6e, 0xfd, 0x7b, 0xad, 0xa1, 0x2c, 0xf0, 0xdf, 0xf5, 0x76, 0xb7, 0xc7, 0x3f, 0xed, 0xa0, 0xfe,
	0xef, 0xcf, 0x1b, 0x99, 0xff, 0x7c, 0xde, 0xc8, 0xfc, 0xf7, 0xf3, 0x46, 0xe6, 0x6f, 0xff, 0xdf,
	0x78, 0xf0, 0x87, 0x97, 0xa7, 0x4e, 0x78, 0x36, 0x1e, 0x6e, 0x5b, 0xfe, 0xf9, 0x8b, 0x54, 0x25,
	0xbc, 0x38, 0xe0, 0x27, 0x3d, 0x3a, 0x8d, 0x3e, 0x9d, 0xbe, 0x30, 0x47, 0xce, 0x8b, 0x8b, 0x97,
	0xc3, 0x1c, 0xfe, 0x4f, 0xf2, 0xea, 0x87, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4f, 0x96, 0x12, 0x3e,
	0x67, 0x11, 0x00, 0x00,
}

func (m *RailwayState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RailwayState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RailwayState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signals) > 0 {
		for iNdEx := len(m.Signals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Sensors) > 0 {
		for iNdEx := len(m.Sensors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sensors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.Locs) > 0 {
		for iNdEx := len(m.Locs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Junctions) > 0 {
		for iNdEx := len(m.Junctions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Junctions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.CommandStations) > 0 {
		for iNdEx := len(m.CommandStations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommandStations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.BlockGroups) > 0 {
		for iNdEx := len(m.BlockGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if m.AutomaticControlRequested {
		i--
		if m.AutomaticControlRequested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.AutomaticControlActual {
		i--
		if m.AutomaticControlActual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.PowerRequested {
		i--
		if m.PowerRequested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.PowerActual {
		i--
		if m.PowerActual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IsVirtualAutorunEnabled {
		i--
		if m.IsVirtualAutorunEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsVirtualModeEnabled {
		i--
		if m.IsVirtualModeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsRunModeEnabled {
		i--
		if m.IsRunModeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *LocState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsEnabled {
		i--
		if m.IsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if m.F0Requested {
		i--
		if m.F0Requested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.F0Actual {
		i--
		if m.F0Actual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if m.IsReversing {
		i--
		if m.IsReversing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.DirectionRequested != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.DirectionRequested))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.DirectionActual != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.DirectionActual))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.SpeedInStepsRequested != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.SpeedInStepsRequested))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.SpeedInStepsActual != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.SpeedInStepsActual))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if len(m.StateText) > 0 {
		i -= len(m.StateText)
		copy(dAtA[i:], m.StateText)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.StateText)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if len(m.SpeedText) > 0 {
		i -= len(m.SpeedText)
		copy(dAtA[i:], m.SpeedText)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.SpeedText)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.SpeedRequested != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.SpeedRequested))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.SpeedActual != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.SpeedActual))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.CurrentBlockEnterSide != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.CurrentBlockEnterSide))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.CurrentBlock != nil {
		{
			size, err := m.CurrentBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.NextRoute != nil {
		{
			size, err := m.NextRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.IsCurrentRouteDurationExceeded {
		i--
		if m.IsCurrentRouteDurationExceeded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.WaitAfterCurrentRoute {
		i--
		if m.WaitAfterCurrentRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.CurrentRoute != nil {
		{
			size, err := m.CurrentRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.AutomaticState != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.AutomaticState))
		i--
		dAtA[i] = 0x68
	}
	if m.CanBeControlledAutomatically {
		i--
		if m.CanBeControlledAutomatically {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.ControlledAutomaticallyRequested {
		i--
		if m.ControlledAutomaticallyRequested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.ControlledAutomaticallyActual {
		i--
		if m.ControlledAutomaticallyActual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandStationState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStationState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandStationState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HardwareModules) > 0 {
		for iNdEx := len(m.HardwareModules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HardwareModules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HardwareModule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardwareModule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardwareModule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SshUrl) > 0 {
		i -= len(m.SshUrl)
		copy(dAtA[i:], m.SshUrl)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.SshUrl)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DccGeneratorUrl) > 0 {
		i -= len(m.DccGeneratorUrl)
		copy(dAtA[i:], m.DccGeneratorUrl)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.DccGeneratorUrl)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MetricsUrl) > 0 {
		i -= len(m.MetricsUrl)
		copy(dAtA[i:], m.MetricsUrl)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.MetricsUrl)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SecondsSinceLastUpdated != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.SecondsSinceLastUpdated))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ErrorMessages) > 0 {
		for iNdEx := len(m.ErrorMessages) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ErrorMessages[iNdEx])
			copy(dAtA[i:], m.ErrorMessages[iNdEx])
			i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.ErrorMessages[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LastUpdatedAt) > 0 {
		i -= len(m.LastUpdatedAt)
		copy(dAtA[i:], m.LastUpdatedAt)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.LastUpdatedAt)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Uptime != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.Uptime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBrStateTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasWaitingLoc {
		i--
		if m.HasWaitingLoc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.IsStation {
		i--
		if m.IsStation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.IsDeadend {
		i--
		if m.IsDeadend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ClosedRequested {
		i--
		if m.ClosedRequested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.ClosedActual {
		i--
		if m.ClosedActual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.State != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.LockedBy != nil {
		{
			size, err := m.LockedBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockGroupState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockGroupState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockGroupState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JunctionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunctionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JunctionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Switch != nil {
		{
			size, err := m.Switch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwitchState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DirectionRequested != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.DirectionRequested))
		i--
		dAtA[i] = 0x10
	}
	if m.DirectionActual != 0 {
		i = encodeVarintBrStateTypes(dAtA, i, uint64(m.DirectionActual))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OutputState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinaryOutput != nil {
		{
			size, err := m.BinaryOutput.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOutputState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOutputState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOutputState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ActiveRequested {
		i--
		if m.ActiveRequested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ActiveActual {
		i--
		if m.ActiveActual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SensorState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrStateTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBrStateTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovBrStateTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RailwayState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsRunModeEnabled {
		n += 2
	}
	if m.IsVirtualModeEnabled {
		n += 2
	}
	if m.IsVirtualAutorunEnabled {
		n += 2
	}
	if m.PowerActual {
		n += 2
	}
	if m.PowerRequested {
		n += 2
	}
	if m.AutomaticControlActual {
		n += 2
	}
	if m.AutomaticControlRequested {
		n += 2
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.BlockGroups) > 0 {
		for _, e := range m.BlockGroups {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.CommandStations) > 0 {
		for _, e := range m.CommandStations {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.Junctions) > 0 {
		for _, e := range m.Junctions {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.Locs) > 0 {
		for _, e := range m.Locs {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.Sensors) > 0 {
		for _, e := range m.Sensors {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if len(m.Signals) > 0 {
		for _, e := range m.Signals {
			l = e.Size()
			n += 2 + l + sovBrStateTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.ControlledAutomaticallyActual {
		n += 2
	}
	if m.ControlledAutomaticallyRequested {
		n += 2
	}
	if m.CanBeControlledAutomatically {
		n += 2
	}
	if m.AutomaticState != 0 {
		n += 1 + sovBrStateTypes(uint64(m.AutomaticState))
	}
	if m.CurrentRoute != nil {
		l = m.CurrentRoute.Size()
		n += 2 + l + sovBrStateTypes(uint64(l))
	}
	if m.WaitAfterCurrentRoute {
		n += 3
	}
	if m.IsCurrentRouteDurationExceeded {
		n += 3
	}
	if m.NextRoute != nil {
		l = m.NextRoute.Size()
		n += 2 + l + sovBrStateTypes(uint64(l))
	}
	if m.CurrentBlock != nil {
		l = m.CurrentBlock.Size()
		n += 2 + l + sovBrStateTypes(uint64(l))
	}
	if m.CurrentBlockEnterSide != 0 {
		n += 2 + sovBrStateTypes(uint64(m.CurrentBlockEnterSide))
	}
	if m.SpeedActual != 0 {
		n += 2 + sovBrStateTypes(uint64(m.SpeedActual))
	}
	if m.SpeedRequested != 0 {
		n += 2 + sovBrStateTypes(uint64(m.SpeedRequested))
	}
	l = len(m.SpeedText)
	if l > 0 {
		n += 2 + l + sovBrStateTypes(uint64(l))
	}
	l = len(m.StateText)
	if l > 0 {
		n += 2 + l + sovBrStateTypes(uint64(l))
	}
	if m.SpeedInStepsActual != 0 {
		n += 2 + sovBrStateTypes(uint64(m.SpeedInStepsActual))
	}
	if m.SpeedInStepsRequested != 0 {
		n += 2 + sovBrStateTypes(uint64(m.SpeedInStepsRequested))
	}
	if m.DirectionActual != 0 {
		n += 2 + sovBrStateTypes(uint64(m.DirectionActual))
	}
	if m.DirectionRequested != 0 {
		n += 2 + sovBrStateTypes(uint64(m.DirectionRequested))
	}
	if m.IsReversing {
		n += 3
	}
	if m.F0Actual {
		n += 3
	}
	if m.F0Requested {
		n += 3
	}
	if m.IsEnabled {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandStationState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if len(m.HardwareModules) > 0 {
		for _, e := range m.HardwareModules {
			l = e.Size()
			n += 1 + l + sovBrStateTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HardwareModule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.Uptime != 0 {
		n += 1 + sovBrStateTypes(uint64(m.Uptime))
	}
	l = len(m.LastUpdatedAt)
	if l > 0 {
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if len(m.ErrorMessages) > 0 {
		for _, s := range m.ErrorMessages {
			l = len(s)
			n += 1 + l + sovBrStateTypes(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.SecondsSinceLastUpdated != 0 {
		n += 1 + sovBrStateTypes(uint64(m.SecondsSinceLastUpdated))
	}
	l = len(m.MetricsUrl)
	if l > 0 {
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	l = len(m.DccGeneratorUrl)
	if l > 0 {
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	l = len(m.SshUrl)
	if l > 0 {
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.LockedBy != nil {
		l = m.LockedBy.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBrStateTypes(uint64(m.State))
	}
	if m.ClosedActual {
		n += 2
	}
	if m.ClosedRequested {
		n += 2
	}
	if m.IsDeadend {
		n += 3
	}
	if m.IsStation {
		n += 3
	}
	if m.HasWaitingLoc {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockGroupState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JunctionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.Switch != nil {
		l = m.Switch.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwitchState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DirectionActual != 0 {
		n += 1 + sovBrStateTypes(uint64(m.DirectionActual))
	}
	if m.DirectionRequested != 0 {
		n += 1 + sovBrStateTypes(uint64(m.DirectionRequested))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OutputState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.BinaryOutput != nil {
		l = m.BinaryOutput.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinaryOutputState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveActual {
		n += 2
	}
	if m.ActiveRequested {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.Active {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovBrStateTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBrStateTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBrStateTypes(x uint64) (n int) {
	return sovBrStateTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RailwayState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RailwayState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RailwayState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRunModeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRunModeEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtualModeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtualModeEnabled = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtualAutorunEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtualAutorunEnabled = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerActual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PowerActual = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerRequested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PowerRequested = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticControlActual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutomaticControlActual = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticControlRequested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutomaticControlRequested = bool(v != 0)
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockRef{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockGroups = append(m.BlockGroups, &BlockGroupRef{})
			if err := m.BlockGroups[len(m.BlockGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandStations = append(m.CommandStations, &CommandStationRef{})
			if err := m.CommandStations[len(m.CommandStations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Junctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Junctions = append(m.Junctions, &JunctionRef{})
			if err := m.Junctions[len(m.Junctions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locs = append(m.Locs, &LocRef{})
			if err := m.Locs[len(m.Locs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &OutputRef{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteRef{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sensors = append(m.Sensors, &SensorRef{})
			if err := m.Sensors[len(m.Sensors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signals = append(m.Signals, &SignalRef{})
			if err := m.Signals[len(m.Signals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Loc{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlledAutomaticallyActual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControlledAutomaticallyActual = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlledAutomaticallyRequested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControlledAutomaticallyRequested = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanBeControlledAutomatically", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanBeControlledAutomatically = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticState", wireType)
			}
			m.AutomaticState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutomaticState |= AutoLocState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentRoute == nil {
				m.CurrentRoute = &RouteRef{}
			}
			if err := m.CurrentRoute.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitAfterCurrentRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WaitAfterCurrentRoute = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCurrentRouteDurationExceeded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCurrentRouteDurationExceeded = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextRoute == nil {
				m.NextRoute = &RouteRef{}
			}
			if err := m.NextRoute.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentBlock == nil {
				m.CurrentBlock = &BlockRef{}
			}
			if err := m.CurrentBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlockEnterSide", wireType)
			}
			m.CurrentBlockEnterSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBlockEnterSide |= BlockSide(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedActual", wireType)
			}
			m.SpeedActual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedActual |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedRequested", wireType)
			}
			m.SpeedRequested = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedRequested |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpeedText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedInStepsActual", wireType)
			}
			m.SpeedInStepsActual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedInStepsActual |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedInStepsRequested", wireType)
			}
			m.SpeedInStepsRequested = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedInStepsRequested |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionActual", wireType)
			}
			m.DirectionActual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectionActual |= LocDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionRequested", wireType)
			}
			m.DirectionRequested = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectionRequested |= LocDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReversing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReversing = bool(v != 0)
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F0Actual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.F0Actual = bool(v != 0)
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F0Requested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.F0Requested = bool(v != 0)
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStationState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStationState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStationState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &CommandStation{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareModules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareModules = append(m.HardwareModules, &HardwareModule{})
			if err := m.HardwareModules[len(m.HardwareModules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardwareModule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardwareModule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardwareModule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessages = append(m.ErrorMessages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsSinceLastUpdated", wireType)
			}
			m.SecondsSinceLastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondsSinceLastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricsUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DccGeneratorUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DccGeneratorUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Block{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockedBy == nil {
				m.LockedBy = &LocRef{}
			}
			if err := m.LockedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BlockStateState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedActual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClosedActual = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedRequested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClosedRequested = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeadend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeadend = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStation = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasWaitingLoc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasWaitingLoc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockGroupState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockGroupState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockGroupState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &BlockGroup{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunctionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunctionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunctionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Junction{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Switch == nil {
				m.Switch = &SwitchState{}
			}
			if err := m.Switch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionActual", wireType)
			}
			m.DirectionActual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectionActual |= SwitchDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionRequested", wireType)
			}
			m.DirectionRequested = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectionRequested |= SwitchDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Output{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinaryOutput == nil {
				m.BinaryOutput = &BinaryOutputState{}
			}
			if err := m.BinaryOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOutputState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOutputState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOutputState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveActual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveActual = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveRequested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveRequested = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Route{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Sensor{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Signal{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrStateTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrStateTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrStateTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrStateTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrStateTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBrStateTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBrStateTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBrStateTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBrStateTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrStateTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBrStateTypes = fmt.Errorf("proto: unexpected end of group")
)
